# coding: utf-8

"""
    Cloudsmith API (v1)

    The API to the Cloudsmith Service  # noqa: E501

    OpenAPI spec version: v1
    Contact: support@cloudsmith.io
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from cloudsmith_api.configuration import Configuration


class RepositoryRequestPatch(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'content_kind': 'str',
        'contextual_auth_realm': 'bool',
        'copy_own': 'bool',
        'copy_packages': 'str',
        'default_privilege': 'str',
        'delete_own': 'bool',
        'delete_packages': 'str',
        'description': 'str',
        'distributes': 'list[str]',
        'docker_refresh_tokens_enabled': 'bool',
        'index_files': 'bool',
        'move_own': 'bool',
        'move_packages': 'str',
        'name': 'str',
        'proxy_npmjs': 'bool',
        'proxy_pypi': 'bool',
        'raw_package_index_enabled': 'bool',
        'raw_package_index_signatures_enabled': 'bool',
        'replace_packages': 'str',
        'replace_packages_by_default': 'bool',
        'repository_type_str': 'str',
        'resync_own': 'bool',
        'resync_packages': 'str',
        'scan_own': 'bool',
        'scan_packages': 'str',
        'show_setup_all': 'bool',
        'slug': 'str',
        'strict_npm_validation': 'bool',
        'use_debian_labels': 'bool',
        'use_default_cargo_upstream': 'bool',
        'use_noarch_packages': 'bool',
        'use_source_packages': 'bool',
        'use_vulnerability_scanning': 'bool',
        'user_entitlements_enabled': 'bool',
        'view_statistics': 'str'
    }

    attribute_map = {
        'content_kind': 'content_kind',
        'contextual_auth_realm': 'contextual_auth_realm',
        'copy_own': 'copy_own',
        'copy_packages': 'copy_packages',
        'default_privilege': 'default_privilege',
        'delete_own': 'delete_own',
        'delete_packages': 'delete_packages',
        'description': 'description',
        'distributes': 'distributes',
        'docker_refresh_tokens_enabled': 'docker_refresh_tokens_enabled',
        'index_files': 'index_files',
        'move_own': 'move_own',
        'move_packages': 'move_packages',
        'name': 'name',
        'proxy_npmjs': 'proxy_npmjs',
        'proxy_pypi': 'proxy_pypi',
        'raw_package_index_enabled': 'raw_package_index_enabled',
        'raw_package_index_signatures_enabled': 'raw_package_index_signatures_enabled',
        'replace_packages': 'replace_packages',
        'replace_packages_by_default': 'replace_packages_by_default',
        'repository_type_str': 'repository_type_str',
        'resync_own': 'resync_own',
        'resync_packages': 'resync_packages',
        'scan_own': 'scan_own',
        'scan_packages': 'scan_packages',
        'show_setup_all': 'show_setup_all',
        'slug': 'slug',
        'strict_npm_validation': 'strict_npm_validation',
        'use_debian_labels': 'use_debian_labels',
        'use_default_cargo_upstream': 'use_default_cargo_upstream',
        'use_noarch_packages': 'use_noarch_packages',
        'use_source_packages': 'use_source_packages',
        'use_vulnerability_scanning': 'use_vulnerability_scanning',
        'user_entitlements_enabled': 'user_entitlements_enabled',
        'view_statistics': 'view_statistics'
    }

    def __init__(self, content_kind='Standard', contextual_auth_realm=None, copy_own=None, copy_packages='Read', default_privilege='None', delete_own=None, delete_packages='Admin', description=None, distributes=None, docker_refresh_tokens_enabled=None, index_files=None, move_own=None, move_packages='Admin', name=None, proxy_npmjs=None, proxy_pypi=None, raw_package_index_enabled=None, raw_package_index_signatures_enabled=None, replace_packages='Write', replace_packages_by_default=None, repository_type_str='Public', resync_own=None, resync_packages='Admin', scan_own=None, scan_packages='Read', show_setup_all=None, slug=None, strict_npm_validation=None, use_debian_labels=None, use_default_cargo_upstream=None, use_noarch_packages=None, use_source_packages=None, use_vulnerability_scanning=None, user_entitlements_enabled=None, view_statistics='Read', _configuration=None):  # noqa: E501
        """RepositoryRequestPatch - a model defined in Swagger"""  # noqa: E501
        if _configuration is None:
            _configuration = Configuration()
        self._configuration = _configuration

        self._content_kind = None
        self._contextual_auth_realm = None
        self._copy_own = None
        self._copy_packages = None
        self._default_privilege = None
        self._delete_own = None
        self._delete_packages = None
        self._description = None
        self._distributes = None
        self._docker_refresh_tokens_enabled = None
        self._index_files = None
        self._move_own = None
        self._move_packages = None
        self._name = None
        self._proxy_npmjs = None
        self._proxy_pypi = None
        self._raw_package_index_enabled = None
        self._raw_package_index_signatures_enabled = None
        self._replace_packages = None
        self._replace_packages_by_default = None
        self._repository_type_str = None
        self._resync_own = None
        self._resync_packages = None
        self._scan_own = None
        self._scan_packages = None
        self._show_setup_all = None
        self._slug = None
        self._strict_npm_validation = None
        self._use_debian_labels = None
        self._use_default_cargo_upstream = None
        self._use_noarch_packages = None
        self._use_source_packages = None
        self._use_vulnerability_scanning = None
        self._user_entitlements_enabled = None
        self._view_statistics = None
        self.discriminator = None

        if content_kind is not None:
            self.content_kind = content_kind
        if contextual_auth_realm is not None:
            self.contextual_auth_realm = contextual_auth_realm
        if copy_own is not None:
            self.copy_own = copy_own
        if copy_packages is not None:
            self.copy_packages = copy_packages
        if default_privilege is not None:
            self.default_privilege = default_privilege
        if delete_own is not None:
            self.delete_own = delete_own
        if delete_packages is not None:
            self.delete_packages = delete_packages
        if description is not None:
            self.description = description
        if distributes is not None:
            self.distributes = distributes
        if docker_refresh_tokens_enabled is not None:
            self.docker_refresh_tokens_enabled = docker_refresh_tokens_enabled
        if index_files is not None:
            self.index_files = index_files
        if move_own is not None:
            self.move_own = move_own
        if move_packages is not None:
            self.move_packages = move_packages
        if name is not None:
            self.name = name
        if proxy_npmjs is not None:
            self.proxy_npmjs = proxy_npmjs
        if proxy_pypi is not None:
            self.proxy_pypi = proxy_pypi
        if raw_package_index_enabled is not None:
            self.raw_package_index_enabled = raw_package_index_enabled
        if raw_package_index_signatures_enabled is not None:
            self.raw_package_index_signatures_enabled = raw_package_index_signatures_enabled
        if replace_packages is not None:
            self.replace_packages = replace_packages
        if replace_packages_by_default is not None:
            self.replace_packages_by_default = replace_packages_by_default
        if repository_type_str is not None:
            self.repository_type_str = repository_type_str
        if resync_own is not None:
            self.resync_own = resync_own
        if resync_packages is not None:
            self.resync_packages = resync_packages
        if scan_own is not None:
            self.scan_own = scan_own
        if scan_packages is not None:
            self.scan_packages = scan_packages
        if show_setup_all is not None:
            self.show_setup_all = show_setup_all
        if slug is not None:
            self.slug = slug
        if strict_npm_validation is not None:
            self.strict_npm_validation = strict_npm_validation
        if use_debian_labels is not None:
            self.use_debian_labels = use_debian_labels
        if use_default_cargo_upstream is not None:
            self.use_default_cargo_upstream = use_default_cargo_upstream
        if use_noarch_packages is not None:
            self.use_noarch_packages = use_noarch_packages
        if use_source_packages is not None:
            self.use_source_packages = use_source_packages
        if use_vulnerability_scanning is not None:
            self.use_vulnerability_scanning = use_vulnerability_scanning
        if user_entitlements_enabled is not None:
            self.user_entitlements_enabled = user_entitlements_enabled
        if view_statistics is not None:
            self.view_statistics = view_statistics

    @property
    def content_kind(self):
        """Gets the content_kind of this RepositoryRequestPatch.

        The repository content kind determines whether this repository contains packages, or provides a distribution of packages from other repositories. You can only select the content kind at repository creation time.

        :return: The content_kind of this RepositoryRequestPatch.
        :rtype: str
        """
        return self._content_kind

    @content_kind.setter
    def content_kind(self, content_kind):
        """Sets the content_kind of this RepositoryRequestPatch.

        The repository content kind determines whether this repository contains packages, or provides a distribution of packages from other repositories. You can only select the content kind at repository creation time.

        :param content_kind: The content_kind of this RepositoryRequestPatch.
        :type: str
        """
        allowed_values = ["Standard", "Distribution", "Upstream"]  # noqa: E501
        if (self._configuration.client_side_validation and
                content_kind not in allowed_values):
            raise ValueError(
                "Invalid value for `content_kind` ({0}), must be one of {1}"  # noqa: E501
                .format(content_kind, allowed_values)
            )

        self._content_kind = content_kind

    @property
    def contextual_auth_realm(self):
        """Gets the contextual_auth_realm of this RepositoryRequestPatch.

        If checked, missing credentials for this repository where basic authentication is required shall present an enriched value in the 'WWW-Authenticate' header containing the namespace and repository. This can be useful for tooling such as SBT where the authentication realm is used to distinguish and disambiguate credentials.

        :return: The contextual_auth_realm of this RepositoryRequestPatch.
        :rtype: bool
        """
        return self._contextual_auth_realm

    @contextual_auth_realm.setter
    def contextual_auth_realm(self, contextual_auth_realm):
        """Sets the contextual_auth_realm of this RepositoryRequestPatch.

        If checked, missing credentials for this repository where basic authentication is required shall present an enriched value in the 'WWW-Authenticate' header containing the namespace and repository. This can be useful for tooling such as SBT where the authentication realm is used to distinguish and disambiguate credentials.

        :param contextual_auth_realm: The contextual_auth_realm of this RepositoryRequestPatch.
        :type: bool
        """

        self._contextual_auth_realm = contextual_auth_realm

    @property
    def copy_own(self):
        """Gets the copy_own of this RepositoryRequestPatch.

        If checked, users can copy any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the 'Access Controls' section of the repository, and any inherited from the org.

        :return: The copy_own of this RepositoryRequestPatch.
        :rtype: bool
        """
        return self._copy_own

    @copy_own.setter
    def copy_own(self, copy_own):
        """Sets the copy_own of this RepositoryRequestPatch.

        If checked, users can copy any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the 'Access Controls' section of the repository, and any inherited from the org.

        :param copy_own: The copy_own of this RepositoryRequestPatch.
        :type: bool
        """

        self._copy_own = copy_own

    @property
    def copy_packages(self):
        """Gets the copy_packages of this RepositoryRequestPatch.

        This defines the minimum level of privilege required for a user to copy packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific copy setting.

        :return: The copy_packages of this RepositoryRequestPatch.
        :rtype: str
        """
        return self._copy_packages

    @copy_packages.setter
    def copy_packages(self, copy_packages):
        """Sets the copy_packages of this RepositoryRequestPatch.

        This defines the minimum level of privilege required for a user to copy packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific copy setting.

        :param copy_packages: The copy_packages of this RepositoryRequestPatch.
        :type: str
        """
        allowed_values = ["Admin", "Write", "Read"]  # noqa: E501
        if (self._configuration.client_side_validation and
                copy_packages not in allowed_values):
            raise ValueError(
                "Invalid value for `copy_packages` ({0}), must be one of {1}"  # noqa: E501
                .format(copy_packages, allowed_values)
            )

        self._copy_packages = copy_packages

    @property
    def default_privilege(self):
        """Gets the default_privilege of this RepositoryRequestPatch.

        This defines the default level of privilege that all of your organization members have for this repository. This does not include collaborators, but applies to any member of the org regardless of their own membership role (i.e. it applies to owners, managers and members). Be careful if setting this to admin, because any member will be able to change settings.

        :return: The default_privilege of this RepositoryRequestPatch.
        :rtype: str
        """
        return self._default_privilege

    @default_privilege.setter
    def default_privilege(self, default_privilege):
        """Sets the default_privilege of this RepositoryRequestPatch.

        This defines the default level of privilege that all of your organization members have for this repository. This does not include collaborators, but applies to any member of the org regardless of their own membership role (i.e. it applies to owners, managers and members). Be careful if setting this to admin, because any member will be able to change settings.

        :param default_privilege: The default_privilege of this RepositoryRequestPatch.
        :type: str
        """
        allowed_values = ["Admin", "Write", "Read", "None"]  # noqa: E501
        if (self._configuration.client_side_validation and
                default_privilege not in allowed_values):
            raise ValueError(
                "Invalid value for `default_privilege` ({0}), must be one of {1}"  # noqa: E501
                .format(default_privilege, allowed_values)
            )

        self._default_privilege = default_privilege

    @property
    def delete_own(self):
        """Gets the delete_own of this RepositoryRequestPatch.

        If checked, users can delete any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the 'Access Controls' section of the repository, and any inherited from the org.

        :return: The delete_own of this RepositoryRequestPatch.
        :rtype: bool
        """
        return self._delete_own

    @delete_own.setter
    def delete_own(self, delete_own):
        """Sets the delete_own of this RepositoryRequestPatch.

        If checked, users can delete any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the 'Access Controls' section of the repository, and any inherited from the org.

        :param delete_own: The delete_own of this RepositoryRequestPatch.
        :type: bool
        """

        self._delete_own = delete_own

    @property
    def delete_packages(self):
        """Gets the delete_packages of this RepositoryRequestPatch.

        This defines the minimum level of privilege required for a user to delete packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific delete setting.

        :return: The delete_packages of this RepositoryRequestPatch.
        :rtype: str
        """
        return self._delete_packages

    @delete_packages.setter
    def delete_packages(self, delete_packages):
        """Sets the delete_packages of this RepositoryRequestPatch.

        This defines the minimum level of privilege required for a user to delete packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific delete setting.

        :param delete_packages: The delete_packages of this RepositoryRequestPatch.
        :type: str
        """
        allowed_values = ["Admin", "Write"]  # noqa: E501
        if (self._configuration.client_side_validation and
                delete_packages not in allowed_values):
            raise ValueError(
                "Invalid value for `delete_packages` ({0}), must be one of {1}"  # noqa: E501
                .format(delete_packages, allowed_values)
            )

        self._delete_packages = delete_packages

    @property
    def description(self):
        """Gets the description of this RepositoryRequestPatch.

        A description of the repository's purpose/contents.

        :return: The description of this RepositoryRequestPatch.
        :rtype: str
        """
        return self._description

    @description.setter
    def description(self, description):
        """Sets the description of this RepositoryRequestPatch.

        A description of the repository's purpose/contents.

        :param description: The description of this RepositoryRequestPatch.
        :type: str
        """

        self._description = description

    @property
    def distributes(self):
        """Gets the distributes of this RepositoryRequestPatch.

        The repositories distributed through this repo. Adding repos here is only valid if the content_kind is DISTRIBUTION.

        :return: The distributes of this RepositoryRequestPatch.
        :rtype: list[str]
        """
        return self._distributes

    @distributes.setter
    def distributes(self, distributes):
        """Sets the distributes of this RepositoryRequestPatch.

        The repositories distributed through this repo. Adding repos here is only valid if the content_kind is DISTRIBUTION.

        :param distributes: The distributes of this RepositoryRequestPatch.
        :type: list[str]
        """

        self._distributes = distributes

    @property
    def docker_refresh_tokens_enabled(self):
        """Gets the docker_refresh_tokens_enabled of this RepositoryRequestPatch.

        If checked, refresh tokens will be issued in addition to access tokens for Docker authentication. This allows unlimited extension of the lifetime of access tokens.

        :return: The docker_refresh_tokens_enabled of this RepositoryRequestPatch.
        :rtype: bool
        """
        return self._docker_refresh_tokens_enabled

    @docker_refresh_tokens_enabled.setter
    def docker_refresh_tokens_enabled(self, docker_refresh_tokens_enabled):
        """Sets the docker_refresh_tokens_enabled of this RepositoryRequestPatch.

        If checked, refresh tokens will be issued in addition to access tokens for Docker authentication. This allows unlimited extension of the lifetime of access tokens.

        :param docker_refresh_tokens_enabled: The docker_refresh_tokens_enabled of this RepositoryRequestPatch.
        :type: bool
        """

        self._docker_refresh_tokens_enabled = docker_refresh_tokens_enabled

    @property
    def index_files(self):
        """Gets the index_files of this RepositoryRequestPatch.

        If checked, files contained in packages will be indexed, which increase the synchronisation time required for packages. Note that it is recommended you keep this enabled unless the synchronisation time is significantly impacted.

        :return: The index_files of this RepositoryRequestPatch.
        :rtype: bool
        """
        return self._index_files

    @index_files.setter
    def index_files(self, index_files):
        """Sets the index_files of this RepositoryRequestPatch.

        If checked, files contained in packages will be indexed, which increase the synchronisation time required for packages. Note that it is recommended you keep this enabled unless the synchronisation time is significantly impacted.

        :param index_files: The index_files of this RepositoryRequestPatch.
        :type: bool
        """

        self._index_files = index_files

    @property
    def move_own(self):
        """Gets the move_own of this RepositoryRequestPatch.

        If checked, users can move any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the 'Access Controls' section of the repository, and any inherited from the org.

        :return: The move_own of this RepositoryRequestPatch.
        :rtype: bool
        """
        return self._move_own

    @move_own.setter
    def move_own(self, move_own):
        """Sets the move_own of this RepositoryRequestPatch.

        If checked, users can move any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the 'Access Controls' section of the repository, and any inherited from the org.

        :param move_own: The move_own of this RepositoryRequestPatch.
        :type: bool
        """

        self._move_own = move_own

    @property
    def move_packages(self):
        """Gets the move_packages of this RepositoryRequestPatch.

        This defines the minimum level of privilege required for a user to move packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific move setting.

        :return: The move_packages of this RepositoryRequestPatch.
        :rtype: str
        """
        return self._move_packages

    @move_packages.setter
    def move_packages(self, move_packages):
        """Sets the move_packages of this RepositoryRequestPatch.

        This defines the minimum level of privilege required for a user to move packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific move setting.

        :param move_packages: The move_packages of this RepositoryRequestPatch.
        :type: str
        """
        allowed_values = ["Admin", "Write", "Read"]  # noqa: E501
        if (self._configuration.client_side_validation and
                move_packages not in allowed_values):
            raise ValueError(
                "Invalid value for `move_packages` ({0}), must be one of {1}"  # noqa: E501
                .format(move_packages, allowed_values)
            )

        self._move_packages = move_packages

    @property
    def name(self):
        """Gets the name of this RepositoryRequestPatch.

        A descriptive name for the repository.

        :return: The name of this RepositoryRequestPatch.
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this RepositoryRequestPatch.

        A descriptive name for the repository.

        :param name: The name of this RepositoryRequestPatch.
        :type: str
        """
        if (self._configuration.client_side_validation and
                name is not None and len(name) > 50):
            raise ValueError("Invalid value for `name`, length must be less than or equal to `50`")  # noqa: E501
        if (self._configuration.client_side_validation and
                name is not None and len(name) < 1):
            raise ValueError("Invalid value for `name`, length must be greater than or equal to `1`")  # noqa: E501
        if (self._configuration.client_side_validation and
                name is not None and not re.search('^\\w[\\w \\-\'\\.\/()]+$', name)):  # noqa: E501
            raise ValueError(r"Invalid value for `name`, must be a follow pattern or equal to `/^\\w[\\w \\-'\\.\/()]+$/`")  # noqa: E501

        self._name = name

    @property
    def proxy_npmjs(self):
        """Gets the proxy_npmjs of this RepositoryRequestPatch.

        If checked, Npm packages that are not in the repository when requested by clients will automatically be proxied from the public npmjs.org registry. If there is at least one version for a package, others will not be proxied.

        :return: The proxy_npmjs of this RepositoryRequestPatch.
        :rtype: bool
        """
        return self._proxy_npmjs

    @proxy_npmjs.setter
    def proxy_npmjs(self, proxy_npmjs):
        """Sets the proxy_npmjs of this RepositoryRequestPatch.

        If checked, Npm packages that are not in the repository when requested by clients will automatically be proxied from the public npmjs.org registry. If there is at least one version for a package, others will not be proxied.

        :param proxy_npmjs: The proxy_npmjs of this RepositoryRequestPatch.
        :type: bool
        """

        self._proxy_npmjs = proxy_npmjs

    @property
    def proxy_pypi(self):
        """Gets the proxy_pypi of this RepositoryRequestPatch.

        If checked, Python packages that are not in the repository when requested by clients will automatically be proxied from the public pypi.python.org registry. If there is at least one version for a package, others will not be proxied.

        :return: The proxy_pypi of this RepositoryRequestPatch.
        :rtype: bool
        """
        return self._proxy_pypi

    @proxy_pypi.setter
    def proxy_pypi(self, proxy_pypi):
        """Sets the proxy_pypi of this RepositoryRequestPatch.

        If checked, Python packages that are not in the repository when requested by clients will automatically be proxied from the public pypi.python.org registry. If there is at least one version for a package, others will not be proxied.

        :param proxy_pypi: The proxy_pypi of this RepositoryRequestPatch.
        :type: bool
        """

        self._proxy_pypi = proxy_pypi

    @property
    def raw_package_index_enabled(self):
        """Gets the raw_package_index_enabled of this RepositoryRequestPatch.

        If checked, HTML and JSON indexes will be generated that list all available raw packages in the repository.

        :return: The raw_package_index_enabled of this RepositoryRequestPatch.
        :rtype: bool
        """
        return self._raw_package_index_enabled

    @raw_package_index_enabled.setter
    def raw_package_index_enabled(self, raw_package_index_enabled):
        """Sets the raw_package_index_enabled of this RepositoryRequestPatch.

        If checked, HTML and JSON indexes will be generated that list all available raw packages in the repository.

        :param raw_package_index_enabled: The raw_package_index_enabled of this RepositoryRequestPatch.
        :type: bool
        """

        self._raw_package_index_enabled = raw_package_index_enabled

    @property
    def raw_package_index_signatures_enabled(self):
        """Gets the raw_package_index_signatures_enabled of this RepositoryRequestPatch.

        If checked, the HTML and JSON indexes will display raw package GPG signatures alongside the index packages.

        :return: The raw_package_index_signatures_enabled of this RepositoryRequestPatch.
        :rtype: bool
        """
        return self._raw_package_index_signatures_enabled

    @raw_package_index_signatures_enabled.setter
    def raw_package_index_signatures_enabled(self, raw_package_index_signatures_enabled):
        """Sets the raw_package_index_signatures_enabled of this RepositoryRequestPatch.

        If checked, the HTML and JSON indexes will display raw package GPG signatures alongside the index packages.

        :param raw_package_index_signatures_enabled: The raw_package_index_signatures_enabled of this RepositoryRequestPatch.
        :type: bool
        """

        self._raw_package_index_signatures_enabled = raw_package_index_signatures_enabled

    @property
    def replace_packages(self):
        """Gets the replace_packages of this RepositoryRequestPatch.

        This defines the minimum level of privilege required for a user to republish packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific republish setting. Please note that the user still requires the privilege to delete packages that will be replaced by the new package; otherwise the republish will fail.

        :return: The replace_packages of this RepositoryRequestPatch.
        :rtype: str
        """
        return self._replace_packages

    @replace_packages.setter
    def replace_packages(self, replace_packages):
        """Sets the replace_packages of this RepositoryRequestPatch.

        This defines the minimum level of privilege required for a user to republish packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific republish setting. Please note that the user still requires the privilege to delete packages that will be replaced by the new package; otherwise the republish will fail.

        :param replace_packages: The replace_packages of this RepositoryRequestPatch.
        :type: str
        """
        allowed_values = ["Admin", "Write"]  # noqa: E501
        if (self._configuration.client_side_validation and
                replace_packages not in allowed_values):
            raise ValueError(
                "Invalid value for `replace_packages` ({0}), must be one of {1}"  # noqa: E501
                .format(replace_packages, allowed_values)
            )

        self._replace_packages = replace_packages

    @property
    def replace_packages_by_default(self):
        """Gets the replace_packages_by_default of this RepositoryRequestPatch.

        If checked, uploaded packages will overwrite/replace any others with the same attributes (e.g. same version) by default. This only applies if the user has the required privilege for the republishing AND has the required privilege to delete existing packages that they don't own.

        :return: The replace_packages_by_default of this RepositoryRequestPatch.
        :rtype: bool
        """
        return self._replace_packages_by_default

    @replace_packages_by_default.setter
    def replace_packages_by_default(self, replace_packages_by_default):
        """Sets the replace_packages_by_default of this RepositoryRequestPatch.

        If checked, uploaded packages will overwrite/replace any others with the same attributes (e.g. same version) by default. This only applies if the user has the required privilege for the republishing AND has the required privilege to delete existing packages that they don't own.

        :param replace_packages_by_default: The replace_packages_by_default of this RepositoryRequestPatch.
        :type: bool
        """

        self._replace_packages_by_default = replace_packages_by_default

    @property
    def repository_type_str(self):
        """Gets the repository_type_str of this RepositoryRequestPatch.

        The repository type changes how it is accessed and billed. Private repositories are visible only to you or authorized delegates. Public repositories are visible to all Cloudsmith users.

        :return: The repository_type_str of this RepositoryRequestPatch.
        :rtype: str
        """
        return self._repository_type_str

    @repository_type_str.setter
    def repository_type_str(self, repository_type_str):
        """Sets the repository_type_str of this RepositoryRequestPatch.

        The repository type changes how it is accessed and billed. Private repositories are visible only to you or authorized delegates. Public repositories are visible to all Cloudsmith users.

        :param repository_type_str: The repository_type_str of this RepositoryRequestPatch.
        :type: str
        """
        allowed_values = ["Public", "Private"]  # noqa: E501
        if (self._configuration.client_side_validation and
                repository_type_str not in allowed_values):
            raise ValueError(
                "Invalid value for `repository_type_str` ({0}), must be one of {1}"  # noqa: E501
                .format(repository_type_str, allowed_values)
            )

        self._repository_type_str = repository_type_str

    @property
    def resync_own(self):
        """Gets the resync_own of this RepositoryRequestPatch.

        If checked, users can resync any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the 'Access Controls' section of the repository, and any inherited from the org.

        :return: The resync_own of this RepositoryRequestPatch.
        :rtype: bool
        """
        return self._resync_own

    @resync_own.setter
    def resync_own(self, resync_own):
        """Sets the resync_own of this RepositoryRequestPatch.

        If checked, users can resync any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the 'Access Controls' section of the repository, and any inherited from the org.

        :param resync_own: The resync_own of this RepositoryRequestPatch.
        :type: bool
        """

        self._resync_own = resync_own

    @property
    def resync_packages(self):
        """Gets the resync_packages of this RepositoryRequestPatch.

        This defines the minimum level of privilege required for a user to resync packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific resync setting.

        :return: The resync_packages of this RepositoryRequestPatch.
        :rtype: str
        """
        return self._resync_packages

    @resync_packages.setter
    def resync_packages(self, resync_packages):
        """Sets the resync_packages of this RepositoryRequestPatch.

        This defines the minimum level of privilege required for a user to resync packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific resync setting.

        :param resync_packages: The resync_packages of this RepositoryRequestPatch.
        :type: str
        """
        allowed_values = ["Admin", "Write"]  # noqa: E501
        if (self._configuration.client_side_validation and
                resync_packages not in allowed_values):
            raise ValueError(
                "Invalid value for `resync_packages` ({0}), must be one of {1}"  # noqa: E501
                .format(resync_packages, allowed_values)
            )

        self._resync_packages = resync_packages

    @property
    def scan_own(self):
        """Gets the scan_own of this RepositoryRequestPatch.

        If checked, users can scan any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the 'Access Controls' section of the repository, and any inherited from the org.

        :return: The scan_own of this RepositoryRequestPatch.
        :rtype: bool
        """
        return self._scan_own

    @scan_own.setter
    def scan_own(self, scan_own):
        """Sets the scan_own of this RepositoryRequestPatch.

        If checked, users can scan any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the 'Access Controls' section of the repository, and any inherited from the org.

        :param scan_own: The scan_own of this RepositoryRequestPatch.
        :type: bool
        """

        self._scan_own = scan_own

    @property
    def scan_packages(self):
        """Gets the scan_packages of this RepositoryRequestPatch.

        This defines the minimum level of privilege required for a user to scan packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific scan setting.

        :return: The scan_packages of this RepositoryRequestPatch.
        :rtype: str
        """
        return self._scan_packages

    @scan_packages.setter
    def scan_packages(self, scan_packages):
        """Sets the scan_packages of this RepositoryRequestPatch.

        This defines the minimum level of privilege required for a user to scan packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific scan setting.

        :param scan_packages: The scan_packages of this RepositoryRequestPatch.
        :type: str
        """
        allowed_values = ["Admin", "Write", "Read"]  # noqa: E501
        if (self._configuration.client_side_validation and
                scan_packages not in allowed_values):
            raise ValueError(
                "Invalid value for `scan_packages` ({0}), must be one of {1}"  # noqa: E501
                .format(scan_packages, allowed_values)
            )

        self._scan_packages = scan_packages

    @property
    def show_setup_all(self):
        """Gets the show_setup_all of this RepositoryRequestPatch.

        If checked, the Set Me Up help for all formats will always be shown, even if you don't have packages of that type uploaded. Otherwise, help will only be shown for packages that are in the repository. For example, if you have uploaded only NuGet packages, then the Set Me Up help for NuGet packages will be shown only.

        :return: The show_setup_all of this RepositoryRequestPatch.
        :rtype: bool
        """
        return self._show_setup_all

    @show_setup_all.setter
    def show_setup_all(self, show_setup_all):
        """Sets the show_setup_all of this RepositoryRequestPatch.

        If checked, the Set Me Up help for all formats will always be shown, even if you don't have packages of that type uploaded. Otherwise, help will only be shown for packages that are in the repository. For example, if you have uploaded only NuGet packages, then the Set Me Up help for NuGet packages will be shown only.

        :param show_setup_all: The show_setup_all of this RepositoryRequestPatch.
        :type: bool
        """

        self._show_setup_all = show_setup_all

    @property
    def slug(self):
        """Gets the slug of this RepositoryRequestPatch.

        The slug identifies the repository in URIs.

        :return: The slug of this RepositoryRequestPatch.
        :rtype: str
        """
        return self._slug

    @slug.setter
    def slug(self, slug):
        """Sets the slug of this RepositoryRequestPatch.

        The slug identifies the repository in URIs.

        :param slug: The slug of this RepositoryRequestPatch.
        :type: str
        """

        self._slug = slug

    @property
    def strict_npm_validation(self):
        """Gets the strict_npm_validation of this RepositoryRequestPatch.

        If checked, npm packages will be validated strictly to ensure the package matches specifcation. You can turn this off if you have packages that are old or otherwise mildly off-spec, but we can't guarantee the packages will work with npm-cli or other tooling correctly. Turn off at your own risk!

        :return: The strict_npm_validation of this RepositoryRequestPatch.
        :rtype: bool
        """
        return self._strict_npm_validation

    @strict_npm_validation.setter
    def strict_npm_validation(self, strict_npm_validation):
        """Sets the strict_npm_validation of this RepositoryRequestPatch.

        If checked, npm packages will be validated strictly to ensure the package matches specifcation. You can turn this off if you have packages that are old or otherwise mildly off-spec, but we can't guarantee the packages will work with npm-cli or other tooling correctly. Turn off at your own risk!

        :param strict_npm_validation: The strict_npm_validation of this RepositoryRequestPatch.
        :type: bool
        """

        self._strict_npm_validation = strict_npm_validation

    @property
    def use_debian_labels(self):
        """Gets the use_debian_labels of this RepositoryRequestPatch.

        If checked, a 'Label' field will be present in Debian-based repositories. It will contain a string that identifies the entitlement token used to authenticate the repository, in the form of 'source=t-<identifier>'; or 'source=none' if no token was used. You can use this to help with pinning.

        :return: The use_debian_labels of this RepositoryRequestPatch.
        :rtype: bool
        """
        return self._use_debian_labels

    @use_debian_labels.setter
    def use_debian_labels(self, use_debian_labels):
        """Sets the use_debian_labels of this RepositoryRequestPatch.

        If checked, a 'Label' field will be present in Debian-based repositories. It will contain a string that identifies the entitlement token used to authenticate the repository, in the form of 'source=t-<identifier>'; or 'source=none' if no token was used. You can use this to help with pinning.

        :param use_debian_labels: The use_debian_labels of this RepositoryRequestPatch.
        :type: bool
        """

        self._use_debian_labels = use_debian_labels

    @property
    def use_default_cargo_upstream(self):
        """Gets the use_default_cargo_upstream of this RepositoryRequestPatch.

        If checked, dependencies of uploaded Cargo crates which do not set an explicit value for \"registry\" will be assumed to be available from crates.io. If unchecked, dependencies with unspecified \"registry\" values will be assumed to be available in the registry being uploaded to. Uncheck this if you want to ensure that dependencies are only ever installed from Cloudsmith unless explicitly specified as belong to another registry.

        :return: The use_default_cargo_upstream of this RepositoryRequestPatch.
        :rtype: bool
        """
        return self._use_default_cargo_upstream

    @use_default_cargo_upstream.setter
    def use_default_cargo_upstream(self, use_default_cargo_upstream):
        """Sets the use_default_cargo_upstream of this RepositoryRequestPatch.

        If checked, dependencies of uploaded Cargo crates which do not set an explicit value for \"registry\" will be assumed to be available from crates.io. If unchecked, dependencies with unspecified \"registry\" values will be assumed to be available in the registry being uploaded to. Uncheck this if you want to ensure that dependencies are only ever installed from Cloudsmith unless explicitly specified as belong to another registry.

        :param use_default_cargo_upstream: The use_default_cargo_upstream of this RepositoryRequestPatch.
        :type: bool
        """

        self._use_default_cargo_upstream = use_default_cargo_upstream

    @property
    def use_noarch_packages(self):
        """Gets the use_noarch_packages of this RepositoryRequestPatch.

        If checked, noarch packages (if supported) are enabled in installations/configurations. A noarch package is one that is not tied to specific system architecture (like i686).

        :return: The use_noarch_packages of this RepositoryRequestPatch.
        :rtype: bool
        """
        return self._use_noarch_packages

    @use_noarch_packages.setter
    def use_noarch_packages(self, use_noarch_packages):
        """Sets the use_noarch_packages of this RepositoryRequestPatch.

        If checked, noarch packages (if supported) are enabled in installations/configurations. A noarch package is one that is not tied to specific system architecture (like i686).

        :param use_noarch_packages: The use_noarch_packages of this RepositoryRequestPatch.
        :type: bool
        """

        self._use_noarch_packages = use_noarch_packages

    @property
    def use_source_packages(self):
        """Gets the use_source_packages of this RepositoryRequestPatch.

        If checked, source packages (if supported) are enabled in installations/configurations. A source package is one that contains source code rather than built binaries.

        :return: The use_source_packages of this RepositoryRequestPatch.
        :rtype: bool
        """
        return self._use_source_packages

    @use_source_packages.setter
    def use_source_packages(self, use_source_packages):
        """Sets the use_source_packages of this RepositoryRequestPatch.

        If checked, source packages (if supported) are enabled in installations/configurations. A source package is one that contains source code rather than built binaries.

        :param use_source_packages: The use_source_packages of this RepositoryRequestPatch.
        :type: bool
        """

        self._use_source_packages = use_source_packages

    @property
    def use_vulnerability_scanning(self):
        """Gets the use_vulnerability_scanning of this RepositoryRequestPatch.

        If checked, vulnerability scanning will be enabled for all supported packages within this repository.

        :return: The use_vulnerability_scanning of this RepositoryRequestPatch.
        :rtype: bool
        """
        return self._use_vulnerability_scanning

    @use_vulnerability_scanning.setter
    def use_vulnerability_scanning(self, use_vulnerability_scanning):
        """Sets the use_vulnerability_scanning of this RepositoryRequestPatch.

        If checked, vulnerability scanning will be enabled for all supported packages within this repository.

        :param use_vulnerability_scanning: The use_vulnerability_scanning of this RepositoryRequestPatch.
        :type: bool
        """

        self._use_vulnerability_scanning = use_vulnerability_scanning

    @property
    def user_entitlements_enabled(self):
        """Gets the user_entitlements_enabled of this RepositoryRequestPatch.

        If checked, users can use and manage their own user-specific entitlement token for the repository (if private). Otherwise, user-specific entitlements are disabled for all users.

        :return: The user_entitlements_enabled of this RepositoryRequestPatch.
        :rtype: bool
        """
        return self._user_entitlements_enabled

    @user_entitlements_enabled.setter
    def user_entitlements_enabled(self, user_entitlements_enabled):
        """Sets the user_entitlements_enabled of this RepositoryRequestPatch.

        If checked, users can use and manage their own user-specific entitlement token for the repository (if private). Otherwise, user-specific entitlements are disabled for all users.

        :param user_entitlements_enabled: The user_entitlements_enabled of this RepositoryRequestPatch.
        :type: bool
        """

        self._user_entitlements_enabled = user_entitlements_enabled

    @property
    def view_statistics(self):
        """Gets the view_statistics of this RepositoryRequestPatch.

        This defines the minimum level of privilege required for a user to view repository statistics, to include entitlement-based usage, if applicable. If a user does not have the permission, they won't be able to view any statistics, either via the UI, API or CLI.

        :return: The view_statistics of this RepositoryRequestPatch.
        :rtype: str
        """
        return self._view_statistics

    @view_statistics.setter
    def view_statistics(self, view_statistics):
        """Sets the view_statistics of this RepositoryRequestPatch.

        This defines the minimum level of privilege required for a user to view repository statistics, to include entitlement-based usage, if applicable. If a user does not have the permission, they won't be able to view any statistics, either via the UI, API or CLI.

        :param view_statistics: The view_statistics of this RepositoryRequestPatch.
        :type: str
        """
        allowed_values = ["Admin", "Write", "Read"]  # noqa: E501
        if (self._configuration.client_side_validation and
                view_statistics not in allowed_values):
            raise ValueError(
                "Invalid value for `view_statistics` ({0}), must be one of {1}"  # noqa: E501
                .format(view_statistics, allowed_values)
            )

        self._view_statistics = view_statistics

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(RepositoryRequestPatch, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, RepositoryRequestPatch):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, RepositoryRequestPatch):
            return True

        return self.to_dict() != other.to_dict()

