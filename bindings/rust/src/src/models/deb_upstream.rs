/* 
 * Cloudsmith API (v1)
 *
 * The API to the Cloudsmith Service
 *
 * OpenAPI spec version: v1
 * Contact: support@cloudsmith.io
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct DebUpstream {
  /// The authentication mode to use when accessing this upstream. 
  #[serde(rename = "auth_mode")]
  auth_mode: Option<String>,
  /// Secret to provide with requests to upstream.
  #[serde(rename = "auth_secret")]
  auth_secret: Option<String>,
  /// Username to provide with requests to upstream.
  #[serde(rename = "auth_username")]
  auth_username: Option<String>,
  /// The component to fetch from the upstream
  #[serde(rename = "component")]
  component: Option<String>,
  /// The datetime the upstream source was created.
  #[serde(rename = "created_at")]
  created_at: Option<String>,
  #[serde(rename = "disable_reason")]
  disable_reason: Option<String>,
  /// The distribution version that packages found on this upstream could be associated with.
  #[serde(rename = "distro_versions")]
  distro_versions: Vec<String>,
  /// The key for extra header #1 to send to upstream.
  #[serde(rename = "extra_header_1")]
  extra_header_1: Option<String>,
  /// The key for extra header #2 to send to upstream.
  #[serde(rename = "extra_header_2")]
  extra_header_2: Option<String>,
  /// The value for extra header #1 to send to upstream. This is stored as plaintext, and is NOT encrypted.
  #[serde(rename = "extra_value_1")]
  extra_value_1: Option<String>,
  /// The value for extra header #2 to send to upstream. This is stored as plaintext, and is NOT encrypted.
  #[serde(rename = "extra_value_2")]
  extra_value_2: Option<String>,
  /// A public GPG key to associate with packages found on this upstream. When using the Cloudsmith setup script, this GPG key will be automatically imported on your deployment machines to allow upstream packages to validate and install.
  #[serde(rename = "gpg_key_inline")]
  gpg_key_inline: Option<String>,
  /// When provided, Cloudsmith will fetch, validate, and associate a public GPG key found at the provided URL. When using the Cloudsmith setup script, this GPG key will be automatically imported on your deployment machines to allow upstream packages to validate and install.
  #[serde(rename = "gpg_key_url")]
  gpg_key_url: Option<String>,
  /// The GPG signature verification mode for this upstream.
  #[serde(rename = "gpg_verification")]
  gpg_verification: Option<String>,
  /// When true, source packages will be available from this upstream.
  #[serde(rename = "include_sources")]
  include_sources: Option<bool>,
  /// Whether or not this upstream is active and ready for requests.
  #[serde(rename = "is_active")]
  is_active: Option<bool>,
  /// The mode that this upstream should operate in. Upstream sources can be used to proxy resolved packages, as well as operate in a proxy/cache or cache only mode.
  #[serde(rename = "mode")]
  mode: Option<String>,
  /// A descriptive name for this upstream source. A shortened version of this name will be used for tagging cached packages retrieved from this upstream.
  #[serde(rename = "name")]
  name: String,
  /// When true, this upstream source is pending validation.
  #[serde(rename = "pending_validation")]
  pending_validation: Option<bool>,
  /// Upstream sources are selected for resolving requests by sequential order (1..n), followed by creation date.
  #[serde(rename = "priority")]
  priority: Option<i32>,
  #[serde(rename = "slug_perm")]
  slug_perm: Option<String>,
  #[serde(rename = "updated_at")]
  updated_at: Option<String>,
  /// The distribution to fetch from the upstream
  #[serde(rename = "upstream_distribution")]
  upstream_distribution: Option<String>,
  /// The URL for this upstream source. This must be a fully qualified URL including any path elements required to reach the root of the repository. 
  #[serde(rename = "upstream_url")]
  upstream_url: String,
  /// The signature verification status for this upstream.
  #[serde(rename = "verification_status")]
  verification_status: Option<String>,
  /// If enabled, SSL certificates are verified when requests are made to this upstream. It's recommended to leave this enabled for all public sources to help mitigate Man-In-The-Middle (MITM) attacks. Please note this only applies to HTTPS upstreams.
  #[serde(rename = "verify_ssl")]
  verify_ssl: Option<bool>
}

impl DebUpstream {
  pub fn new(distro_versions: Vec<String>, name: String, upstream_url: String) -> DebUpstream {
    DebUpstream {
      auth_mode: None,
      auth_secret: None,
      auth_username: None,
      component: None,
      created_at: None,
      disable_reason: None,
      distro_versions: distro_versions,
      extra_header_1: None,
      extra_header_2: None,
      extra_value_1: None,
      extra_value_2: None,
      gpg_key_inline: None,
      gpg_key_url: None,
      gpg_verification: None,
      include_sources: None,
      is_active: None,
      mode: None,
      name: name,
      pending_validation: None,
      priority: None,
      slug_perm: None,
      updated_at: None,
      upstream_distribution: None,
      upstream_url: upstream_url,
      verification_status: None,
      verify_ssl: None
    }
  }

  pub fn set_auth_mode(&mut self, auth_mode: String) {
    self.auth_mode = Some(auth_mode);
  }

  pub fn with_auth_mode(mut self, auth_mode: String) -> DebUpstream {
    self.auth_mode = Some(auth_mode);
    self
  }

  pub fn auth_mode(&self) -> Option<&String> {
    self.auth_mode.as_ref()
  }

  pub fn reset_auth_mode(&mut self) {
    self.auth_mode = None;
  }

  pub fn set_auth_secret(&mut self, auth_secret: String) {
    self.auth_secret = Some(auth_secret);
  }

  pub fn with_auth_secret(mut self, auth_secret: String) -> DebUpstream {
    self.auth_secret = Some(auth_secret);
    self
  }

  pub fn auth_secret(&self) -> Option<&String> {
    self.auth_secret.as_ref()
  }

  pub fn reset_auth_secret(&mut self) {
    self.auth_secret = None;
  }

  pub fn set_auth_username(&mut self, auth_username: String) {
    self.auth_username = Some(auth_username);
  }

  pub fn with_auth_username(mut self, auth_username: String) -> DebUpstream {
    self.auth_username = Some(auth_username);
    self
  }

  pub fn auth_username(&self) -> Option<&String> {
    self.auth_username.as_ref()
  }

  pub fn reset_auth_username(&mut self) {
    self.auth_username = None;
  }

  pub fn set_component(&mut self, component: String) {
    self.component = Some(component);
  }

  pub fn with_component(mut self, component: String) -> DebUpstream {
    self.component = Some(component);
    self
  }

  pub fn component(&self) -> Option<&String> {
    self.component.as_ref()
  }

  pub fn reset_component(&mut self) {
    self.component = None;
  }

  pub fn set_created_at(&mut self, created_at: String) {
    self.created_at = Some(created_at);
  }

  pub fn with_created_at(mut self, created_at: String) -> DebUpstream {
    self.created_at = Some(created_at);
    self
  }

  pub fn created_at(&self) -> Option<&String> {
    self.created_at.as_ref()
  }

  pub fn reset_created_at(&mut self) {
    self.created_at = None;
  }

  pub fn set_disable_reason(&mut self, disable_reason: String) {
    self.disable_reason = Some(disable_reason);
  }

  pub fn with_disable_reason(mut self, disable_reason: String) -> DebUpstream {
    self.disable_reason = Some(disable_reason);
    self
  }

  pub fn disable_reason(&self) -> Option<&String> {
    self.disable_reason.as_ref()
  }

  pub fn reset_disable_reason(&mut self) {
    self.disable_reason = None;
  }

  pub fn set_distro_versions(&mut self, distro_versions: Vec<String>) {
    self.distro_versions = distro_versions;
  }

  pub fn with_distro_versions(mut self, distro_versions: Vec<String>) -> DebUpstream {
    self.distro_versions = distro_versions;
    self
  }

  pub fn distro_versions(&self) -> &Vec<String> {
    &self.distro_versions
  }


  pub fn set_extra_header_1(&mut self, extra_header_1: String) {
    self.extra_header_1 = Some(extra_header_1);
  }

  pub fn with_extra_header_1(mut self, extra_header_1: String) -> DebUpstream {
    self.extra_header_1 = Some(extra_header_1);
    self
  }

  pub fn extra_header_1(&self) -> Option<&String> {
    self.extra_header_1.as_ref()
  }

  pub fn reset_extra_header_1(&mut self) {
    self.extra_header_1 = None;
  }

  pub fn set_extra_header_2(&mut self, extra_header_2: String) {
    self.extra_header_2 = Some(extra_header_2);
  }

  pub fn with_extra_header_2(mut self, extra_header_2: String) -> DebUpstream {
    self.extra_header_2 = Some(extra_header_2);
    self
  }

  pub fn extra_header_2(&self) -> Option<&String> {
    self.extra_header_2.as_ref()
  }

  pub fn reset_extra_header_2(&mut self) {
    self.extra_header_2 = None;
  }

  pub fn set_extra_value_1(&mut self, extra_value_1: String) {
    self.extra_value_1 = Some(extra_value_1);
  }

  pub fn with_extra_value_1(mut self, extra_value_1: String) -> DebUpstream {
    self.extra_value_1 = Some(extra_value_1);
    self
  }

  pub fn extra_value_1(&self) -> Option<&String> {
    self.extra_value_1.as_ref()
  }

  pub fn reset_extra_value_1(&mut self) {
    self.extra_value_1 = None;
  }

  pub fn set_extra_value_2(&mut self, extra_value_2: String) {
    self.extra_value_2 = Some(extra_value_2);
  }

  pub fn with_extra_value_2(mut self, extra_value_2: String) -> DebUpstream {
    self.extra_value_2 = Some(extra_value_2);
    self
  }

  pub fn extra_value_2(&self) -> Option<&String> {
    self.extra_value_2.as_ref()
  }

  pub fn reset_extra_value_2(&mut self) {
    self.extra_value_2 = None;
  }

  pub fn set_gpg_key_inline(&mut self, gpg_key_inline: String) {
    self.gpg_key_inline = Some(gpg_key_inline);
  }

  pub fn with_gpg_key_inline(mut self, gpg_key_inline: String) -> DebUpstream {
    self.gpg_key_inline = Some(gpg_key_inline);
    self
  }

  pub fn gpg_key_inline(&self) -> Option<&String> {
    self.gpg_key_inline.as_ref()
  }

  pub fn reset_gpg_key_inline(&mut self) {
    self.gpg_key_inline = None;
  }

  pub fn set_gpg_key_url(&mut self, gpg_key_url: String) {
    self.gpg_key_url = Some(gpg_key_url);
  }

  pub fn with_gpg_key_url(mut self, gpg_key_url: String) -> DebUpstream {
    self.gpg_key_url = Some(gpg_key_url);
    self
  }

  pub fn gpg_key_url(&self) -> Option<&String> {
    self.gpg_key_url.as_ref()
  }

  pub fn reset_gpg_key_url(&mut self) {
    self.gpg_key_url = None;
  }

  pub fn set_gpg_verification(&mut self, gpg_verification: String) {
    self.gpg_verification = Some(gpg_verification);
  }

  pub fn with_gpg_verification(mut self, gpg_verification: String) -> DebUpstream {
    self.gpg_verification = Some(gpg_verification);
    self
  }

  pub fn gpg_verification(&self) -> Option<&String> {
    self.gpg_verification.as_ref()
  }

  pub fn reset_gpg_verification(&mut self) {
    self.gpg_verification = None;
  }

  pub fn set_include_sources(&mut self, include_sources: bool) {
    self.include_sources = Some(include_sources);
  }

  pub fn with_include_sources(mut self, include_sources: bool) -> DebUpstream {
    self.include_sources = Some(include_sources);
    self
  }

  pub fn include_sources(&self) -> Option<&bool> {
    self.include_sources.as_ref()
  }

  pub fn reset_include_sources(&mut self) {
    self.include_sources = None;
  }

  pub fn set_is_active(&mut self, is_active: bool) {
    self.is_active = Some(is_active);
  }

  pub fn with_is_active(mut self, is_active: bool) -> DebUpstream {
    self.is_active = Some(is_active);
    self
  }

  pub fn is_active(&self) -> Option<&bool> {
    self.is_active.as_ref()
  }

  pub fn reset_is_active(&mut self) {
    self.is_active = None;
  }

  pub fn set_mode(&mut self, mode: String) {
    self.mode = Some(mode);
  }

  pub fn with_mode(mut self, mode: String) -> DebUpstream {
    self.mode = Some(mode);
    self
  }

  pub fn mode(&self) -> Option<&String> {
    self.mode.as_ref()
  }

  pub fn reset_mode(&mut self) {
    self.mode = None;
  }

  pub fn set_name(&mut self, name: String) {
    self.name = name;
  }

  pub fn with_name(mut self, name: String) -> DebUpstream {
    self.name = name;
    self
  }

  pub fn name(&self) -> &String {
    &self.name
  }


  pub fn set_pending_validation(&mut self, pending_validation: bool) {
    self.pending_validation = Some(pending_validation);
  }

  pub fn with_pending_validation(mut self, pending_validation: bool) -> DebUpstream {
    self.pending_validation = Some(pending_validation);
    self
  }

  pub fn pending_validation(&self) -> Option<&bool> {
    self.pending_validation.as_ref()
  }

  pub fn reset_pending_validation(&mut self) {
    self.pending_validation = None;
  }

  pub fn set_priority(&mut self, priority: i32) {
    self.priority = Some(priority);
  }

  pub fn with_priority(mut self, priority: i32) -> DebUpstream {
    self.priority = Some(priority);
    self
  }

  pub fn priority(&self) -> Option<&i32> {
    self.priority.as_ref()
  }

  pub fn reset_priority(&mut self) {
    self.priority = None;
  }

  pub fn set_slug_perm(&mut self, slug_perm: String) {
    self.slug_perm = Some(slug_perm);
  }

  pub fn with_slug_perm(mut self, slug_perm: String) -> DebUpstream {
    self.slug_perm = Some(slug_perm);
    self
  }

  pub fn slug_perm(&self) -> Option<&String> {
    self.slug_perm.as_ref()
  }

  pub fn reset_slug_perm(&mut self) {
    self.slug_perm = None;
  }

  pub fn set_updated_at(&mut self, updated_at: String) {
    self.updated_at = Some(updated_at);
  }

  pub fn with_updated_at(mut self, updated_at: String) -> DebUpstream {
    self.updated_at = Some(updated_at);
    self
  }

  pub fn updated_at(&self) -> Option<&String> {
    self.updated_at.as_ref()
  }

  pub fn reset_updated_at(&mut self) {
    self.updated_at = None;
  }

  pub fn set_upstream_distribution(&mut self, upstream_distribution: String) {
    self.upstream_distribution = Some(upstream_distribution);
  }

  pub fn with_upstream_distribution(mut self, upstream_distribution: String) -> DebUpstream {
    self.upstream_distribution = Some(upstream_distribution);
    self
  }

  pub fn upstream_distribution(&self) -> Option<&String> {
    self.upstream_distribution.as_ref()
  }

  pub fn reset_upstream_distribution(&mut self) {
    self.upstream_distribution = None;
  }

  pub fn set_upstream_url(&mut self, upstream_url: String) {
    self.upstream_url = upstream_url;
  }

  pub fn with_upstream_url(mut self, upstream_url: String) -> DebUpstream {
    self.upstream_url = upstream_url;
    self
  }

  pub fn upstream_url(&self) -> &String {
    &self.upstream_url
  }


  pub fn set_verification_status(&mut self, verification_status: String) {
    self.verification_status = Some(verification_status);
  }

  pub fn with_verification_status(mut self, verification_status: String) -> DebUpstream {
    self.verification_status = Some(verification_status);
    self
  }

  pub fn verification_status(&self) -> Option<&String> {
    self.verification_status.as_ref()
  }

  pub fn reset_verification_status(&mut self) {
    self.verification_status = None;
  }

  pub fn set_verify_ssl(&mut self, verify_ssl: bool) {
    self.verify_ssl = Some(verify_ssl);
  }

  pub fn with_verify_ssl(mut self, verify_ssl: bool) -> DebUpstream {
    self.verify_ssl = Some(verify_ssl);
    self
  }

  pub fn verify_ssl(&self) -> Option<&bool> {
    self.verify_ssl.as_ref()
  }

  pub fn reset_verify_ssl(&mut self) {
    self.verify_ssl = None;
  }

}



