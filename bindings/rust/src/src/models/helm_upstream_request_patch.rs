/* 
 * Cloudsmith API (v1)
 *
 * The API to the Cloudsmith Service
 *
 * OpenAPI spec version: v1
 * Contact: support@cloudsmith.io
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct HelmUpstreamRequestPatch {
  /// The authentication mode to use when accessing this upstream. 
  #[serde(rename = "auth_mode")]
  auth_mode: Option<String>,
  /// Secret to provide with requests to upstream.
  #[serde(rename = "auth_secret")]
  auth_secret: Option<String>,
  /// Username to provide with requests to upstream.
  #[serde(rename = "auth_username")]
  auth_username: Option<String>,
  /// The key for extra header #1 to send to upstream.
  #[serde(rename = "extra_header_1")]
  extra_header_1: Option<String>,
  /// The key for extra header #2 to send to upstream.
  #[serde(rename = "extra_header_2")]
  extra_header_2: Option<String>,
  /// The value for extra header #1 to send to upstream. This is stored as plaintext, and is NOT encrypted.
  #[serde(rename = "extra_value_1")]
  extra_value_1: Option<String>,
  /// The value for extra header #2 to send to upstream. This is stored as plaintext, and is NOT encrypted.
  #[serde(rename = "extra_value_2")]
  extra_value_2: Option<String>,
  /// Whether or not this upstream is active and ready for requests.
  #[serde(rename = "is_active")]
  is_active: Option<bool>,
  /// The mode that this upstream should operate in. Upstream sources can be used to proxy resolved packages, as well as operate in a proxy/cache or cache only mode.
  #[serde(rename = "mode")]
  mode: Option<String>,
  /// A descriptive name for this upstream source. A shortened version of this name will be used for tagging cached packages retrieved from this upstream.
  #[serde(rename = "name")]
  name: Option<String>,
  /// Upstream sources are selected for resolving requests by sequential order (1..n), followed by creation date.
  #[serde(rename = "priority")]
  priority: Option<i32>,
  /// The URL for this upstream source. This must be a fully qualified URL including any path elements required to reach the root of the repository. 
  #[serde(rename = "upstream_url")]
  upstream_url: Option<String>,
  /// If enabled, SSL certificates are verified when requests are made to this upstream. It's recommended to leave this enabled for all public sources to help mitigate Man-In-The-Middle (MITM) attacks. Please note this only applies to HTTPS upstreams.
  #[serde(rename = "verify_ssl")]
  verify_ssl: Option<bool>
}

impl HelmUpstreamRequestPatch {
  pub fn new() -> HelmUpstreamRequestPatch {
    HelmUpstreamRequestPatch {
      auth_mode: None,
      auth_secret: None,
      auth_username: None,
      extra_header_1: None,
      extra_header_2: None,
      extra_value_1: None,
      extra_value_2: None,
      is_active: None,
      mode: None,
      name: None,
      priority: None,
      upstream_url: None,
      verify_ssl: None
    }
  }

  pub fn set_auth_mode(&mut self, auth_mode: String) {
    self.auth_mode = Some(auth_mode);
  }

  pub fn with_auth_mode(mut self, auth_mode: String) -> HelmUpstreamRequestPatch {
    self.auth_mode = Some(auth_mode);
    self
  }

  pub fn auth_mode(&self) -> Option<&String> {
    self.auth_mode.as_ref()
  }

  pub fn reset_auth_mode(&mut self) {
    self.auth_mode = None;
  }

  pub fn set_auth_secret(&mut self, auth_secret: String) {
    self.auth_secret = Some(auth_secret);
  }

  pub fn with_auth_secret(mut self, auth_secret: String) -> HelmUpstreamRequestPatch {
    self.auth_secret = Some(auth_secret);
    self
  }

  pub fn auth_secret(&self) -> Option<&String> {
    self.auth_secret.as_ref()
  }

  pub fn reset_auth_secret(&mut self) {
    self.auth_secret = None;
  }

  pub fn set_auth_username(&mut self, auth_username: String) {
    self.auth_username = Some(auth_username);
  }

  pub fn with_auth_username(mut self, auth_username: String) -> HelmUpstreamRequestPatch {
    self.auth_username = Some(auth_username);
    self
  }

  pub fn auth_username(&self) -> Option<&String> {
    self.auth_username.as_ref()
  }

  pub fn reset_auth_username(&mut self) {
    self.auth_username = None;
  }

  pub fn set_extra_header_1(&mut self, extra_header_1: String) {
    self.extra_header_1 = Some(extra_header_1);
  }

  pub fn with_extra_header_1(mut self, extra_header_1: String) -> HelmUpstreamRequestPatch {
    self.extra_header_1 = Some(extra_header_1);
    self
  }

  pub fn extra_header_1(&self) -> Option<&String> {
    self.extra_header_1.as_ref()
  }

  pub fn reset_extra_header_1(&mut self) {
    self.extra_header_1 = None;
  }

  pub fn set_extra_header_2(&mut self, extra_header_2: String) {
    self.extra_header_2 = Some(extra_header_2);
  }

  pub fn with_extra_header_2(mut self, extra_header_2: String) -> HelmUpstreamRequestPatch {
    self.extra_header_2 = Some(extra_header_2);
    self
  }

  pub fn extra_header_2(&self) -> Option<&String> {
    self.extra_header_2.as_ref()
  }

  pub fn reset_extra_header_2(&mut self) {
    self.extra_header_2 = None;
  }

  pub fn set_extra_value_1(&mut self, extra_value_1: String) {
    self.extra_value_1 = Some(extra_value_1);
  }

  pub fn with_extra_value_1(mut self, extra_value_1: String) -> HelmUpstreamRequestPatch {
    self.extra_value_1 = Some(extra_value_1);
    self
  }

  pub fn extra_value_1(&self) -> Option<&String> {
    self.extra_value_1.as_ref()
  }

  pub fn reset_extra_value_1(&mut self) {
    self.extra_value_1 = None;
  }

  pub fn set_extra_value_2(&mut self, extra_value_2: String) {
    self.extra_value_2 = Some(extra_value_2);
  }

  pub fn with_extra_value_2(mut self, extra_value_2: String) -> HelmUpstreamRequestPatch {
    self.extra_value_2 = Some(extra_value_2);
    self
  }

  pub fn extra_value_2(&self) -> Option<&String> {
    self.extra_value_2.as_ref()
  }

  pub fn reset_extra_value_2(&mut self) {
    self.extra_value_2 = None;
  }

  pub fn set_is_active(&mut self, is_active: bool) {
    self.is_active = Some(is_active);
  }

  pub fn with_is_active(mut self, is_active: bool) -> HelmUpstreamRequestPatch {
    self.is_active = Some(is_active);
    self
  }

  pub fn is_active(&self) -> Option<&bool> {
    self.is_active.as_ref()
  }

  pub fn reset_is_active(&mut self) {
    self.is_active = None;
  }

  pub fn set_mode(&mut self, mode: String) {
    self.mode = Some(mode);
  }

  pub fn with_mode(mut self, mode: String) -> HelmUpstreamRequestPatch {
    self.mode = Some(mode);
    self
  }

  pub fn mode(&self) -> Option<&String> {
    self.mode.as_ref()
  }

  pub fn reset_mode(&mut self) {
    self.mode = None;
  }

  pub fn set_name(&mut self, name: String) {
    self.name = Some(name);
  }

  pub fn with_name(mut self, name: String) -> HelmUpstreamRequestPatch {
    self.name = Some(name);
    self
  }

  pub fn name(&self) -> Option<&String> {
    self.name.as_ref()
  }

  pub fn reset_name(&mut self) {
    self.name = None;
  }

  pub fn set_priority(&mut self, priority: i32) {
    self.priority = Some(priority);
  }

  pub fn with_priority(mut self, priority: i32) -> HelmUpstreamRequestPatch {
    self.priority = Some(priority);
    self
  }

  pub fn priority(&self) -> Option<&i32> {
    self.priority.as_ref()
  }

  pub fn reset_priority(&mut self) {
    self.priority = None;
  }

  pub fn set_upstream_url(&mut self, upstream_url: String) {
    self.upstream_url = Some(upstream_url);
  }

  pub fn with_upstream_url(mut self, upstream_url: String) -> HelmUpstreamRequestPatch {
    self.upstream_url = Some(upstream_url);
    self
  }

  pub fn upstream_url(&self) -> Option<&String> {
    self.upstream_url.as_ref()
  }

  pub fn reset_upstream_url(&mut self) {
    self.upstream_url = None;
  }

  pub fn set_verify_ssl(&mut self, verify_ssl: bool) {
    self.verify_ssl = Some(verify_ssl);
  }

  pub fn with_verify_ssl(mut self, verify_ssl: bool) -> HelmUpstreamRequestPatch {
    self.verify_ssl = Some(verify_ssl);
    self
  }

  pub fn verify_ssl(&self) -> Option<&bool> {
    self.verify_ssl.as_ref()
  }

  pub fn reset_verify_ssl(&mut self) {
    self.verify_ssl = None;
  }

}



