/* 
 * Cloudsmith API (v1)
 *
 * The API to the Cloudsmith Service
 *
 * OpenAPI spec version: v1
 * Contact: support@cloudsmith.io
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct RateCheck {
  /// The time in seconds that you are suggested to wait until the next request in order to avoid consuming too much within the rate limit window.
  #[serde(rename = "interval")]
  interval: Option<f32>,
  /// The maximum number of requests that you are permitted to send per hour
  #[serde(rename = "limit")]
  limit: Option<i32>,
  /// The number of requests that are remaining in the current rate limit window
  #[serde(rename = "remaining")]
  remaining: Option<i32>,
  /// The UTC epoch timestamp at which the current rate limit window will reset
  #[serde(rename = "reset")]
  reset: Option<i32>,
  /// The ISO 8601 datetime at which the current rate limit window will reset
  #[serde(rename = "reset_iso_8601")]
  reset_iso_8601: Option<String>,
  /// If true, throttling is currently being enforced.
  #[serde(rename = "throttled")]
  throttled: Option<bool>
}

impl RateCheck {
  pub fn new() -> RateCheck {
    RateCheck {
      interval: None,
      limit: None,
      remaining: None,
      reset: None,
      reset_iso_8601: None,
      throttled: None
    }
  }

  pub fn set_interval(&mut self, interval: f32) {
    self.interval = Some(interval);
  }

  pub fn with_interval(mut self, interval: f32) -> RateCheck {
    self.interval = Some(interval);
    self
  }

  pub fn interval(&self) -> Option<&f32> {
    self.interval.as_ref()
  }

  pub fn reset_interval(&mut self) {
    self.interval = None;
  }

  pub fn set_limit(&mut self, limit: i32) {
    self.limit = Some(limit);
  }

  pub fn with_limit(mut self, limit: i32) -> RateCheck {
    self.limit = Some(limit);
    self
  }

  pub fn limit(&self) -> Option<&i32> {
    self.limit.as_ref()
  }

  pub fn reset_limit(&mut self) {
    self.limit = None;
  }

  pub fn set_remaining(&mut self, remaining: i32) {
    self.remaining = Some(remaining);
  }

  pub fn with_remaining(mut self, remaining: i32) -> RateCheck {
    self.remaining = Some(remaining);
    self
  }

  pub fn remaining(&self) -> Option<&i32> {
    self.remaining.as_ref()
  }

  pub fn reset_remaining(&mut self) {
    self.remaining = None;
  }

  pub fn set_reset(&mut self, reset: i32) {
    self.reset = Some(reset);
  }

  pub fn with_reset(mut self, reset: i32) -> RateCheck {
    self.reset = Some(reset);
    self
  }

  pub fn reset(&self) -> Option<&i32> {
    self.reset.as_ref()
  }

  pub fn reset_reset(&mut self) {
    self.reset = None;
  }

  pub fn set_reset_iso_8601(&mut self, reset_iso_8601: String) {
    self.reset_iso_8601 = Some(reset_iso_8601);
  }

  pub fn with_reset_iso_8601(mut self, reset_iso_8601: String) -> RateCheck {
    self.reset_iso_8601 = Some(reset_iso_8601);
    self
  }

  pub fn reset_iso_8601(&self) -> Option<&String> {
    self.reset_iso_8601.as_ref()
  }

  pub fn reset_reset_iso_8601(&mut self) {
    self.reset_iso_8601 = None;
  }

  pub fn set_throttled(&mut self, throttled: bool) {
    self.throttled = Some(throttled);
  }

  pub fn with_throttled(mut self, throttled: bool) -> RateCheck {
    self.throttled = Some(throttled);
    self
  }

  pub fn throttled(&self) -> Option<&bool> {
    self.throttled.as_ref()
  }

  pub fn reset_throttled(&mut self) {
    self.throttled = None;
  }

}



