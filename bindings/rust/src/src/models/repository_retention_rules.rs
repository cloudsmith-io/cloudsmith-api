/* 
 * Cloudsmith API (v1)
 *
 * The API to the Cloudsmith Service
 *
 * OpenAPI spec version: v1
 * Contact: support@cloudsmith.io
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct RepositoryRetentionRules {
  /// The maximum X number of packages to retain.
  #[serde(rename = "retention_count_limit")]
  retention_count_limit: Option<i32>,
  /// The X number of days of packages to retain.
  #[serde(rename = "retention_days_limit")]
  retention_days_limit: Option<i32>,
  /// If checked, the retention lifecycle rules will be activated for the repository. Any packages that don't match will be deleted automatically, and the rest are retained.
  #[serde(rename = "retention_enabled")]
  retention_enabled: Option<bool>,
  /// If checked, retention will apply to packages by package formats rather than across all package formats.For example, when retaining by a limit of 1 and you upload PythonPkg 1.0 and RubyPkg 1.0, no packages are deleted because they are different formats.
  #[serde(rename = "retention_group_by_format")]
  retention_group_by_format: Option<bool>,
  /// If checked, retention will apply to groups of packages by name rather than all packages.<br>For example, when retaining by a limit of 1 and you upload PkgA 1.0, PkgB 1.0 and PkgB 1.1; only PkgB 1.0 is deleted because there are two (2) PkgBs and one (1) PkgA.
  #[serde(rename = "retention_group_by_name")]
  retention_group_by_name: Option<bool>,
  /// If checked, retention will apply to packages by package type (e.g. by binary, by source, etc.), rather than across all package types for one or more formats. <br>For example, when retaining by a limit of 1 and you upload DebPackage 1.0 and DebSourcePackage 1.0, no packages are deleted because they are different package types, binary and source respectively.
  #[serde(rename = "retention_group_by_package_type")]
  retention_group_by_package_type: Option<bool>,
  /// The maximum X total size (in bytes) of packages to retain.
  #[serde(rename = "retention_size_limit")]
  retention_size_limit: Option<i32>
}

impl RepositoryRetentionRules {
  pub fn new() -> RepositoryRetentionRules {
    RepositoryRetentionRules {
      retention_count_limit: None,
      retention_days_limit: None,
      retention_enabled: None,
      retention_group_by_format: None,
      retention_group_by_name: None,
      retention_group_by_package_type: None,
      retention_size_limit: None
    }
  }

  pub fn set_retention_count_limit(&mut self, retention_count_limit: i32) {
    self.retention_count_limit = Some(retention_count_limit);
  }

  pub fn with_retention_count_limit(mut self, retention_count_limit: i32) -> RepositoryRetentionRules {
    self.retention_count_limit = Some(retention_count_limit);
    self
  }

  pub fn retention_count_limit(&self) -> Option<&i32> {
    self.retention_count_limit.as_ref()
  }

  pub fn reset_retention_count_limit(&mut self) {
    self.retention_count_limit = None;
  }

  pub fn set_retention_days_limit(&mut self, retention_days_limit: i32) {
    self.retention_days_limit = Some(retention_days_limit);
  }

  pub fn with_retention_days_limit(mut self, retention_days_limit: i32) -> RepositoryRetentionRules {
    self.retention_days_limit = Some(retention_days_limit);
    self
  }

  pub fn retention_days_limit(&self) -> Option<&i32> {
    self.retention_days_limit.as_ref()
  }

  pub fn reset_retention_days_limit(&mut self) {
    self.retention_days_limit = None;
  }

  pub fn set_retention_enabled(&mut self, retention_enabled: bool) {
    self.retention_enabled = Some(retention_enabled);
  }

  pub fn with_retention_enabled(mut self, retention_enabled: bool) -> RepositoryRetentionRules {
    self.retention_enabled = Some(retention_enabled);
    self
  }

  pub fn retention_enabled(&self) -> Option<&bool> {
    self.retention_enabled.as_ref()
  }

  pub fn reset_retention_enabled(&mut self) {
    self.retention_enabled = None;
  }

  pub fn set_retention_group_by_format(&mut self, retention_group_by_format: bool) {
    self.retention_group_by_format = Some(retention_group_by_format);
  }

  pub fn with_retention_group_by_format(mut self, retention_group_by_format: bool) -> RepositoryRetentionRules {
    self.retention_group_by_format = Some(retention_group_by_format);
    self
  }

  pub fn retention_group_by_format(&self) -> Option<&bool> {
    self.retention_group_by_format.as_ref()
  }

  pub fn reset_retention_group_by_format(&mut self) {
    self.retention_group_by_format = None;
  }

  pub fn set_retention_group_by_name(&mut self, retention_group_by_name: bool) {
    self.retention_group_by_name = Some(retention_group_by_name);
  }

  pub fn with_retention_group_by_name(mut self, retention_group_by_name: bool) -> RepositoryRetentionRules {
    self.retention_group_by_name = Some(retention_group_by_name);
    self
  }

  pub fn retention_group_by_name(&self) -> Option<&bool> {
    self.retention_group_by_name.as_ref()
  }

  pub fn reset_retention_group_by_name(&mut self) {
    self.retention_group_by_name = None;
  }

  pub fn set_retention_group_by_package_type(&mut self, retention_group_by_package_type: bool) {
    self.retention_group_by_package_type = Some(retention_group_by_package_type);
  }

  pub fn with_retention_group_by_package_type(mut self, retention_group_by_package_type: bool) -> RepositoryRetentionRules {
    self.retention_group_by_package_type = Some(retention_group_by_package_type);
    self
  }

  pub fn retention_group_by_package_type(&self) -> Option<&bool> {
    self.retention_group_by_package_type.as_ref()
  }

  pub fn reset_retention_group_by_package_type(&mut self) {
    self.retention_group_by_package_type = None;
  }

  pub fn set_retention_size_limit(&mut self, retention_size_limit: i32) {
    self.retention_size_limit = Some(retention_size_limit);
  }

  pub fn with_retention_size_limit(mut self, retention_size_limit: i32) -> RepositoryRetentionRules {
    self.retention_size_limit = Some(retention_size_limit);
    self
  }

  pub fn retention_size_limit(&self) -> Option<&i32> {
    self.retention_size_limit.as_ref()
  }

  pub fn reset_retention_size_limit(&mut self) {
    self.retention_size_limit = None;
  }

}



