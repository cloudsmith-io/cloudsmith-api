/* 
 * Cloudsmith API (v1)
 *
 * The API to the Cloudsmith Service
 *
 * OpenAPI spec version: v1
 * Contact: support@cloudsmith.io
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct RepositoryTokenRequestPatch {
  /// If checked, a EULA acceptance is required for this token.
  #[serde(rename = "eula_required")]
  eula_required: Option<bool>,
  /// If enabled, the token will allow downloads based on configured restrictions (if any).
  #[serde(rename = "is_active")]
  is_active: Option<bool>,
  /// The maximum download bandwidth allowed for the token. Values are expressed as the selected unit of bandwidth. Please note that since downloads are calculated asynchronously (after the download happens), the limit may not be imposed immediately but at a later point. 
  #[serde(rename = "limit_bandwidth")]
  limit_bandwidth: Option<i32>,
  #[serde(rename = "limit_bandwidth_unit")]
  limit_bandwidth_unit: Option<String>,
  /// The starting date/time the token is allowed to be used from.
  #[serde(rename = "limit_date_range_from")]
  limit_date_range_from: Option<String>,
  /// The ending date/time the token is allowed to be used until.
  #[serde(rename = "limit_date_range_to")]
  limit_date_range_to: Option<String>,
  /// The maximum number of unique clients allowed for the token. Please note that since clients are calculated asynchronously (after the download happens), the limit may not be imposed immediately but at a later point.
  #[serde(rename = "limit_num_clients")]
  limit_num_clients: Option<i32>,
  /// The maximum number of downloads allowed for the token. Please note that since downloads are calculated asynchronously (after the download happens), the limit may not be imposed immediately but at a later point.
  #[serde(rename = "limit_num_downloads")]
  limit_num_downloads: Option<i32>,
  /// The package-based search query to apply to restrict downloads to. This uses the same syntax as the standard search used for repositories, and also supports boolean logic operators such as OR/AND/NOT and parentheses for grouping. This will still allow access to non-package files, such as metadata.
  #[serde(rename = "limit_package_query")]
  limit_package_query: Option<String>,
  /// THIS WILL SOON BE DEPRECATED, please use limit_package_query instead. The path-based search query to apply to restrict downloads to. This supports boolean logic operators such as OR/AND/NOT and parentheses for grouping. The path evaluated does not include the domain name, the namespace, the entitlement code used, the package format, etc. and it always starts with a forward slash.
  #[serde(rename = "limit_path_query")]
  limit_path_query: Option<String>,
  #[serde(rename = "metadata")]
  metadata: Option<Value>,
  #[serde(rename = "name")]
  name: Option<String>,
  /// The time at which the scheduled reset period has elapsed and the token limits were automatically reset to zero.
  #[serde(rename = "scheduled_reset_at")]
  scheduled_reset_at: Option<String>,
  #[serde(rename = "scheduled_reset_period")]
  scheduled_reset_period: Option<String>,
  #[serde(rename = "token")]
  token: Option<String>
}

impl RepositoryTokenRequestPatch {
  pub fn new() -> RepositoryTokenRequestPatch {
    RepositoryTokenRequestPatch {
      eula_required: None,
      is_active: None,
      limit_bandwidth: None,
      limit_bandwidth_unit: None,
      limit_date_range_from: None,
      limit_date_range_to: None,
      limit_num_clients: None,
      limit_num_downloads: None,
      limit_package_query: None,
      limit_path_query: None,
      metadata: None,
      name: None,
      scheduled_reset_at: None,
      scheduled_reset_period: None,
      token: None
    }
  }

  pub fn set_eula_required(&mut self, eula_required: bool) {
    self.eula_required = Some(eula_required);
  }

  pub fn with_eula_required(mut self, eula_required: bool) -> RepositoryTokenRequestPatch {
    self.eula_required = Some(eula_required);
    self
  }

  pub fn eula_required(&self) -> Option<&bool> {
    self.eula_required.as_ref()
  }

  pub fn reset_eula_required(&mut self) {
    self.eula_required = None;
  }

  pub fn set_is_active(&mut self, is_active: bool) {
    self.is_active = Some(is_active);
  }

  pub fn with_is_active(mut self, is_active: bool) -> RepositoryTokenRequestPatch {
    self.is_active = Some(is_active);
    self
  }

  pub fn is_active(&self) -> Option<&bool> {
    self.is_active.as_ref()
  }

  pub fn reset_is_active(&mut self) {
    self.is_active = None;
  }

  pub fn set_limit_bandwidth(&mut self, limit_bandwidth: i32) {
    self.limit_bandwidth = Some(limit_bandwidth);
  }

  pub fn with_limit_bandwidth(mut self, limit_bandwidth: i32) -> RepositoryTokenRequestPatch {
    self.limit_bandwidth = Some(limit_bandwidth);
    self
  }

  pub fn limit_bandwidth(&self) -> Option<&i32> {
    self.limit_bandwidth.as_ref()
  }

  pub fn reset_limit_bandwidth(&mut self) {
    self.limit_bandwidth = None;
  }

  pub fn set_limit_bandwidth_unit(&mut self, limit_bandwidth_unit: String) {
    self.limit_bandwidth_unit = Some(limit_bandwidth_unit);
  }

  pub fn with_limit_bandwidth_unit(mut self, limit_bandwidth_unit: String) -> RepositoryTokenRequestPatch {
    self.limit_bandwidth_unit = Some(limit_bandwidth_unit);
    self
  }

  pub fn limit_bandwidth_unit(&self) -> Option<&String> {
    self.limit_bandwidth_unit.as_ref()
  }

  pub fn reset_limit_bandwidth_unit(&mut self) {
    self.limit_bandwidth_unit = None;
  }

  pub fn set_limit_date_range_from(&mut self, limit_date_range_from: String) {
    self.limit_date_range_from = Some(limit_date_range_from);
  }

  pub fn with_limit_date_range_from(mut self, limit_date_range_from: String) -> RepositoryTokenRequestPatch {
    self.limit_date_range_from = Some(limit_date_range_from);
    self
  }

  pub fn limit_date_range_from(&self) -> Option<&String> {
    self.limit_date_range_from.as_ref()
  }

  pub fn reset_limit_date_range_from(&mut self) {
    self.limit_date_range_from = None;
  }

  pub fn set_limit_date_range_to(&mut self, limit_date_range_to: String) {
    self.limit_date_range_to = Some(limit_date_range_to);
  }

  pub fn with_limit_date_range_to(mut self, limit_date_range_to: String) -> RepositoryTokenRequestPatch {
    self.limit_date_range_to = Some(limit_date_range_to);
    self
  }

  pub fn limit_date_range_to(&self) -> Option<&String> {
    self.limit_date_range_to.as_ref()
  }

  pub fn reset_limit_date_range_to(&mut self) {
    self.limit_date_range_to = None;
  }

  pub fn set_limit_num_clients(&mut self, limit_num_clients: i32) {
    self.limit_num_clients = Some(limit_num_clients);
  }

  pub fn with_limit_num_clients(mut self, limit_num_clients: i32) -> RepositoryTokenRequestPatch {
    self.limit_num_clients = Some(limit_num_clients);
    self
  }

  pub fn limit_num_clients(&self) -> Option<&i32> {
    self.limit_num_clients.as_ref()
  }

  pub fn reset_limit_num_clients(&mut self) {
    self.limit_num_clients = None;
  }

  pub fn set_limit_num_downloads(&mut self, limit_num_downloads: i32) {
    self.limit_num_downloads = Some(limit_num_downloads);
  }

  pub fn with_limit_num_downloads(mut self, limit_num_downloads: i32) -> RepositoryTokenRequestPatch {
    self.limit_num_downloads = Some(limit_num_downloads);
    self
  }

  pub fn limit_num_downloads(&self) -> Option<&i32> {
    self.limit_num_downloads.as_ref()
  }

  pub fn reset_limit_num_downloads(&mut self) {
    self.limit_num_downloads = None;
  }

  pub fn set_limit_package_query(&mut self, limit_package_query: String) {
    self.limit_package_query = Some(limit_package_query);
  }

  pub fn with_limit_package_query(mut self, limit_package_query: String) -> RepositoryTokenRequestPatch {
    self.limit_package_query = Some(limit_package_query);
    self
  }

  pub fn limit_package_query(&self) -> Option<&String> {
    self.limit_package_query.as_ref()
  }

  pub fn reset_limit_package_query(&mut self) {
    self.limit_package_query = None;
  }

  pub fn set_limit_path_query(&mut self, limit_path_query: String) {
    self.limit_path_query = Some(limit_path_query);
  }

  pub fn with_limit_path_query(mut self, limit_path_query: String) -> RepositoryTokenRequestPatch {
    self.limit_path_query = Some(limit_path_query);
    self
  }

  pub fn limit_path_query(&self) -> Option<&String> {
    self.limit_path_query.as_ref()
  }

  pub fn reset_limit_path_query(&mut self) {
    self.limit_path_query = None;
  }

  pub fn set_metadata(&mut self, metadata: Value) {
    self.metadata = Some(metadata);
  }

  pub fn with_metadata(mut self, metadata: Value) -> RepositoryTokenRequestPatch {
    self.metadata = Some(metadata);
    self
  }

  pub fn metadata(&self) -> Option<&Value> {
    self.metadata.as_ref()
  }

  pub fn reset_metadata(&mut self) {
    self.metadata = None;
  }

  pub fn set_name(&mut self, name: String) {
    self.name = Some(name);
  }

  pub fn with_name(mut self, name: String) -> RepositoryTokenRequestPatch {
    self.name = Some(name);
    self
  }

  pub fn name(&self) -> Option<&String> {
    self.name.as_ref()
  }

  pub fn reset_name(&mut self) {
    self.name = None;
  }

  pub fn set_scheduled_reset_at(&mut self, scheduled_reset_at: String) {
    self.scheduled_reset_at = Some(scheduled_reset_at);
  }

  pub fn with_scheduled_reset_at(mut self, scheduled_reset_at: String) -> RepositoryTokenRequestPatch {
    self.scheduled_reset_at = Some(scheduled_reset_at);
    self
  }

  pub fn scheduled_reset_at(&self) -> Option<&String> {
    self.scheduled_reset_at.as_ref()
  }

  pub fn reset_scheduled_reset_at(&mut self) {
    self.scheduled_reset_at = None;
  }

  pub fn set_scheduled_reset_period(&mut self, scheduled_reset_period: String) {
    self.scheduled_reset_period = Some(scheduled_reset_period);
  }

  pub fn with_scheduled_reset_period(mut self, scheduled_reset_period: String) -> RepositoryTokenRequestPatch {
    self.scheduled_reset_period = Some(scheduled_reset_period);
    self
  }

  pub fn scheduled_reset_period(&self) -> Option<&String> {
    self.scheduled_reset_period.as_ref()
  }

  pub fn reset_scheduled_reset_period(&mut self) {
    self.scheduled_reset_period = None;
  }

  pub fn set_token(&mut self, token: String) {
    self.token = Some(token);
  }

  pub fn with_token(mut self, token: String) -> RepositoryTokenRequestPatch {
    self.token = Some(token);
    self
  }

  pub fn token(&self) -> Option<&String> {
    self.token.as_ref()
  }

  pub fn reset_token(&mut self) {
    self.token = None;
  }

}



