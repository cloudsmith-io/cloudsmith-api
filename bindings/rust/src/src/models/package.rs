/* 
 * Cloudsmith API (v1)
 *
 * The API to the Cloudsmith Service
 *
 * OpenAPI spec version: v1
 * Contact: support@cloudsmith.io
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct Package {
  #[serde(rename = "architectures")]
  architectures: Option<Vec<::models::Architecture>>,
  #[serde(rename = "cdn_url")]
  cdn_url: Option<String>,
  #[serde(rename = "checksum_md5")]
  checksum_md5: Option<String>,
  #[serde(rename = "checksum_sha1")]
  checksum_sha1: Option<String>,
  #[serde(rename = "checksum_sha256")]
  checksum_sha256: Option<String>,
  #[serde(rename = "checksum_sha512")]
  checksum_sha512: Option<String>,
  /// A checksum of all of the package's dependencies.
  #[serde(rename = "dependencies_checksum_md5")]
  dependencies_checksum_md5: Option<String>,
  #[serde(rename = "dependencies_url")]
  dependencies_url: Option<String>,
  /// A textual description of this package.
  #[serde(rename = "description")]
  description: Option<String>,
  #[serde(rename = "display_name")]
  display_name: Option<String>,
  #[serde(rename = "distro")]
  distro: Option<::models::Distribution>,
  #[serde(rename = "distro_version")]
  distro_version: Option<::models::DistributionVersion>,
  #[serde(rename = "downloads")]
  downloads: Option<i32>,
  /// The epoch of the package version (if any).
  #[serde(rename = "epoch")]
  epoch: Option<i32>,
  #[serde(rename = "extension")]
  extension: Option<String>,
  #[serde(rename = "filename")]
  filename: Option<String>,
  #[serde(rename = "files")]
  files: Option<Vec<::models::PackageFile>>,
  #[serde(rename = "format")]
  format: Option<String>,
  #[serde(rename = "format_url")]
  format_url: Option<String>,
  /// Amount of storage that will be freed if this package is deleted
  #[serde(rename = "freeable_storage")]
  freeable_storage: Option<i32>,
  #[serde(rename = "fully_qualified_name")]
  fully_qualified_name: Option<String>,
  /// Unique and permanent identifier for the package.
  #[serde(rename = "identifier_perm")]
  identifier_perm: Option<String>,
  /// Return a map of identifier field names and their values.
  #[serde(rename = "identifiers")]
  identifiers: Option<::std::collections::HashMap<String, String>>,
  #[serde(rename = "indexed")]
  indexed: Option<bool>,
  #[serde(rename = "is_cancellable")]
  is_cancellable: Option<bool>,
  #[serde(rename = "is_copyable")]
  is_copyable: Option<bool>,
  #[serde(rename = "is_deleteable")]
  is_deleteable: Option<bool>,
  #[serde(rename = "is_downloadable")]
  is_downloadable: Option<bool>,
  #[serde(rename = "is_moveable")]
  is_moveable: Option<bool>,
  #[serde(rename = "is_quarantinable")]
  is_quarantinable: Option<bool>,
  #[serde(rename = "is_quarantined")]
  is_quarantined: Option<bool>,
  #[serde(rename = "is_resyncable")]
  is_resyncable: Option<bool>,
  #[serde(rename = "is_security_scannable")]
  is_security_scannable: Option<bool>,
  #[serde(rename = "is_sync_awaiting")]
  is_sync_awaiting: Option<bool>,
  #[serde(rename = "is_sync_completed")]
  is_sync_completed: Option<bool>,
  #[serde(rename = "is_sync_failed")]
  is_sync_failed: Option<bool>,
  #[serde(rename = "is_sync_in_flight")]
  is_sync_in_flight: Option<bool>,
  #[serde(rename = "is_sync_in_progress")]
  is_sync_in_progress: Option<bool>,
  /// The license of this package.
  #[serde(rename = "license")]
  license: Option<String>,
  /// The name of this package.
  #[serde(rename = "name")]
  name: Option<String>,
  #[serde(rename = "namespace")]
  namespace: Option<String>,
  #[serde(rename = "namespace_url")]
  namespace_url: Option<String>,
  #[serde(rename = "num_files")]
  num_files: Option<i32>,
  #[serde(rename = "origin_repository")]
  origin_repository: Option<String>,
  #[serde(rename = "origin_repository_url")]
  origin_repository_url: Option<String>,
  /// The type of package contents.
  #[serde(rename = "package_type")]
  package_type: Option<i32>,
  /// Whether or not the package has violated any policy.
  #[serde(rename = "policy_violated")]
  policy_violated: Option<bool>,
  /// The release of the package version (if any).
  #[serde(rename = "release")]
  release: Option<String>,
  #[serde(rename = "repository")]
  repository: Option<String>,
  #[serde(rename = "repository_url")]
  repository_url: Option<String>,
  /// The datetime the security scanning was completed.
  #[serde(rename = "security_scan_completed_at")]
  security_scan_completed_at: Option<String>,
  /// The datetime the security scanning was started.
  #[serde(rename = "security_scan_started_at")]
  security_scan_started_at: Option<String>,
  #[serde(rename = "security_scan_status")]
  security_scan_status: Option<String>,
  /// The datetime the security scanning status was updated.
  #[serde(rename = "security_scan_status_updated_at")]
  security_scan_status_updated_at: Option<String>,
  #[serde(rename = "self_html_url")]
  self_html_url: Option<String>,
  #[serde(rename = "self_url")]
  self_url: Option<String>,
  #[serde(rename = "signature_url")]
  signature_url: Option<String>,
  /// The calculated size of the package.
  #[serde(rename = "size")]
  size: Option<i32>,
  /// The public unique identifier for the package.
  #[serde(rename = "slug")]
  slug: Option<String>,
  #[serde(rename = "slug_perm")]
  slug_perm: Option<String>,
  /// The synchronisation (in progress) stage of the package.
  #[serde(rename = "stage")]
  stage: Option<i32>,
  #[serde(rename = "stage_str")]
  stage_str: Option<String>,
  /// The datetime the package stage was updated at.
  #[serde(rename = "stage_updated_at")]
  stage_updated_at: Option<String>,
  /// The synchronisation status of the package.
  #[serde(rename = "status")]
  status: Option<i32>,
  /// A textual description for the synchronous status reason (if any
  #[serde(rename = "status_reason")]
  status_reason: Option<String>,
  #[serde(rename = "status_str")]
  status_str: Option<String>,
  /// The datetime the package status was updated at.
  #[serde(rename = "status_updated_at")]
  status_updated_at: Option<String>,
  #[serde(rename = "status_url")]
  status_url: Option<String>,
  #[serde(rename = "subtype")]
  subtype: Option<String>,
  /// A one-liner synopsis of this package.
  #[serde(rename = "summary")]
  summary: Option<String>,
  /// The datetime the package sync was finished at.
  #[serde(rename = "sync_finished_at")]
  sync_finished_at: Option<String>,
  /// Synchronisation progress (from 0-100)
  #[serde(rename = "sync_progress")]
  sync_progress: Option<i32>,
  #[serde(rename = "tags")]
  tags: Option<::models::Tags>,
  #[serde(rename = "tags_immutable")]
  tags_immutable: Option<::models::Tags>,
  #[serde(rename = "type_display")]
  type_display: Option<String>,
  /// The date this package was uploaded.
  #[serde(rename = "uploaded_at")]
  uploaded_at: Option<String>,
  #[serde(rename = "uploader")]
  uploader: Option<String>,
  #[serde(rename = "uploader_url")]
  uploader_url: Option<String>,
  /// The raw version for this package.
  #[serde(rename = "version")]
  version: Option<String>,
  #[serde(rename = "version_orig")]
  version_orig: Option<String>,
  #[serde(rename = "vulnerability_scan_results_url")]
  vulnerability_scan_results_url: Option<String>
}

impl Package {
  pub fn new() -> Package {
    Package {
      architectures: None,
      cdn_url: None,
      checksum_md5: None,
      checksum_sha1: None,
      checksum_sha256: None,
      checksum_sha512: None,
      dependencies_checksum_md5: None,
      dependencies_url: None,
      description: None,
      display_name: None,
      distro: None,
      distro_version: None,
      downloads: None,
      epoch: None,
      extension: None,
      filename: None,
      files: None,
      format: None,
      format_url: None,
      freeable_storage: None,
      fully_qualified_name: None,
      identifier_perm: None,
      identifiers: None,
      indexed: None,
      is_cancellable: None,
      is_copyable: None,
      is_deleteable: None,
      is_downloadable: None,
      is_moveable: None,
      is_quarantinable: None,
      is_quarantined: None,
      is_resyncable: None,
      is_security_scannable: None,
      is_sync_awaiting: None,
      is_sync_completed: None,
      is_sync_failed: None,
      is_sync_in_flight: None,
      is_sync_in_progress: None,
      license: None,
      name: None,
      namespace: None,
      namespace_url: None,
      num_files: None,
      origin_repository: None,
      origin_repository_url: None,
      package_type: None,
      policy_violated: None,
      release: None,
      repository: None,
      repository_url: None,
      security_scan_completed_at: None,
      security_scan_started_at: None,
      security_scan_status: None,
      security_scan_status_updated_at: None,
      self_html_url: None,
      self_url: None,
      signature_url: None,
      size: None,
      slug: None,
      slug_perm: None,
      stage: None,
      stage_str: None,
      stage_updated_at: None,
      status: None,
      status_reason: None,
      status_str: None,
      status_updated_at: None,
      status_url: None,
      subtype: None,
      summary: None,
      sync_finished_at: None,
      sync_progress: None,
      tags: None,
      tags_immutable: None,
      type_display: None,
      uploaded_at: None,
      uploader: None,
      uploader_url: None,
      version: None,
      version_orig: None,
      vulnerability_scan_results_url: None
    }
  }

  pub fn set_architectures(&mut self, architectures: Vec<::models::Architecture>) {
    self.architectures = Some(architectures);
  }

  pub fn with_architectures(mut self, architectures: Vec<::models::Architecture>) -> Package {
    self.architectures = Some(architectures);
    self
  }

  pub fn architectures(&self) -> Option<&Vec<::models::Architecture>> {
    self.architectures.as_ref()
  }

  pub fn reset_architectures(&mut self) {
    self.architectures = None;
  }

  pub fn set_cdn_url(&mut self, cdn_url: String) {
    self.cdn_url = Some(cdn_url);
  }

  pub fn with_cdn_url(mut self, cdn_url: String) -> Package {
    self.cdn_url = Some(cdn_url);
    self
  }

  pub fn cdn_url(&self) -> Option<&String> {
    self.cdn_url.as_ref()
  }

  pub fn reset_cdn_url(&mut self) {
    self.cdn_url = None;
  }

  pub fn set_checksum_md5(&mut self, checksum_md5: String) {
    self.checksum_md5 = Some(checksum_md5);
  }

  pub fn with_checksum_md5(mut self, checksum_md5: String) -> Package {
    self.checksum_md5 = Some(checksum_md5);
    self
  }

  pub fn checksum_md5(&self) -> Option<&String> {
    self.checksum_md5.as_ref()
  }

  pub fn reset_checksum_md5(&mut self) {
    self.checksum_md5 = None;
  }

  pub fn set_checksum_sha1(&mut self, checksum_sha1: String) {
    self.checksum_sha1 = Some(checksum_sha1);
  }

  pub fn with_checksum_sha1(mut self, checksum_sha1: String) -> Package {
    self.checksum_sha1 = Some(checksum_sha1);
    self
  }

  pub fn checksum_sha1(&self) -> Option<&String> {
    self.checksum_sha1.as_ref()
  }

  pub fn reset_checksum_sha1(&mut self) {
    self.checksum_sha1 = None;
  }

  pub fn set_checksum_sha256(&mut self, checksum_sha256: String) {
    self.checksum_sha256 = Some(checksum_sha256);
  }

  pub fn with_checksum_sha256(mut self, checksum_sha256: String) -> Package {
    self.checksum_sha256 = Some(checksum_sha256);
    self
  }

  pub fn checksum_sha256(&self) -> Option<&String> {
    self.checksum_sha256.as_ref()
  }

  pub fn reset_checksum_sha256(&mut self) {
    self.checksum_sha256 = None;
  }

  pub fn set_checksum_sha512(&mut self, checksum_sha512: String) {
    self.checksum_sha512 = Some(checksum_sha512);
  }

  pub fn with_checksum_sha512(mut self, checksum_sha512: String) -> Package {
    self.checksum_sha512 = Some(checksum_sha512);
    self
  }

  pub fn checksum_sha512(&self) -> Option<&String> {
    self.checksum_sha512.as_ref()
  }

  pub fn reset_checksum_sha512(&mut self) {
    self.checksum_sha512 = None;
  }

  pub fn set_dependencies_checksum_md5(&mut self, dependencies_checksum_md5: String) {
    self.dependencies_checksum_md5 = Some(dependencies_checksum_md5);
  }

  pub fn with_dependencies_checksum_md5(mut self, dependencies_checksum_md5: String) -> Package {
    self.dependencies_checksum_md5 = Some(dependencies_checksum_md5);
    self
  }

  pub fn dependencies_checksum_md5(&self) -> Option<&String> {
    self.dependencies_checksum_md5.as_ref()
  }

  pub fn reset_dependencies_checksum_md5(&mut self) {
    self.dependencies_checksum_md5 = None;
  }

  pub fn set_dependencies_url(&mut self, dependencies_url: String) {
    self.dependencies_url = Some(dependencies_url);
  }

  pub fn with_dependencies_url(mut self, dependencies_url: String) -> Package {
    self.dependencies_url = Some(dependencies_url);
    self
  }

  pub fn dependencies_url(&self) -> Option<&String> {
    self.dependencies_url.as_ref()
  }

  pub fn reset_dependencies_url(&mut self) {
    self.dependencies_url = None;
  }

  pub fn set_description(&mut self, description: String) {
    self.description = Some(description);
  }

  pub fn with_description(mut self, description: String) -> Package {
    self.description = Some(description);
    self
  }

  pub fn description(&self) -> Option<&String> {
    self.description.as_ref()
  }

  pub fn reset_description(&mut self) {
    self.description = None;
  }

  pub fn set_display_name(&mut self, display_name: String) {
    self.display_name = Some(display_name);
  }

  pub fn with_display_name(mut self, display_name: String) -> Package {
    self.display_name = Some(display_name);
    self
  }

  pub fn display_name(&self) -> Option<&String> {
    self.display_name.as_ref()
  }

  pub fn reset_display_name(&mut self) {
    self.display_name = None;
  }

  pub fn set_distro(&mut self, distro: ::models::Distribution) {
    self.distro = Some(distro);
  }

  pub fn with_distro(mut self, distro: ::models::Distribution) -> Package {
    self.distro = Some(distro);
    self
  }

  pub fn distro(&self) -> Option<&::models::Distribution> {
    self.distro.as_ref()
  }

  pub fn reset_distro(&mut self) {
    self.distro = None;
  }

  pub fn set_distro_version(&mut self, distro_version: ::models::DistributionVersion) {
    self.distro_version = Some(distro_version);
  }

  pub fn with_distro_version(mut self, distro_version: ::models::DistributionVersion) -> Package {
    self.distro_version = Some(distro_version);
    self
  }

  pub fn distro_version(&self) -> Option<&::models::DistributionVersion> {
    self.distro_version.as_ref()
  }

  pub fn reset_distro_version(&mut self) {
    self.distro_version = None;
  }

  pub fn set_downloads(&mut self, downloads: i32) {
    self.downloads = Some(downloads);
  }

  pub fn with_downloads(mut self, downloads: i32) -> Package {
    self.downloads = Some(downloads);
    self
  }

  pub fn downloads(&self) -> Option<&i32> {
    self.downloads.as_ref()
  }

  pub fn reset_downloads(&mut self) {
    self.downloads = None;
  }

  pub fn set_epoch(&mut self, epoch: i32) {
    self.epoch = Some(epoch);
  }

  pub fn with_epoch(mut self, epoch: i32) -> Package {
    self.epoch = Some(epoch);
    self
  }

  pub fn epoch(&self) -> Option<&i32> {
    self.epoch.as_ref()
  }

  pub fn reset_epoch(&mut self) {
    self.epoch = None;
  }

  pub fn set_extension(&mut self, extension: String) {
    self.extension = Some(extension);
  }

  pub fn with_extension(mut self, extension: String) -> Package {
    self.extension = Some(extension);
    self
  }

  pub fn extension(&self) -> Option<&String> {
    self.extension.as_ref()
  }

  pub fn reset_extension(&mut self) {
    self.extension = None;
  }

  pub fn set_filename(&mut self, filename: String) {
    self.filename = Some(filename);
  }

  pub fn with_filename(mut self, filename: String) -> Package {
    self.filename = Some(filename);
    self
  }

  pub fn filename(&self) -> Option<&String> {
    self.filename.as_ref()
  }

  pub fn reset_filename(&mut self) {
    self.filename = None;
  }

  pub fn set_files(&mut self, files: Vec<::models::PackageFile>) {
    self.files = Some(files);
  }

  pub fn with_files(mut self, files: Vec<::models::PackageFile>) -> Package {
    self.files = Some(files);
    self
  }

  pub fn files(&self) -> Option<&Vec<::models::PackageFile>> {
    self.files.as_ref()
  }

  pub fn reset_files(&mut self) {
    self.files = None;
  }

  pub fn set_format(&mut self, format: String) {
    self.format = Some(format);
  }

  pub fn with_format(mut self, format: String) -> Package {
    self.format = Some(format);
    self
  }

  pub fn format(&self) -> Option<&String> {
    self.format.as_ref()
  }

  pub fn reset_format(&mut self) {
    self.format = None;
  }

  pub fn set_format_url(&mut self, format_url: String) {
    self.format_url = Some(format_url);
  }

  pub fn with_format_url(mut self, format_url: String) -> Package {
    self.format_url = Some(format_url);
    self
  }

  pub fn format_url(&self) -> Option<&String> {
    self.format_url.as_ref()
  }

  pub fn reset_format_url(&mut self) {
    self.format_url = None;
  }

  pub fn set_freeable_storage(&mut self, freeable_storage: i32) {
    self.freeable_storage = Some(freeable_storage);
  }

  pub fn with_freeable_storage(mut self, freeable_storage: i32) -> Package {
    self.freeable_storage = Some(freeable_storage);
    self
  }

  pub fn freeable_storage(&self) -> Option<&i32> {
    self.freeable_storage.as_ref()
  }

  pub fn reset_freeable_storage(&mut self) {
    self.freeable_storage = None;
  }

  pub fn set_fully_qualified_name(&mut self, fully_qualified_name: String) {
    self.fully_qualified_name = Some(fully_qualified_name);
  }

  pub fn with_fully_qualified_name(mut self, fully_qualified_name: String) -> Package {
    self.fully_qualified_name = Some(fully_qualified_name);
    self
  }

  pub fn fully_qualified_name(&self) -> Option<&String> {
    self.fully_qualified_name.as_ref()
  }

  pub fn reset_fully_qualified_name(&mut self) {
    self.fully_qualified_name = None;
  }

  pub fn set_identifier_perm(&mut self, identifier_perm: String) {
    self.identifier_perm = Some(identifier_perm);
  }

  pub fn with_identifier_perm(mut self, identifier_perm: String) -> Package {
    self.identifier_perm = Some(identifier_perm);
    self
  }

  pub fn identifier_perm(&self) -> Option<&String> {
    self.identifier_perm.as_ref()
  }

  pub fn reset_identifier_perm(&mut self) {
    self.identifier_perm = None;
  }

  pub fn set_identifiers(&mut self, identifiers: ::std::collections::HashMap<String, String>) {
    self.identifiers = Some(identifiers);
  }

  pub fn with_identifiers(mut self, identifiers: ::std::collections::HashMap<String, String>) -> Package {
    self.identifiers = Some(identifiers);
    self
  }

  pub fn identifiers(&self) -> Option<&::std::collections::HashMap<String, String>> {
    self.identifiers.as_ref()
  }

  pub fn reset_identifiers(&mut self) {
    self.identifiers = None;
  }

  pub fn set_indexed(&mut self, indexed: bool) {
    self.indexed = Some(indexed);
  }

  pub fn with_indexed(mut self, indexed: bool) -> Package {
    self.indexed = Some(indexed);
    self
  }

  pub fn indexed(&self) -> Option<&bool> {
    self.indexed.as_ref()
  }

  pub fn reset_indexed(&mut self) {
    self.indexed = None;
  }

  pub fn set_is_cancellable(&mut self, is_cancellable: bool) {
    self.is_cancellable = Some(is_cancellable);
  }

  pub fn with_is_cancellable(mut self, is_cancellable: bool) -> Package {
    self.is_cancellable = Some(is_cancellable);
    self
  }

  pub fn is_cancellable(&self) -> Option<&bool> {
    self.is_cancellable.as_ref()
  }

  pub fn reset_is_cancellable(&mut self) {
    self.is_cancellable = None;
  }

  pub fn set_is_copyable(&mut self, is_copyable: bool) {
    self.is_copyable = Some(is_copyable);
  }

  pub fn with_is_copyable(mut self, is_copyable: bool) -> Package {
    self.is_copyable = Some(is_copyable);
    self
  }

  pub fn is_copyable(&self) -> Option<&bool> {
    self.is_copyable.as_ref()
  }

  pub fn reset_is_copyable(&mut self) {
    self.is_copyable = None;
  }

  pub fn set_is_deleteable(&mut self, is_deleteable: bool) {
    self.is_deleteable = Some(is_deleteable);
  }

  pub fn with_is_deleteable(mut self, is_deleteable: bool) -> Package {
    self.is_deleteable = Some(is_deleteable);
    self
  }

  pub fn is_deleteable(&self) -> Option<&bool> {
    self.is_deleteable.as_ref()
  }

  pub fn reset_is_deleteable(&mut self) {
    self.is_deleteable = None;
  }

  pub fn set_is_downloadable(&mut self, is_downloadable: bool) {
    self.is_downloadable = Some(is_downloadable);
  }

  pub fn with_is_downloadable(mut self, is_downloadable: bool) -> Package {
    self.is_downloadable = Some(is_downloadable);
    self
  }

  pub fn is_downloadable(&self) -> Option<&bool> {
    self.is_downloadable.as_ref()
  }

  pub fn reset_is_downloadable(&mut self) {
    self.is_downloadable = None;
  }

  pub fn set_is_moveable(&mut self, is_moveable: bool) {
    self.is_moveable = Some(is_moveable);
  }

  pub fn with_is_moveable(mut self, is_moveable: bool) -> Package {
    self.is_moveable = Some(is_moveable);
    self
  }

  pub fn is_moveable(&self) -> Option<&bool> {
    self.is_moveable.as_ref()
  }

  pub fn reset_is_moveable(&mut self) {
    self.is_moveable = None;
  }

  pub fn set_is_quarantinable(&mut self, is_quarantinable: bool) {
    self.is_quarantinable = Some(is_quarantinable);
  }

  pub fn with_is_quarantinable(mut self, is_quarantinable: bool) -> Package {
    self.is_quarantinable = Some(is_quarantinable);
    self
  }

  pub fn is_quarantinable(&self) -> Option<&bool> {
    self.is_quarantinable.as_ref()
  }

  pub fn reset_is_quarantinable(&mut self) {
    self.is_quarantinable = None;
  }

  pub fn set_is_quarantined(&mut self, is_quarantined: bool) {
    self.is_quarantined = Some(is_quarantined);
  }

  pub fn with_is_quarantined(mut self, is_quarantined: bool) -> Package {
    self.is_quarantined = Some(is_quarantined);
    self
  }

  pub fn is_quarantined(&self) -> Option<&bool> {
    self.is_quarantined.as_ref()
  }

  pub fn reset_is_quarantined(&mut self) {
    self.is_quarantined = None;
  }

  pub fn set_is_resyncable(&mut self, is_resyncable: bool) {
    self.is_resyncable = Some(is_resyncable);
  }

  pub fn with_is_resyncable(mut self, is_resyncable: bool) -> Package {
    self.is_resyncable = Some(is_resyncable);
    self
  }

  pub fn is_resyncable(&self) -> Option<&bool> {
    self.is_resyncable.as_ref()
  }

  pub fn reset_is_resyncable(&mut self) {
    self.is_resyncable = None;
  }

  pub fn set_is_security_scannable(&mut self, is_security_scannable: bool) {
    self.is_security_scannable = Some(is_security_scannable);
  }

  pub fn with_is_security_scannable(mut self, is_security_scannable: bool) -> Package {
    self.is_security_scannable = Some(is_security_scannable);
    self
  }

  pub fn is_security_scannable(&self) -> Option<&bool> {
    self.is_security_scannable.as_ref()
  }

  pub fn reset_is_security_scannable(&mut self) {
    self.is_security_scannable = None;
  }

  pub fn set_is_sync_awaiting(&mut self, is_sync_awaiting: bool) {
    self.is_sync_awaiting = Some(is_sync_awaiting);
  }

  pub fn with_is_sync_awaiting(mut self, is_sync_awaiting: bool) -> Package {
    self.is_sync_awaiting = Some(is_sync_awaiting);
    self
  }

  pub fn is_sync_awaiting(&self) -> Option<&bool> {
    self.is_sync_awaiting.as_ref()
  }

  pub fn reset_is_sync_awaiting(&mut self) {
    self.is_sync_awaiting = None;
  }

  pub fn set_is_sync_completed(&mut self, is_sync_completed: bool) {
    self.is_sync_completed = Some(is_sync_completed);
  }

  pub fn with_is_sync_completed(mut self, is_sync_completed: bool) -> Package {
    self.is_sync_completed = Some(is_sync_completed);
    self
  }

  pub fn is_sync_completed(&self) -> Option<&bool> {
    self.is_sync_completed.as_ref()
  }

  pub fn reset_is_sync_completed(&mut self) {
    self.is_sync_completed = None;
  }

  pub fn set_is_sync_failed(&mut self, is_sync_failed: bool) {
    self.is_sync_failed = Some(is_sync_failed);
  }

  pub fn with_is_sync_failed(mut self, is_sync_failed: bool) -> Package {
    self.is_sync_failed = Some(is_sync_failed);
    self
  }

  pub fn is_sync_failed(&self) -> Option<&bool> {
    self.is_sync_failed.as_ref()
  }

  pub fn reset_is_sync_failed(&mut self) {
    self.is_sync_failed = None;
  }

  pub fn set_is_sync_in_flight(&mut self, is_sync_in_flight: bool) {
    self.is_sync_in_flight = Some(is_sync_in_flight);
  }

  pub fn with_is_sync_in_flight(mut self, is_sync_in_flight: bool) -> Package {
    self.is_sync_in_flight = Some(is_sync_in_flight);
    self
  }

  pub fn is_sync_in_flight(&self) -> Option<&bool> {
    self.is_sync_in_flight.as_ref()
  }

  pub fn reset_is_sync_in_flight(&mut self) {
    self.is_sync_in_flight = None;
  }

  pub fn set_is_sync_in_progress(&mut self, is_sync_in_progress: bool) {
    self.is_sync_in_progress = Some(is_sync_in_progress);
  }

  pub fn with_is_sync_in_progress(mut self, is_sync_in_progress: bool) -> Package {
    self.is_sync_in_progress = Some(is_sync_in_progress);
    self
  }

  pub fn is_sync_in_progress(&self) -> Option<&bool> {
    self.is_sync_in_progress.as_ref()
  }

  pub fn reset_is_sync_in_progress(&mut self) {
    self.is_sync_in_progress = None;
  }

  pub fn set_license(&mut self, license: String) {
    self.license = Some(license);
  }

  pub fn with_license(mut self, license: String) -> Package {
    self.license = Some(license);
    self
  }

  pub fn license(&self) -> Option<&String> {
    self.license.as_ref()
  }

  pub fn reset_license(&mut self) {
    self.license = None;
  }

  pub fn set_name(&mut self, name: String) {
    self.name = Some(name);
  }

  pub fn with_name(mut self, name: String) -> Package {
    self.name = Some(name);
    self
  }

  pub fn name(&self) -> Option<&String> {
    self.name.as_ref()
  }

  pub fn reset_name(&mut self) {
    self.name = None;
  }

  pub fn set_namespace(&mut self, namespace: String) {
    self.namespace = Some(namespace);
  }

  pub fn with_namespace(mut self, namespace: String) -> Package {
    self.namespace = Some(namespace);
    self
  }

  pub fn namespace(&self) -> Option<&String> {
    self.namespace.as_ref()
  }

  pub fn reset_namespace(&mut self) {
    self.namespace = None;
  }

  pub fn set_namespace_url(&mut self, namespace_url: String) {
    self.namespace_url = Some(namespace_url);
  }

  pub fn with_namespace_url(mut self, namespace_url: String) -> Package {
    self.namespace_url = Some(namespace_url);
    self
  }

  pub fn namespace_url(&self) -> Option<&String> {
    self.namespace_url.as_ref()
  }

  pub fn reset_namespace_url(&mut self) {
    self.namespace_url = None;
  }

  pub fn set_num_files(&mut self, num_files: i32) {
    self.num_files = Some(num_files);
  }

  pub fn with_num_files(mut self, num_files: i32) -> Package {
    self.num_files = Some(num_files);
    self
  }

  pub fn num_files(&self) -> Option<&i32> {
    self.num_files.as_ref()
  }

  pub fn reset_num_files(&mut self) {
    self.num_files = None;
  }

  pub fn set_origin_repository(&mut self, origin_repository: String) {
    self.origin_repository = Some(origin_repository);
  }

  pub fn with_origin_repository(mut self, origin_repository: String) -> Package {
    self.origin_repository = Some(origin_repository);
    self
  }

  pub fn origin_repository(&self) -> Option<&String> {
    self.origin_repository.as_ref()
  }

  pub fn reset_origin_repository(&mut self) {
    self.origin_repository = None;
  }

  pub fn set_origin_repository_url(&mut self, origin_repository_url: String) {
    self.origin_repository_url = Some(origin_repository_url);
  }

  pub fn with_origin_repository_url(mut self, origin_repository_url: String) -> Package {
    self.origin_repository_url = Some(origin_repository_url);
    self
  }

  pub fn origin_repository_url(&self) -> Option<&String> {
    self.origin_repository_url.as_ref()
  }

  pub fn reset_origin_repository_url(&mut self) {
    self.origin_repository_url = None;
  }

  pub fn set_package_type(&mut self, package_type: i32) {
    self.package_type = Some(package_type);
  }

  pub fn with_package_type(mut self, package_type: i32) -> Package {
    self.package_type = Some(package_type);
    self
  }

  pub fn package_type(&self) -> Option<&i32> {
    self.package_type.as_ref()
  }

  pub fn reset_package_type(&mut self) {
    self.package_type = None;
  }

  pub fn set_policy_violated(&mut self, policy_violated: bool) {
    self.policy_violated = Some(policy_violated);
  }

  pub fn with_policy_violated(mut self, policy_violated: bool) -> Package {
    self.policy_violated = Some(policy_violated);
    self
  }

  pub fn policy_violated(&self) -> Option<&bool> {
    self.policy_violated.as_ref()
  }

  pub fn reset_policy_violated(&mut self) {
    self.policy_violated = None;
  }

  pub fn set_release(&mut self, release: String) {
    self.release = Some(release);
  }

  pub fn with_release(mut self, release: String) -> Package {
    self.release = Some(release);
    self
  }

  pub fn release(&self) -> Option<&String> {
    self.release.as_ref()
  }

  pub fn reset_release(&mut self) {
    self.release = None;
  }

  pub fn set_repository(&mut self, repository: String) {
    self.repository = Some(repository);
  }

  pub fn with_repository(mut self, repository: String) -> Package {
    self.repository = Some(repository);
    self
  }

  pub fn repository(&self) -> Option<&String> {
    self.repository.as_ref()
  }

  pub fn reset_repository(&mut self) {
    self.repository = None;
  }

  pub fn set_repository_url(&mut self, repository_url: String) {
    self.repository_url = Some(repository_url);
  }

  pub fn with_repository_url(mut self, repository_url: String) -> Package {
    self.repository_url = Some(repository_url);
    self
  }

  pub fn repository_url(&self) -> Option<&String> {
    self.repository_url.as_ref()
  }

  pub fn reset_repository_url(&mut self) {
    self.repository_url = None;
  }

  pub fn set_security_scan_completed_at(&mut self, security_scan_completed_at: String) {
    self.security_scan_completed_at = Some(security_scan_completed_at);
  }

  pub fn with_security_scan_completed_at(mut self, security_scan_completed_at: String) -> Package {
    self.security_scan_completed_at = Some(security_scan_completed_at);
    self
  }

  pub fn security_scan_completed_at(&self) -> Option<&String> {
    self.security_scan_completed_at.as_ref()
  }

  pub fn reset_security_scan_completed_at(&mut self) {
    self.security_scan_completed_at = None;
  }

  pub fn set_security_scan_started_at(&mut self, security_scan_started_at: String) {
    self.security_scan_started_at = Some(security_scan_started_at);
  }

  pub fn with_security_scan_started_at(mut self, security_scan_started_at: String) -> Package {
    self.security_scan_started_at = Some(security_scan_started_at);
    self
  }

  pub fn security_scan_started_at(&self) -> Option<&String> {
    self.security_scan_started_at.as_ref()
  }

  pub fn reset_security_scan_started_at(&mut self) {
    self.security_scan_started_at = None;
  }

  pub fn set_security_scan_status(&mut self, security_scan_status: String) {
    self.security_scan_status = Some(security_scan_status);
  }

  pub fn with_security_scan_status(mut self, security_scan_status: String) -> Package {
    self.security_scan_status = Some(security_scan_status);
    self
  }

  pub fn security_scan_status(&self) -> Option<&String> {
    self.security_scan_status.as_ref()
  }

  pub fn reset_security_scan_status(&mut self) {
    self.security_scan_status = None;
  }

  pub fn set_security_scan_status_updated_at(&mut self, security_scan_status_updated_at: String) {
    self.security_scan_status_updated_at = Some(security_scan_status_updated_at);
  }

  pub fn with_security_scan_status_updated_at(mut self, security_scan_status_updated_at: String) -> Package {
    self.security_scan_status_updated_at = Some(security_scan_status_updated_at);
    self
  }

  pub fn security_scan_status_updated_at(&self) -> Option<&String> {
    self.security_scan_status_updated_at.as_ref()
  }

  pub fn reset_security_scan_status_updated_at(&mut self) {
    self.security_scan_status_updated_at = None;
  }

  pub fn set_self_html_url(&mut self, self_html_url: String) {
    self.self_html_url = Some(self_html_url);
  }

  pub fn with_self_html_url(mut self, self_html_url: String) -> Package {
    self.self_html_url = Some(self_html_url);
    self
  }

  pub fn self_html_url(&self) -> Option<&String> {
    self.self_html_url.as_ref()
  }

  pub fn reset_self_html_url(&mut self) {
    self.self_html_url = None;
  }

  pub fn set_self_url(&mut self, self_url: String) {
    self.self_url = Some(self_url);
  }

  pub fn with_self_url(mut self, self_url: String) -> Package {
    self.self_url = Some(self_url);
    self
  }

  pub fn self_url(&self) -> Option<&String> {
    self.self_url.as_ref()
  }

  pub fn reset_self_url(&mut self) {
    self.self_url = None;
  }

  pub fn set_signature_url(&mut self, signature_url: String) {
    self.signature_url = Some(signature_url);
  }

  pub fn with_signature_url(mut self, signature_url: String) -> Package {
    self.signature_url = Some(signature_url);
    self
  }

  pub fn signature_url(&self) -> Option<&String> {
    self.signature_url.as_ref()
  }

  pub fn reset_signature_url(&mut self) {
    self.signature_url = None;
  }

  pub fn set_size(&mut self, size: i32) {
    self.size = Some(size);
  }

  pub fn with_size(mut self, size: i32) -> Package {
    self.size = Some(size);
    self
  }

  pub fn size(&self) -> Option<&i32> {
    self.size.as_ref()
  }

  pub fn reset_size(&mut self) {
    self.size = None;
  }

  pub fn set_slug(&mut self, slug: String) {
    self.slug = Some(slug);
  }

  pub fn with_slug(mut self, slug: String) -> Package {
    self.slug = Some(slug);
    self
  }

  pub fn slug(&self) -> Option<&String> {
    self.slug.as_ref()
  }

  pub fn reset_slug(&mut self) {
    self.slug = None;
  }

  pub fn set_slug_perm(&mut self, slug_perm: String) {
    self.slug_perm = Some(slug_perm);
  }

  pub fn with_slug_perm(mut self, slug_perm: String) -> Package {
    self.slug_perm = Some(slug_perm);
    self
  }

  pub fn slug_perm(&self) -> Option<&String> {
    self.slug_perm.as_ref()
  }

  pub fn reset_slug_perm(&mut self) {
    self.slug_perm = None;
  }

  pub fn set_stage(&mut self, stage: i32) {
    self.stage = Some(stage);
  }

  pub fn with_stage(mut self, stage: i32) -> Package {
    self.stage = Some(stage);
    self
  }

  pub fn stage(&self) -> Option<&i32> {
    self.stage.as_ref()
  }

  pub fn reset_stage(&mut self) {
    self.stage = None;
  }

  pub fn set_stage_str(&mut self, stage_str: String) {
    self.stage_str = Some(stage_str);
  }

  pub fn with_stage_str(mut self, stage_str: String) -> Package {
    self.stage_str = Some(stage_str);
    self
  }

  pub fn stage_str(&self) -> Option<&String> {
    self.stage_str.as_ref()
  }

  pub fn reset_stage_str(&mut self) {
    self.stage_str = None;
  }

  pub fn set_stage_updated_at(&mut self, stage_updated_at: String) {
    self.stage_updated_at = Some(stage_updated_at);
  }

  pub fn with_stage_updated_at(mut self, stage_updated_at: String) -> Package {
    self.stage_updated_at = Some(stage_updated_at);
    self
  }

  pub fn stage_updated_at(&self) -> Option<&String> {
    self.stage_updated_at.as_ref()
  }

  pub fn reset_stage_updated_at(&mut self) {
    self.stage_updated_at = None;
  }

  pub fn set_status(&mut self, status: i32) {
    self.status = Some(status);
  }

  pub fn with_status(mut self, status: i32) -> Package {
    self.status = Some(status);
    self
  }

  pub fn status(&self) -> Option<&i32> {
    self.status.as_ref()
  }

  pub fn reset_status(&mut self) {
    self.status = None;
  }

  pub fn set_status_reason(&mut self, status_reason: String) {
    self.status_reason = Some(status_reason);
  }

  pub fn with_status_reason(mut self, status_reason: String) -> Package {
    self.status_reason = Some(status_reason);
    self
  }

  pub fn status_reason(&self) -> Option<&String> {
    self.status_reason.as_ref()
  }

  pub fn reset_status_reason(&mut self) {
    self.status_reason = None;
  }

  pub fn set_status_str(&mut self, status_str: String) {
    self.status_str = Some(status_str);
  }

  pub fn with_status_str(mut self, status_str: String) -> Package {
    self.status_str = Some(status_str);
    self
  }

  pub fn status_str(&self) -> Option<&String> {
    self.status_str.as_ref()
  }

  pub fn reset_status_str(&mut self) {
    self.status_str = None;
  }

  pub fn set_status_updated_at(&mut self, status_updated_at: String) {
    self.status_updated_at = Some(status_updated_at);
  }

  pub fn with_status_updated_at(mut self, status_updated_at: String) -> Package {
    self.status_updated_at = Some(status_updated_at);
    self
  }

  pub fn status_updated_at(&self) -> Option<&String> {
    self.status_updated_at.as_ref()
  }

  pub fn reset_status_updated_at(&mut self) {
    self.status_updated_at = None;
  }

  pub fn set_status_url(&mut self, status_url: String) {
    self.status_url = Some(status_url);
  }

  pub fn with_status_url(mut self, status_url: String) -> Package {
    self.status_url = Some(status_url);
    self
  }

  pub fn status_url(&self) -> Option<&String> {
    self.status_url.as_ref()
  }

  pub fn reset_status_url(&mut self) {
    self.status_url = None;
  }

  pub fn set_subtype(&mut self, subtype: String) {
    self.subtype = Some(subtype);
  }

  pub fn with_subtype(mut self, subtype: String) -> Package {
    self.subtype = Some(subtype);
    self
  }

  pub fn subtype(&self) -> Option<&String> {
    self.subtype.as_ref()
  }

  pub fn reset_subtype(&mut self) {
    self.subtype = None;
  }

  pub fn set_summary(&mut self, summary: String) {
    self.summary = Some(summary);
  }

  pub fn with_summary(mut self, summary: String) -> Package {
    self.summary = Some(summary);
    self
  }

  pub fn summary(&self) -> Option<&String> {
    self.summary.as_ref()
  }

  pub fn reset_summary(&mut self) {
    self.summary = None;
  }

  pub fn set_sync_finished_at(&mut self, sync_finished_at: String) {
    self.sync_finished_at = Some(sync_finished_at);
  }

  pub fn with_sync_finished_at(mut self, sync_finished_at: String) -> Package {
    self.sync_finished_at = Some(sync_finished_at);
    self
  }

  pub fn sync_finished_at(&self) -> Option<&String> {
    self.sync_finished_at.as_ref()
  }

  pub fn reset_sync_finished_at(&mut self) {
    self.sync_finished_at = None;
  }

  pub fn set_sync_progress(&mut self, sync_progress: i32) {
    self.sync_progress = Some(sync_progress);
  }

  pub fn with_sync_progress(mut self, sync_progress: i32) -> Package {
    self.sync_progress = Some(sync_progress);
    self
  }

  pub fn sync_progress(&self) -> Option<&i32> {
    self.sync_progress.as_ref()
  }

  pub fn reset_sync_progress(&mut self) {
    self.sync_progress = None;
  }

  pub fn set_tags(&mut self, tags: ::models::Tags) {
    self.tags = Some(tags);
  }

  pub fn with_tags(mut self, tags: ::models::Tags) -> Package {
    self.tags = Some(tags);
    self
  }

  pub fn tags(&self) -> Option<&::models::Tags> {
    self.tags.as_ref()
  }

  pub fn reset_tags(&mut self) {
    self.tags = None;
  }

  pub fn set_tags_immutable(&mut self, tags_immutable: ::models::Tags) {
    self.tags_immutable = Some(tags_immutable);
  }

  pub fn with_tags_immutable(mut self, tags_immutable: ::models::Tags) -> Package {
    self.tags_immutable = Some(tags_immutable);
    self
  }

  pub fn tags_immutable(&self) -> Option<&::models::Tags> {
    self.tags_immutable.as_ref()
  }

  pub fn reset_tags_immutable(&mut self) {
    self.tags_immutable = None;
  }

  pub fn set_type_display(&mut self, type_display: String) {
    self.type_display = Some(type_display);
  }

  pub fn with_type_display(mut self, type_display: String) -> Package {
    self.type_display = Some(type_display);
    self
  }

  pub fn type_display(&self) -> Option<&String> {
    self.type_display.as_ref()
  }

  pub fn reset_type_display(&mut self) {
    self.type_display = None;
  }

  pub fn set_uploaded_at(&mut self, uploaded_at: String) {
    self.uploaded_at = Some(uploaded_at);
  }

  pub fn with_uploaded_at(mut self, uploaded_at: String) -> Package {
    self.uploaded_at = Some(uploaded_at);
    self
  }

  pub fn uploaded_at(&self) -> Option<&String> {
    self.uploaded_at.as_ref()
  }

  pub fn reset_uploaded_at(&mut self) {
    self.uploaded_at = None;
  }

  pub fn set_uploader(&mut self, uploader: String) {
    self.uploader = Some(uploader);
  }

  pub fn with_uploader(mut self, uploader: String) -> Package {
    self.uploader = Some(uploader);
    self
  }

  pub fn uploader(&self) -> Option<&String> {
    self.uploader.as_ref()
  }

  pub fn reset_uploader(&mut self) {
    self.uploader = None;
  }

  pub fn set_uploader_url(&mut self, uploader_url: String) {
    self.uploader_url = Some(uploader_url);
  }

  pub fn with_uploader_url(mut self, uploader_url: String) -> Package {
    self.uploader_url = Some(uploader_url);
    self
  }

  pub fn uploader_url(&self) -> Option<&String> {
    self.uploader_url.as_ref()
  }

  pub fn reset_uploader_url(&mut self) {
    self.uploader_url = None;
  }

  pub fn set_version(&mut self, version: String) {
    self.version = Some(version);
  }

  pub fn with_version(mut self, version: String) -> Package {
    self.version = Some(version);
    self
  }

  pub fn version(&self) -> Option<&String> {
    self.version.as_ref()
  }

  pub fn reset_version(&mut self) {
    self.version = None;
  }

  pub fn set_version_orig(&mut self, version_orig: String) {
    self.version_orig = Some(version_orig);
  }

  pub fn with_version_orig(mut self, version_orig: String) -> Package {
    self.version_orig = Some(version_orig);
    self
  }

  pub fn version_orig(&self) -> Option<&String> {
    self.version_orig.as_ref()
  }

  pub fn reset_version_orig(&mut self) {
    self.version_orig = None;
  }

  pub fn set_vulnerability_scan_results_url(&mut self, vulnerability_scan_results_url: String) {
    self.vulnerability_scan_results_url = Some(vulnerability_scan_results_url);
  }

  pub fn with_vulnerability_scan_results_url(mut self, vulnerability_scan_results_url: String) -> Package {
    self.vulnerability_scan_results_url = Some(vulnerability_scan_results_url);
    self
  }

  pub fn vulnerability_scan_results_url(&self) -> Option<&String> {
    self.vulnerability_scan_results_url.as_ref()
  }

  pub fn reset_vulnerability_scan_results_url(&mut self) {
    self.vulnerability_scan_results_url = None;
  }

}



