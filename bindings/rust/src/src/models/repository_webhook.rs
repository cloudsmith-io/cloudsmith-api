/* 
 * Cloudsmith API (v1)
 *
 * The API to the Cloudsmith Service
 *
 * OpenAPI spec version: v1
 * Contact: support@cloudsmith.io
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct RepositoryWebhook {
  #[serde(rename = "created_at")]
  created_at: Option<String>,
  #[serde(rename = "created_by")]
  created_by: Option<String>,
  #[serde(rename = "created_by_url")]
  created_by_url: Option<String>,
  #[serde(rename = "disable_reason")]
  disable_reason: Option<i32>,
  #[serde(rename = "disable_reason_str")]
  disable_reason_str: Option<String>,
  #[serde(rename = "events")]
  events: Vec<String>,
  /// Deprecated (23-05-15): Please use 'slug_perm' instead. Previously: A monotonically increasing number that identified a webhook request within a repository.
  #[serde(rename = "identifier")]
  identifier: Option<i32>,
  /// If enabled, the webhook will trigger on subscribed events and send payloads to the configured target URL.
  #[serde(rename = "is_active")]
  is_active: Option<bool>,
  #[serde(rename = "is_last_response_bad")]
  is_last_response_bad: Option<bool>,
  #[serde(rename = "last_response_status")]
  last_response_status: Option<i32>,
  #[serde(rename = "last_response_status_str")]
  last_response_status_str: Option<String>,
  #[serde(rename = "num_sent")]
  num_sent: Option<i32>,
  /// The package-based search query for webhooks to fire. This uses the same syntax as the standard search used for repositories, and also supports boolean logic operators such as OR/AND/NOT and parentheses for grouping. If a package does not match, the webhook will not fire.
  #[serde(rename = "package_query")]
  package_query: Option<String>,
  /// The format of the payloads for webhook requests. Valid options are: (0) JSON, (1) JSON array, (2) form encoded JSON and (3) Handlebars template.
  #[serde(rename = "request_body_format")]
  request_body_format: Option<i32>,
  #[serde(rename = "request_body_format_str")]
  request_body_format_str: Option<String>,
  /// The format of the payloads for webhook requests. Valid options are: (0) Generic/user defined, (1) JSON and (2) XML.
  #[serde(rename = "request_body_template_format")]
  request_body_template_format: Option<i32>,
  #[serde(rename = "request_body_template_format_str")]
  request_body_template_format_str: Option<String>,
  /// The value that will be sent for the 'Content Type' header. 
  #[serde(rename = "request_content_type")]
  request_content_type: Option<String>,
  /// The header to send the predefined secret in. This must be unique from existing headers or it won't be sent. You can use this as a form of authentication on the endpoint side.
  #[serde(rename = "secret_header")]
  secret_header: Option<String>,
  #[serde(rename = "self_url")]
  self_url: Option<String>,
  #[serde(rename = "slug_perm")]
  slug_perm: Option<String>,
  /// The destination URL that webhook payloads will be POST'ed to.
  #[serde(rename = "target_url")]
  target_url: String,
  #[serde(rename = "templates")]
  templates: Vec<::models::WebhookTemplate>,
  #[serde(rename = "updated_at")]
  updated_at: Option<String>,
  #[serde(rename = "updated_by")]
  updated_by: Option<String>,
  #[serde(rename = "updated_by_url")]
  updated_by_url: Option<String>,
  /// If enabled, SSL certificates is verified when webhooks are sent. It's recommended to leave this enabled as not verifying the integrity of SSL certificates leaves you susceptible to Man-in-the-Middle (MITM) attacks.
  #[serde(rename = "verify_ssl")]
  verify_ssl: Option<bool>
}

impl RepositoryWebhook {
  pub fn new(events: Vec<String>, target_url: String, templates: Vec<::models::WebhookTemplate>) -> RepositoryWebhook {
    RepositoryWebhook {
      created_at: None,
      created_by: None,
      created_by_url: None,
      disable_reason: None,
      disable_reason_str: None,
      events: events,
      identifier: None,
      is_active: None,
      is_last_response_bad: None,
      last_response_status: None,
      last_response_status_str: None,
      num_sent: None,
      package_query: None,
      request_body_format: None,
      request_body_format_str: None,
      request_body_template_format: None,
      request_body_template_format_str: None,
      request_content_type: None,
      secret_header: None,
      self_url: None,
      slug_perm: None,
      target_url: target_url,
      templates: templates,
      updated_at: None,
      updated_by: None,
      updated_by_url: None,
      verify_ssl: None
    }
  }

  pub fn set_created_at(&mut self, created_at: String) {
    self.created_at = Some(created_at);
  }

  pub fn with_created_at(mut self, created_at: String) -> RepositoryWebhook {
    self.created_at = Some(created_at);
    self
  }

  pub fn created_at(&self) -> Option<&String> {
    self.created_at.as_ref()
  }

  pub fn reset_created_at(&mut self) {
    self.created_at = None;
  }

  pub fn set_created_by(&mut self, created_by: String) {
    self.created_by = Some(created_by);
  }

  pub fn with_created_by(mut self, created_by: String) -> RepositoryWebhook {
    self.created_by = Some(created_by);
    self
  }

  pub fn created_by(&self) -> Option<&String> {
    self.created_by.as_ref()
  }

  pub fn reset_created_by(&mut self) {
    self.created_by = None;
  }

  pub fn set_created_by_url(&mut self, created_by_url: String) {
    self.created_by_url = Some(created_by_url);
  }

  pub fn with_created_by_url(mut self, created_by_url: String) -> RepositoryWebhook {
    self.created_by_url = Some(created_by_url);
    self
  }

  pub fn created_by_url(&self) -> Option<&String> {
    self.created_by_url.as_ref()
  }

  pub fn reset_created_by_url(&mut self) {
    self.created_by_url = None;
  }

  pub fn set_disable_reason(&mut self, disable_reason: i32) {
    self.disable_reason = Some(disable_reason);
  }

  pub fn with_disable_reason(mut self, disable_reason: i32) -> RepositoryWebhook {
    self.disable_reason = Some(disable_reason);
    self
  }

  pub fn disable_reason(&self) -> Option<&i32> {
    self.disable_reason.as_ref()
  }

  pub fn reset_disable_reason(&mut self) {
    self.disable_reason = None;
  }

  pub fn set_disable_reason_str(&mut self, disable_reason_str: String) {
    self.disable_reason_str = Some(disable_reason_str);
  }

  pub fn with_disable_reason_str(mut self, disable_reason_str: String) -> RepositoryWebhook {
    self.disable_reason_str = Some(disable_reason_str);
    self
  }

  pub fn disable_reason_str(&self) -> Option<&String> {
    self.disable_reason_str.as_ref()
  }

  pub fn reset_disable_reason_str(&mut self) {
    self.disable_reason_str = None;
  }

  pub fn set_events(&mut self, events: Vec<String>) {
    self.events = events;
  }

  pub fn with_events(mut self, events: Vec<String>) -> RepositoryWebhook {
    self.events = events;
    self
  }

  pub fn events(&self) -> &Vec<String> {
    &self.events
  }


  pub fn set_identifier(&mut self, identifier: i32) {
    self.identifier = Some(identifier);
  }

  pub fn with_identifier(mut self, identifier: i32) -> RepositoryWebhook {
    self.identifier = Some(identifier);
    self
  }

  pub fn identifier(&self) -> Option<&i32> {
    self.identifier.as_ref()
  }

  pub fn reset_identifier(&mut self) {
    self.identifier = None;
  }

  pub fn set_is_active(&mut self, is_active: bool) {
    self.is_active = Some(is_active);
  }

  pub fn with_is_active(mut self, is_active: bool) -> RepositoryWebhook {
    self.is_active = Some(is_active);
    self
  }

  pub fn is_active(&self) -> Option<&bool> {
    self.is_active.as_ref()
  }

  pub fn reset_is_active(&mut self) {
    self.is_active = None;
  }

  pub fn set_is_last_response_bad(&mut self, is_last_response_bad: bool) {
    self.is_last_response_bad = Some(is_last_response_bad);
  }

  pub fn with_is_last_response_bad(mut self, is_last_response_bad: bool) -> RepositoryWebhook {
    self.is_last_response_bad = Some(is_last_response_bad);
    self
  }

  pub fn is_last_response_bad(&self) -> Option<&bool> {
    self.is_last_response_bad.as_ref()
  }

  pub fn reset_is_last_response_bad(&mut self) {
    self.is_last_response_bad = None;
  }

  pub fn set_last_response_status(&mut self, last_response_status: i32) {
    self.last_response_status = Some(last_response_status);
  }

  pub fn with_last_response_status(mut self, last_response_status: i32) -> RepositoryWebhook {
    self.last_response_status = Some(last_response_status);
    self
  }

  pub fn last_response_status(&self) -> Option<&i32> {
    self.last_response_status.as_ref()
  }

  pub fn reset_last_response_status(&mut self) {
    self.last_response_status = None;
  }

  pub fn set_last_response_status_str(&mut self, last_response_status_str: String) {
    self.last_response_status_str = Some(last_response_status_str);
  }

  pub fn with_last_response_status_str(mut self, last_response_status_str: String) -> RepositoryWebhook {
    self.last_response_status_str = Some(last_response_status_str);
    self
  }

  pub fn last_response_status_str(&self) -> Option<&String> {
    self.last_response_status_str.as_ref()
  }

  pub fn reset_last_response_status_str(&mut self) {
    self.last_response_status_str = None;
  }

  pub fn set_num_sent(&mut self, num_sent: i32) {
    self.num_sent = Some(num_sent);
  }

  pub fn with_num_sent(mut self, num_sent: i32) -> RepositoryWebhook {
    self.num_sent = Some(num_sent);
    self
  }

  pub fn num_sent(&self) -> Option<&i32> {
    self.num_sent.as_ref()
  }

  pub fn reset_num_sent(&mut self) {
    self.num_sent = None;
  }

  pub fn set_package_query(&mut self, package_query: String) {
    self.package_query = Some(package_query);
  }

  pub fn with_package_query(mut self, package_query: String) -> RepositoryWebhook {
    self.package_query = Some(package_query);
    self
  }

  pub fn package_query(&self) -> Option<&String> {
    self.package_query.as_ref()
  }

  pub fn reset_package_query(&mut self) {
    self.package_query = None;
  }

  pub fn set_request_body_format(&mut self, request_body_format: i32) {
    self.request_body_format = Some(request_body_format);
  }

  pub fn with_request_body_format(mut self, request_body_format: i32) -> RepositoryWebhook {
    self.request_body_format = Some(request_body_format);
    self
  }

  pub fn request_body_format(&self) -> Option<&i32> {
    self.request_body_format.as_ref()
  }

  pub fn reset_request_body_format(&mut self) {
    self.request_body_format = None;
  }

  pub fn set_request_body_format_str(&mut self, request_body_format_str: String) {
    self.request_body_format_str = Some(request_body_format_str);
  }

  pub fn with_request_body_format_str(mut self, request_body_format_str: String) -> RepositoryWebhook {
    self.request_body_format_str = Some(request_body_format_str);
    self
  }

  pub fn request_body_format_str(&self) -> Option<&String> {
    self.request_body_format_str.as_ref()
  }

  pub fn reset_request_body_format_str(&mut self) {
    self.request_body_format_str = None;
  }

  pub fn set_request_body_template_format(&mut self, request_body_template_format: i32) {
    self.request_body_template_format = Some(request_body_template_format);
  }

  pub fn with_request_body_template_format(mut self, request_body_template_format: i32) -> RepositoryWebhook {
    self.request_body_template_format = Some(request_body_template_format);
    self
  }

  pub fn request_body_template_format(&self) -> Option<&i32> {
    self.request_body_template_format.as_ref()
  }

  pub fn reset_request_body_template_format(&mut self) {
    self.request_body_template_format = None;
  }

  pub fn set_request_body_template_format_str(&mut self, request_body_template_format_str: String) {
    self.request_body_template_format_str = Some(request_body_template_format_str);
  }

  pub fn with_request_body_template_format_str(mut self, request_body_template_format_str: String) -> RepositoryWebhook {
    self.request_body_template_format_str = Some(request_body_template_format_str);
    self
  }

  pub fn request_body_template_format_str(&self) -> Option<&String> {
    self.request_body_template_format_str.as_ref()
  }

  pub fn reset_request_body_template_format_str(&mut self) {
    self.request_body_template_format_str = None;
  }

  pub fn set_request_content_type(&mut self, request_content_type: String) {
    self.request_content_type = Some(request_content_type);
  }

  pub fn with_request_content_type(mut self, request_content_type: String) -> RepositoryWebhook {
    self.request_content_type = Some(request_content_type);
    self
  }

  pub fn request_content_type(&self) -> Option<&String> {
    self.request_content_type.as_ref()
  }

  pub fn reset_request_content_type(&mut self) {
    self.request_content_type = None;
  }

  pub fn set_secret_header(&mut self, secret_header: String) {
    self.secret_header = Some(secret_header);
  }

  pub fn with_secret_header(mut self, secret_header: String) -> RepositoryWebhook {
    self.secret_header = Some(secret_header);
    self
  }

  pub fn secret_header(&self) -> Option<&String> {
    self.secret_header.as_ref()
  }

  pub fn reset_secret_header(&mut self) {
    self.secret_header = None;
  }

  pub fn set_self_url(&mut self, self_url: String) {
    self.self_url = Some(self_url);
  }

  pub fn with_self_url(mut self, self_url: String) -> RepositoryWebhook {
    self.self_url = Some(self_url);
    self
  }

  pub fn self_url(&self) -> Option<&String> {
    self.self_url.as_ref()
  }

  pub fn reset_self_url(&mut self) {
    self.self_url = None;
  }

  pub fn set_slug_perm(&mut self, slug_perm: String) {
    self.slug_perm = Some(slug_perm);
  }

  pub fn with_slug_perm(mut self, slug_perm: String) -> RepositoryWebhook {
    self.slug_perm = Some(slug_perm);
    self
  }

  pub fn slug_perm(&self) -> Option<&String> {
    self.slug_perm.as_ref()
  }

  pub fn reset_slug_perm(&mut self) {
    self.slug_perm = None;
  }

  pub fn set_target_url(&mut self, target_url: String) {
    self.target_url = target_url;
  }

  pub fn with_target_url(mut self, target_url: String) -> RepositoryWebhook {
    self.target_url = target_url;
    self
  }

  pub fn target_url(&self) -> &String {
    &self.target_url
  }


  pub fn set_templates(&mut self, templates: Vec<::models::WebhookTemplate>) {
    self.templates = templates;
  }

  pub fn with_templates(mut self, templates: Vec<::models::WebhookTemplate>) -> RepositoryWebhook {
    self.templates = templates;
    self
  }

  pub fn templates(&self) -> &Vec<::models::WebhookTemplate> {
    &self.templates
  }


  pub fn set_updated_at(&mut self, updated_at: String) {
    self.updated_at = Some(updated_at);
  }

  pub fn with_updated_at(mut self, updated_at: String) -> RepositoryWebhook {
    self.updated_at = Some(updated_at);
    self
  }

  pub fn updated_at(&self) -> Option<&String> {
    self.updated_at.as_ref()
  }

  pub fn reset_updated_at(&mut self) {
    self.updated_at = None;
  }

  pub fn set_updated_by(&mut self, updated_by: String) {
    self.updated_by = Some(updated_by);
  }

  pub fn with_updated_by(mut self, updated_by: String) -> RepositoryWebhook {
    self.updated_by = Some(updated_by);
    self
  }

  pub fn updated_by(&self) -> Option<&String> {
    self.updated_by.as_ref()
  }

  pub fn reset_updated_by(&mut self) {
    self.updated_by = None;
  }

  pub fn set_updated_by_url(&mut self, updated_by_url: String) {
    self.updated_by_url = Some(updated_by_url);
  }

  pub fn with_updated_by_url(mut self, updated_by_url: String) -> RepositoryWebhook {
    self.updated_by_url = Some(updated_by_url);
    self
  }

  pub fn updated_by_url(&self) -> Option<&String> {
    self.updated_by_url.as_ref()
  }

  pub fn reset_updated_by_url(&mut self) {
    self.updated_by_url = None;
  }

  pub fn set_verify_ssl(&mut self, verify_ssl: bool) {
    self.verify_ssl = Some(verify_ssl);
  }

  pub fn with_verify_ssl(mut self, verify_ssl: bool) -> RepositoryWebhook {
    self.verify_ssl = Some(verify_ssl);
    self
  }

  pub fn verify_ssl(&self) -> Option<&bool> {
    self.verify_ssl.as_ref()
  }

  pub fn reset_verify_ssl(&mut self) {
    self.verify_ssl = None;
  }

}



