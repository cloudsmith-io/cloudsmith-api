/* 
 * Cloudsmith API (v1)
 *
 * The API to the Cloudsmith Service
 *
 * OpenAPI spec version: v1
 * Contact: support@cloudsmith.io
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct RepositoryWebhookRequestPatch {
  #[serde(rename = "events")]
  events: Option<Vec<String>>,
  /// If enabled, the webhook will trigger on subscribed events and send payloads to the configured target URL.
  #[serde(rename = "is_active")]
  is_active: Option<bool>,
  /// The package-based search query for webhooks to fire. This uses the same syntax as the standard search used for repositories, and also supports boolean logic operators such as OR/AND/NOT and parentheses for grouping. If a package does not match, the webhook will not fire.
  #[serde(rename = "package_query")]
  package_query: Option<String>,
  /// The format of the payloads for webhook requests. Valid options are: (0) JSON, (1) JSON array, (2) form encoded JSON and (3) Handlebars template.
  #[serde(rename = "request_body_format")]
  request_body_format: Option<i32>,
  /// The format of the payloads for webhook requests. Valid options are: (0) Generic/user defined, (1) JSON and (2) XML.
  #[serde(rename = "request_body_template_format")]
  request_body_template_format: Option<i32>,
  /// The value that will be sent for the 'Content Type' header. 
  #[serde(rename = "request_content_type")]
  request_content_type: Option<String>,
  /// The header to send the predefined secret in. This must be unique from existing headers or it won't be sent. You can use this as a form of authentication on the endpoint side.
  #[serde(rename = "secret_header")]
  secret_header: Option<String>,
  /// The value for the predefined secret (note: this is treated as a passphrase and is encrypted when we store it). You can use this as a form of authentication on the endpoint side.
  #[serde(rename = "secret_value")]
  secret_value: Option<String>,
  /// The value for the signature key - This is used to generate an HMAC-based hex digest of the request body, which we send as the X-Cloudsmith-Signature header so that you can ensure that the request wasn't modified by a malicious party (note: this is treated as a passphrase and is encrypted when we store it).
  #[serde(rename = "signature_key")]
  signature_key: Option<String>,
  /// The destination URL that webhook payloads will be POST'ed to.
  #[serde(rename = "target_url")]
  target_url: Option<String>,
  #[serde(rename = "templates")]
  templates: Option<Vec<::models::WebhookTemplate>>,
  /// If enabled, SSL certificates is verified when webhooks are sent. It's recommended to leave this enabled as not verifying the integrity of SSL certificates leaves you susceptible to Man-in-the-Middle (MITM) attacks.
  #[serde(rename = "verify_ssl")]
  verify_ssl: Option<bool>
}

impl RepositoryWebhookRequestPatch {
  pub fn new() -> RepositoryWebhookRequestPatch {
    RepositoryWebhookRequestPatch {
      events: None,
      is_active: None,
      package_query: None,
      request_body_format: None,
      request_body_template_format: None,
      request_content_type: None,
      secret_header: None,
      secret_value: None,
      signature_key: None,
      target_url: None,
      templates: None,
      verify_ssl: None
    }
  }

  pub fn set_events(&mut self, events: Vec<String>) {
    self.events = Some(events);
  }

  pub fn with_events(mut self, events: Vec<String>) -> RepositoryWebhookRequestPatch {
    self.events = Some(events);
    self
  }

  pub fn events(&self) -> Option<&Vec<String>> {
    self.events.as_ref()
  }

  pub fn reset_events(&mut self) {
    self.events = None;
  }

  pub fn set_is_active(&mut self, is_active: bool) {
    self.is_active = Some(is_active);
  }

  pub fn with_is_active(mut self, is_active: bool) -> RepositoryWebhookRequestPatch {
    self.is_active = Some(is_active);
    self
  }

  pub fn is_active(&self) -> Option<&bool> {
    self.is_active.as_ref()
  }

  pub fn reset_is_active(&mut self) {
    self.is_active = None;
  }

  pub fn set_package_query(&mut self, package_query: String) {
    self.package_query = Some(package_query);
  }

  pub fn with_package_query(mut self, package_query: String) -> RepositoryWebhookRequestPatch {
    self.package_query = Some(package_query);
    self
  }

  pub fn package_query(&self) -> Option<&String> {
    self.package_query.as_ref()
  }

  pub fn reset_package_query(&mut self) {
    self.package_query = None;
  }

  pub fn set_request_body_format(&mut self, request_body_format: i32) {
    self.request_body_format = Some(request_body_format);
  }

  pub fn with_request_body_format(mut self, request_body_format: i32) -> RepositoryWebhookRequestPatch {
    self.request_body_format = Some(request_body_format);
    self
  }

  pub fn request_body_format(&self) -> Option<&i32> {
    self.request_body_format.as_ref()
  }

  pub fn reset_request_body_format(&mut self) {
    self.request_body_format = None;
  }

  pub fn set_request_body_template_format(&mut self, request_body_template_format: i32) {
    self.request_body_template_format = Some(request_body_template_format);
  }

  pub fn with_request_body_template_format(mut self, request_body_template_format: i32) -> RepositoryWebhookRequestPatch {
    self.request_body_template_format = Some(request_body_template_format);
    self
  }

  pub fn request_body_template_format(&self) -> Option<&i32> {
    self.request_body_template_format.as_ref()
  }

  pub fn reset_request_body_template_format(&mut self) {
    self.request_body_template_format = None;
  }

  pub fn set_request_content_type(&mut self, request_content_type: String) {
    self.request_content_type = Some(request_content_type);
  }

  pub fn with_request_content_type(mut self, request_content_type: String) -> RepositoryWebhookRequestPatch {
    self.request_content_type = Some(request_content_type);
    self
  }

  pub fn request_content_type(&self) -> Option<&String> {
    self.request_content_type.as_ref()
  }

  pub fn reset_request_content_type(&mut self) {
    self.request_content_type = None;
  }

  pub fn set_secret_header(&mut self, secret_header: String) {
    self.secret_header = Some(secret_header);
  }

  pub fn with_secret_header(mut self, secret_header: String) -> RepositoryWebhookRequestPatch {
    self.secret_header = Some(secret_header);
    self
  }

  pub fn secret_header(&self) -> Option<&String> {
    self.secret_header.as_ref()
  }

  pub fn reset_secret_header(&mut self) {
    self.secret_header = None;
  }

  pub fn set_secret_value(&mut self, secret_value: String) {
    self.secret_value = Some(secret_value);
  }

  pub fn with_secret_value(mut self, secret_value: String) -> RepositoryWebhookRequestPatch {
    self.secret_value = Some(secret_value);
    self
  }

  pub fn secret_value(&self) -> Option<&String> {
    self.secret_value.as_ref()
  }

  pub fn reset_secret_value(&mut self) {
    self.secret_value = None;
  }

  pub fn set_signature_key(&mut self, signature_key: String) {
    self.signature_key = Some(signature_key);
  }

  pub fn with_signature_key(mut self, signature_key: String) -> RepositoryWebhookRequestPatch {
    self.signature_key = Some(signature_key);
    self
  }

  pub fn signature_key(&self) -> Option<&String> {
    self.signature_key.as_ref()
  }

  pub fn reset_signature_key(&mut self) {
    self.signature_key = None;
  }

  pub fn set_target_url(&mut self, target_url: String) {
    self.target_url = Some(target_url);
  }

  pub fn with_target_url(mut self, target_url: String) -> RepositoryWebhookRequestPatch {
    self.target_url = Some(target_url);
    self
  }

  pub fn target_url(&self) -> Option<&String> {
    self.target_url.as_ref()
  }

  pub fn reset_target_url(&mut self) {
    self.target_url = None;
  }

  pub fn set_templates(&mut self, templates: Vec<::models::WebhookTemplate>) {
    self.templates = Some(templates);
  }

  pub fn with_templates(mut self, templates: Vec<::models::WebhookTemplate>) -> RepositoryWebhookRequestPatch {
    self.templates = Some(templates);
    self
  }

  pub fn templates(&self) -> Option<&Vec<::models::WebhookTemplate>> {
    self.templates.as_ref()
  }

  pub fn reset_templates(&mut self) {
    self.templates = None;
  }

  pub fn set_verify_ssl(&mut self, verify_ssl: bool) {
    self.verify_ssl = Some(verify_ssl);
  }

  pub fn with_verify_ssl(mut self, verify_ssl: bool) -> RepositoryWebhookRequestPatch {
    self.verify_ssl = Some(verify_ssl);
    self
  }

  pub fn verify_ssl(&self) -> Option<&bool> {
    self.verify_ssl.as_ref()
  }

  pub fn reset_verify_ssl(&mut self) {
    self.verify_ssl = None;
  }

}



