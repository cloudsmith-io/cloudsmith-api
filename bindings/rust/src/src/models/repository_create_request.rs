/* 
 * Cloudsmith API (v1)
 *
 * The API to the Cloudsmith Service
 *
 * OpenAPI spec version: v1
 * Contact: support@cloudsmith.io
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct RepositoryCreateRequest {
  /// The repository content kind determines whether this repository contains packages, or provides a distribution of packages from other repositories. You can only select the content kind at repository creation time.
  #[serde(rename = "content_kind")]
  content_kind: Option<String>,
  /// If checked, missing credentials for this repository where basic authentication is required shall present an enriched value in the 'WWW-Authenticate' header containing the namespace and repository. This can be useful for tooling such as SBT where the authentication realm is used to distinguish and disambiguate credentials.
  #[serde(rename = "contextual_auth_realm")]
  contextual_auth_realm: Option<bool>,
  /// If checked, users can copy any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the 'Access Controls' section of the repository, and any inherited from the org.
  #[serde(rename = "copy_own")]
  copy_own: Option<bool>,
  /// This defines the minimum level of privilege required for a user to copy packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific copy setting.
  #[serde(rename = "copy_packages")]
  copy_packages: Option<String>,
  /// This defines the default level of privilege that all of your organization members have for this repository. This does not include collaborators, but applies to any member of the org regardless of their own membership role (i.e. it applies to owners, managers and members). Be careful if setting this to admin, because any member will be able to change settings.
  #[serde(rename = "default_privilege")]
  default_privilege: Option<String>,
  /// If checked, users can delete any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the 'Access Controls' section of the repository, and any inherited from the org.
  #[serde(rename = "delete_own")]
  delete_own: Option<bool>,
  /// This defines the minimum level of privilege required for a user to delete packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific delete setting.
  #[serde(rename = "delete_packages")]
  delete_packages: Option<String>,
  /// A description of the repository's purpose/contents.
  #[serde(rename = "description")]
  description: Option<String>,
  /// The repositories distributed through this repo. Adding repos here is only valid if the content_kind is DISTRIBUTION.
  #[serde(rename = "distributes")]
  distributes: Option<Vec<String>>,
  /// If checked, refresh tokens will be issued in addition to access tokens for Docker authentication. This allows unlimited extension of the lifetime of access tokens.
  #[serde(rename = "docker_refresh_tokens_enabled")]
  docker_refresh_tokens_enabled: Option<bool>,
  /// If checked, downloads will explicitly require acceptance of an EULA.
  #[serde(rename = "enforce_eula")]
  enforce_eula: Option<bool>,
  /// If checked, files contained in packages will be indexed, which increase the synchronisation time required for packages. Note that it is recommended you keep this enabled unless the synchronisation time is significantly impacted.
  #[serde(rename = "index_files")]
  index_files: Option<bool>,
  /// This defines the minimum level of privilege required for a user to manage entitlement tokens with private repositories. Management is the ability to create, alter, enable, disable or delete all tokens without a repository.
  #[serde(rename = "manage_entitlements_privilege")]
  manage_entitlements_privilege: Option<String>,
  /// If checked, users can move any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the 'Access Controls' section of the repository, and any inherited from the org.
  #[serde(rename = "move_own")]
  move_own: Option<bool>,
  /// This defines the minimum level of privilege required for a user to move packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific move setting.
  #[serde(rename = "move_packages")]
  move_packages: Option<String>,
  /// A descriptive name for the repository.
  #[serde(rename = "name")]
  name: String,
  /// When enabled, all pushed (or pulled from upstream) nuget packages and artifacts will be signed using the repository's X.509 RSA certificate. Additionally, the nuget RepositorySignature index will list all of the repository's signing certificates including the ones from configured upstreams.
  #[serde(rename = "nuget_native_signing_enabled")]
  nuget_native_signing_enabled: Option<bool>,
  /// The SPDX identifier of the open source license.
  #[serde(rename = "open_source_license")]
  open_source_license: Option<String>,
  /// The URL to the Open-Source project, used for validating that the project meets the requirements for Open-Source.
  #[serde(rename = "open_source_project_url")]
  open_source_project_url: Option<String>,
  /// If checked, Npm packages that are not in the repository when requested by clients will automatically be proxied from the public npmjs.org registry. If there is at least one version for a package, others will not be proxied.
  #[serde(rename = "proxy_npmjs")]
  proxy_npmjs: Option<bool>,
  /// If checked, Python packages that are not in the repository when requested by clients will automatically be proxied from the public pypi.python.org registry. If there is at least one version for a package, others will not be proxied.
  #[serde(rename = "proxy_pypi")]
  proxy_pypi: Option<bool>,
  /// If checked, HTML and JSON indexes will be generated that list all available raw packages in the repository.
  #[serde(rename = "raw_package_index_enabled")]
  raw_package_index_enabled: Option<bool>,
  /// If checked, the HTML and JSON indexes will display raw package GPG signatures alongside the index packages.
  #[serde(rename = "raw_package_index_signatures_enabled")]
  raw_package_index_signatures_enabled: Option<bool>,
  /// This defines the minimum level of privilege required for a user to republish packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific republish setting. Please note that the user still requires the privilege to delete packages that will be replaced by the new package; otherwise the republish will fail.
  #[serde(rename = "replace_packages")]
  replace_packages: Option<String>,
  /// If checked, uploaded packages will overwrite/replace any others with the same attributes (e.g. same version) by default. This only applies if the user has the required privilege for the republishing AND has the required privilege to delete existing packages that they don't own.
  #[serde(rename = "replace_packages_by_default")]
  replace_packages_by_default: Option<bool>,
  /// The repository type changes how it is accessed and billed. Private repositories are visible only to you or authorized delegates. Public repositories are visible to all Cloudsmith users.
  #[serde(rename = "repository_type_str")]
  repository_type_str: Option<String>,
  /// If checked, users can resync any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the 'Access Controls' section of the repository, and any inherited from the org.
  #[serde(rename = "resync_own")]
  resync_own: Option<bool>,
  /// This defines the minimum level of privilege required for a user to resync packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific resync setting.
  #[serde(rename = "resync_packages")]
  resync_packages: Option<String>,
  /// If checked, users can scan any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the 'Access Controls' section of the repository, and any inherited from the org.
  #[serde(rename = "scan_own")]
  scan_own: Option<bool>,
  /// This defines the minimum level of privilege required for a user to scan packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific scan setting.
  #[serde(rename = "scan_packages")]
  scan_packages: Option<String>,
  /// If checked, the Set Me Up help for all formats will always be shown, even if you don't have packages of that type uploaded. Otherwise, help will only be shown for packages that are in the repository. For example, if you have uploaded only NuGet packages, then the Set Me Up help for NuGet packages will be shown only.
  #[serde(rename = "show_setup_all")]
  show_setup_all: Option<bool>,
  /// The slug identifies the repository in URIs.
  #[serde(rename = "slug")]
  slug: Option<String>,
  /// The Cloudsmith region in which package files are stored.
  #[serde(rename = "storage_region")]
  storage_region: Option<String>,
  /// If checked, npm packages will be validated strictly to ensure the package matches specifcation. You can turn this on if you want to guarantee that the packages will work with npm-cli and other tools correctly.
  #[serde(rename = "strict_npm_validation")]
  strict_npm_validation: Option<bool>,
  /// If checked, packages pushed with a pre-release component on that version will be marked with the 'latest' tag. Note that if unchecked, a repository containing ONLY pre-release versions, will have no version marked latest which may cause incompatibility with native tools 
  #[serde(rename = "tag_pre_releases_as_latest")]
  tag_pre_releases_as_latest: Option<bool>,
  /// If checked, a 'Label' field will be present in Debian-based repositories. It will contain a string that identifies the entitlement token used to authenticate the repository, in the form of 'source=t-<identifier>'; or 'source=none' if no token was used. You can use this to help with pinning.
  #[serde(rename = "use_debian_labels")]
  use_debian_labels: Option<bool>,
  /// If checked, dependencies of uploaded Cargo crates which do not set an explicit value for \"registry\" will be assumed to be available from crates.io. If unchecked, dependencies with unspecified \"registry\" values will be assumed to be available in the registry being uploaded to. Uncheck this if you want to ensure that dependencies are only ever installed from Cloudsmith unless explicitly specified as belong to another registry.
  #[serde(rename = "use_default_cargo_upstream")]
  use_default_cargo_upstream: Option<bool>,
  /// This defines the minimum level of privilege required for a user to see/use entitlement tokens with private repositories. If a user does not have the permission, they will only be able to download packages using other credentials, such as email/password via basic authentication. Use this if you want to force users to only use their user-based token, which is tied to their access (if removed, they can't use it).
  #[serde(rename = "use_entitlements_privilege")]
  use_entitlements_privilege: Option<String>,
  /// If checked, noarch packages (if supported) are enabled in installations/configurations. A noarch package is one that is not tied to specific system architecture (like i686).
  #[serde(rename = "use_noarch_packages")]
  use_noarch_packages: Option<bool>,
  /// If checked, source packages (if supported) are enabled in installations/configurations. A source package is one that contains source code rather than built binaries.
  #[serde(rename = "use_source_packages")]
  use_source_packages: Option<bool>,
  /// If checked, vulnerability scanning will be enabled for all supported packages within this repository.
  #[serde(rename = "use_vulnerability_scanning")]
  use_vulnerability_scanning: Option<bool>,
  /// If checked, users can use and manage their own user-specific entitlement token for the repository (if private). Otherwise, user-specific entitlements are disabled for all users.
  #[serde(rename = "user_entitlements_enabled")]
  user_entitlements_enabled: Option<bool>,
  /// This defines the minimum level of privilege required for a user to view repository statistics, to include entitlement-based usage, if applicable. If a user does not have the permission, they won't be able to view any statistics, either via the UI, API or CLI.
  #[serde(rename = "view_statistics")]
  view_statistics: Option<String>
}

impl RepositoryCreateRequest {
  pub fn new(name: String) -> RepositoryCreateRequest {
    RepositoryCreateRequest {
      content_kind: None,
      contextual_auth_realm: None,
      copy_own: None,
      copy_packages: None,
      default_privilege: None,
      delete_own: None,
      delete_packages: None,
      description: None,
      distributes: None,
      docker_refresh_tokens_enabled: None,
      enforce_eula: None,
      index_files: None,
      manage_entitlements_privilege: None,
      move_own: None,
      move_packages: None,
      name: name,
      nuget_native_signing_enabled: None,
      open_source_license: None,
      open_source_project_url: None,
      proxy_npmjs: None,
      proxy_pypi: None,
      raw_package_index_enabled: None,
      raw_package_index_signatures_enabled: None,
      replace_packages: None,
      replace_packages_by_default: None,
      repository_type_str: None,
      resync_own: None,
      resync_packages: None,
      scan_own: None,
      scan_packages: None,
      show_setup_all: None,
      slug: None,
      storage_region: None,
      strict_npm_validation: None,
      tag_pre_releases_as_latest: None,
      use_debian_labels: None,
      use_default_cargo_upstream: None,
      use_entitlements_privilege: None,
      use_noarch_packages: None,
      use_source_packages: None,
      use_vulnerability_scanning: None,
      user_entitlements_enabled: None,
      view_statistics: None
    }
  }

  pub fn set_content_kind(&mut self, content_kind: String) {
    self.content_kind = Some(content_kind);
  }

  pub fn with_content_kind(mut self, content_kind: String) -> RepositoryCreateRequest {
    self.content_kind = Some(content_kind);
    self
  }

  pub fn content_kind(&self) -> Option<&String> {
    self.content_kind.as_ref()
  }

  pub fn reset_content_kind(&mut self) {
    self.content_kind = None;
  }

  pub fn set_contextual_auth_realm(&mut self, contextual_auth_realm: bool) {
    self.contextual_auth_realm = Some(contextual_auth_realm);
  }

  pub fn with_contextual_auth_realm(mut self, contextual_auth_realm: bool) -> RepositoryCreateRequest {
    self.contextual_auth_realm = Some(contextual_auth_realm);
    self
  }

  pub fn contextual_auth_realm(&self) -> Option<&bool> {
    self.contextual_auth_realm.as_ref()
  }

  pub fn reset_contextual_auth_realm(&mut self) {
    self.contextual_auth_realm = None;
  }

  pub fn set_copy_own(&mut self, copy_own: bool) {
    self.copy_own = Some(copy_own);
  }

  pub fn with_copy_own(mut self, copy_own: bool) -> RepositoryCreateRequest {
    self.copy_own = Some(copy_own);
    self
  }

  pub fn copy_own(&self) -> Option<&bool> {
    self.copy_own.as_ref()
  }

  pub fn reset_copy_own(&mut self) {
    self.copy_own = None;
  }

  pub fn set_copy_packages(&mut self, copy_packages: String) {
    self.copy_packages = Some(copy_packages);
  }

  pub fn with_copy_packages(mut self, copy_packages: String) -> RepositoryCreateRequest {
    self.copy_packages = Some(copy_packages);
    self
  }

  pub fn copy_packages(&self) -> Option<&String> {
    self.copy_packages.as_ref()
  }

  pub fn reset_copy_packages(&mut self) {
    self.copy_packages = None;
  }

  pub fn set_default_privilege(&mut self, default_privilege: String) {
    self.default_privilege = Some(default_privilege);
  }

  pub fn with_default_privilege(mut self, default_privilege: String) -> RepositoryCreateRequest {
    self.default_privilege = Some(default_privilege);
    self
  }

  pub fn default_privilege(&self) -> Option<&String> {
    self.default_privilege.as_ref()
  }

  pub fn reset_default_privilege(&mut self) {
    self.default_privilege = None;
  }

  pub fn set_delete_own(&mut self, delete_own: bool) {
    self.delete_own = Some(delete_own);
  }

  pub fn with_delete_own(mut self, delete_own: bool) -> RepositoryCreateRequest {
    self.delete_own = Some(delete_own);
    self
  }

  pub fn delete_own(&self) -> Option<&bool> {
    self.delete_own.as_ref()
  }

  pub fn reset_delete_own(&mut self) {
    self.delete_own = None;
  }

  pub fn set_delete_packages(&mut self, delete_packages: String) {
    self.delete_packages = Some(delete_packages);
  }

  pub fn with_delete_packages(mut self, delete_packages: String) -> RepositoryCreateRequest {
    self.delete_packages = Some(delete_packages);
    self
  }

  pub fn delete_packages(&self) -> Option<&String> {
    self.delete_packages.as_ref()
  }

  pub fn reset_delete_packages(&mut self) {
    self.delete_packages = None;
  }

  pub fn set_description(&mut self, description: String) {
    self.description = Some(description);
  }

  pub fn with_description(mut self, description: String) -> RepositoryCreateRequest {
    self.description = Some(description);
    self
  }

  pub fn description(&self) -> Option<&String> {
    self.description.as_ref()
  }

  pub fn reset_description(&mut self) {
    self.description = None;
  }

  pub fn set_distributes(&mut self, distributes: Vec<String>) {
    self.distributes = Some(distributes);
  }

  pub fn with_distributes(mut self, distributes: Vec<String>) -> RepositoryCreateRequest {
    self.distributes = Some(distributes);
    self
  }

  pub fn distributes(&self) -> Option<&Vec<String>> {
    self.distributes.as_ref()
  }

  pub fn reset_distributes(&mut self) {
    self.distributes = None;
  }

  pub fn set_docker_refresh_tokens_enabled(&mut self, docker_refresh_tokens_enabled: bool) {
    self.docker_refresh_tokens_enabled = Some(docker_refresh_tokens_enabled);
  }

  pub fn with_docker_refresh_tokens_enabled(mut self, docker_refresh_tokens_enabled: bool) -> RepositoryCreateRequest {
    self.docker_refresh_tokens_enabled = Some(docker_refresh_tokens_enabled);
    self
  }

  pub fn docker_refresh_tokens_enabled(&self) -> Option<&bool> {
    self.docker_refresh_tokens_enabled.as_ref()
  }

  pub fn reset_docker_refresh_tokens_enabled(&mut self) {
    self.docker_refresh_tokens_enabled = None;
  }

  pub fn set_enforce_eula(&mut self, enforce_eula: bool) {
    self.enforce_eula = Some(enforce_eula);
  }

  pub fn with_enforce_eula(mut self, enforce_eula: bool) -> RepositoryCreateRequest {
    self.enforce_eula = Some(enforce_eula);
    self
  }

  pub fn enforce_eula(&self) -> Option<&bool> {
    self.enforce_eula.as_ref()
  }

  pub fn reset_enforce_eula(&mut self) {
    self.enforce_eula = None;
  }

  pub fn set_index_files(&mut self, index_files: bool) {
    self.index_files = Some(index_files);
  }

  pub fn with_index_files(mut self, index_files: bool) -> RepositoryCreateRequest {
    self.index_files = Some(index_files);
    self
  }

  pub fn index_files(&self) -> Option<&bool> {
    self.index_files.as_ref()
  }

  pub fn reset_index_files(&mut self) {
    self.index_files = None;
  }

  pub fn set_manage_entitlements_privilege(&mut self, manage_entitlements_privilege: String) {
    self.manage_entitlements_privilege = Some(manage_entitlements_privilege);
  }

  pub fn with_manage_entitlements_privilege(mut self, manage_entitlements_privilege: String) -> RepositoryCreateRequest {
    self.manage_entitlements_privilege = Some(manage_entitlements_privilege);
    self
  }

  pub fn manage_entitlements_privilege(&self) -> Option<&String> {
    self.manage_entitlements_privilege.as_ref()
  }

  pub fn reset_manage_entitlements_privilege(&mut self) {
    self.manage_entitlements_privilege = None;
  }

  pub fn set_move_own(&mut self, move_own: bool) {
    self.move_own = Some(move_own);
  }

  pub fn with_move_own(mut self, move_own: bool) -> RepositoryCreateRequest {
    self.move_own = Some(move_own);
    self
  }

  pub fn move_own(&self) -> Option<&bool> {
    self.move_own.as_ref()
  }

  pub fn reset_move_own(&mut self) {
    self.move_own = None;
  }

  pub fn set_move_packages(&mut self, move_packages: String) {
    self.move_packages = Some(move_packages);
  }

  pub fn with_move_packages(mut self, move_packages: String) -> RepositoryCreateRequest {
    self.move_packages = Some(move_packages);
    self
  }

  pub fn move_packages(&self) -> Option<&String> {
    self.move_packages.as_ref()
  }

  pub fn reset_move_packages(&mut self) {
    self.move_packages = None;
  }

  pub fn set_name(&mut self, name: String) {
    self.name = name;
  }

  pub fn with_name(mut self, name: String) -> RepositoryCreateRequest {
    self.name = name;
    self
  }

  pub fn name(&self) -> &String {
    &self.name
  }


  pub fn set_nuget_native_signing_enabled(&mut self, nuget_native_signing_enabled: bool) {
    self.nuget_native_signing_enabled = Some(nuget_native_signing_enabled);
  }

  pub fn with_nuget_native_signing_enabled(mut self, nuget_native_signing_enabled: bool) -> RepositoryCreateRequest {
    self.nuget_native_signing_enabled = Some(nuget_native_signing_enabled);
    self
  }

  pub fn nuget_native_signing_enabled(&self) -> Option<&bool> {
    self.nuget_native_signing_enabled.as_ref()
  }

  pub fn reset_nuget_native_signing_enabled(&mut self) {
    self.nuget_native_signing_enabled = None;
  }

  pub fn set_open_source_license(&mut self, open_source_license: String) {
    self.open_source_license = Some(open_source_license);
  }

  pub fn with_open_source_license(mut self, open_source_license: String) -> RepositoryCreateRequest {
    self.open_source_license = Some(open_source_license);
    self
  }

  pub fn open_source_license(&self) -> Option<&String> {
    self.open_source_license.as_ref()
  }

  pub fn reset_open_source_license(&mut self) {
    self.open_source_license = None;
  }

  pub fn set_open_source_project_url(&mut self, open_source_project_url: String) {
    self.open_source_project_url = Some(open_source_project_url);
  }

  pub fn with_open_source_project_url(mut self, open_source_project_url: String) -> RepositoryCreateRequest {
    self.open_source_project_url = Some(open_source_project_url);
    self
  }

  pub fn open_source_project_url(&self) -> Option<&String> {
    self.open_source_project_url.as_ref()
  }

  pub fn reset_open_source_project_url(&mut self) {
    self.open_source_project_url = None;
  }

  pub fn set_proxy_npmjs(&mut self, proxy_npmjs: bool) {
    self.proxy_npmjs = Some(proxy_npmjs);
  }

  pub fn with_proxy_npmjs(mut self, proxy_npmjs: bool) -> RepositoryCreateRequest {
    self.proxy_npmjs = Some(proxy_npmjs);
    self
  }

  pub fn proxy_npmjs(&self) -> Option<&bool> {
    self.proxy_npmjs.as_ref()
  }

  pub fn reset_proxy_npmjs(&mut self) {
    self.proxy_npmjs = None;
  }

  pub fn set_proxy_pypi(&mut self, proxy_pypi: bool) {
    self.proxy_pypi = Some(proxy_pypi);
  }

  pub fn with_proxy_pypi(mut self, proxy_pypi: bool) -> RepositoryCreateRequest {
    self.proxy_pypi = Some(proxy_pypi);
    self
  }

  pub fn proxy_pypi(&self) -> Option<&bool> {
    self.proxy_pypi.as_ref()
  }

  pub fn reset_proxy_pypi(&mut self) {
    self.proxy_pypi = None;
  }

  pub fn set_raw_package_index_enabled(&mut self, raw_package_index_enabled: bool) {
    self.raw_package_index_enabled = Some(raw_package_index_enabled);
  }

  pub fn with_raw_package_index_enabled(mut self, raw_package_index_enabled: bool) -> RepositoryCreateRequest {
    self.raw_package_index_enabled = Some(raw_package_index_enabled);
    self
  }

  pub fn raw_package_index_enabled(&self) -> Option<&bool> {
    self.raw_package_index_enabled.as_ref()
  }

  pub fn reset_raw_package_index_enabled(&mut self) {
    self.raw_package_index_enabled = None;
  }

  pub fn set_raw_package_index_signatures_enabled(&mut self, raw_package_index_signatures_enabled: bool) {
    self.raw_package_index_signatures_enabled = Some(raw_package_index_signatures_enabled);
  }

  pub fn with_raw_package_index_signatures_enabled(mut self, raw_package_index_signatures_enabled: bool) -> RepositoryCreateRequest {
    self.raw_package_index_signatures_enabled = Some(raw_package_index_signatures_enabled);
    self
  }

  pub fn raw_package_index_signatures_enabled(&self) -> Option<&bool> {
    self.raw_package_index_signatures_enabled.as_ref()
  }

  pub fn reset_raw_package_index_signatures_enabled(&mut self) {
    self.raw_package_index_signatures_enabled = None;
  }

  pub fn set_replace_packages(&mut self, replace_packages: String) {
    self.replace_packages = Some(replace_packages);
  }

  pub fn with_replace_packages(mut self, replace_packages: String) -> RepositoryCreateRequest {
    self.replace_packages = Some(replace_packages);
    self
  }

  pub fn replace_packages(&self) -> Option<&String> {
    self.replace_packages.as_ref()
  }

  pub fn reset_replace_packages(&mut self) {
    self.replace_packages = None;
  }

  pub fn set_replace_packages_by_default(&mut self, replace_packages_by_default: bool) {
    self.replace_packages_by_default = Some(replace_packages_by_default);
  }

  pub fn with_replace_packages_by_default(mut self, replace_packages_by_default: bool) -> RepositoryCreateRequest {
    self.replace_packages_by_default = Some(replace_packages_by_default);
    self
  }

  pub fn replace_packages_by_default(&self) -> Option<&bool> {
    self.replace_packages_by_default.as_ref()
  }

  pub fn reset_replace_packages_by_default(&mut self) {
    self.replace_packages_by_default = None;
  }

  pub fn set_repository_type_str(&mut self, repository_type_str: String) {
    self.repository_type_str = Some(repository_type_str);
  }

  pub fn with_repository_type_str(mut self, repository_type_str: String) -> RepositoryCreateRequest {
    self.repository_type_str = Some(repository_type_str);
    self
  }

  pub fn repository_type_str(&self) -> Option<&String> {
    self.repository_type_str.as_ref()
  }

  pub fn reset_repository_type_str(&mut self) {
    self.repository_type_str = None;
  }

  pub fn set_resync_own(&mut self, resync_own: bool) {
    self.resync_own = Some(resync_own);
  }

  pub fn with_resync_own(mut self, resync_own: bool) -> RepositoryCreateRequest {
    self.resync_own = Some(resync_own);
    self
  }

  pub fn resync_own(&self) -> Option<&bool> {
    self.resync_own.as_ref()
  }

  pub fn reset_resync_own(&mut self) {
    self.resync_own = None;
  }

  pub fn set_resync_packages(&mut self, resync_packages: String) {
    self.resync_packages = Some(resync_packages);
  }

  pub fn with_resync_packages(mut self, resync_packages: String) -> RepositoryCreateRequest {
    self.resync_packages = Some(resync_packages);
    self
  }

  pub fn resync_packages(&self) -> Option<&String> {
    self.resync_packages.as_ref()
  }

  pub fn reset_resync_packages(&mut self) {
    self.resync_packages = None;
  }

  pub fn set_scan_own(&mut self, scan_own: bool) {
    self.scan_own = Some(scan_own);
  }

  pub fn with_scan_own(mut self, scan_own: bool) -> RepositoryCreateRequest {
    self.scan_own = Some(scan_own);
    self
  }

  pub fn scan_own(&self) -> Option<&bool> {
    self.scan_own.as_ref()
  }

  pub fn reset_scan_own(&mut self) {
    self.scan_own = None;
  }

  pub fn set_scan_packages(&mut self, scan_packages: String) {
    self.scan_packages = Some(scan_packages);
  }

  pub fn with_scan_packages(mut self, scan_packages: String) -> RepositoryCreateRequest {
    self.scan_packages = Some(scan_packages);
    self
  }

  pub fn scan_packages(&self) -> Option<&String> {
    self.scan_packages.as_ref()
  }

  pub fn reset_scan_packages(&mut self) {
    self.scan_packages = None;
  }

  pub fn set_show_setup_all(&mut self, show_setup_all: bool) {
    self.show_setup_all = Some(show_setup_all);
  }

  pub fn with_show_setup_all(mut self, show_setup_all: bool) -> RepositoryCreateRequest {
    self.show_setup_all = Some(show_setup_all);
    self
  }

  pub fn show_setup_all(&self) -> Option<&bool> {
    self.show_setup_all.as_ref()
  }

  pub fn reset_show_setup_all(&mut self) {
    self.show_setup_all = None;
  }

  pub fn set_slug(&mut self, slug: String) {
    self.slug = Some(slug);
  }

  pub fn with_slug(mut self, slug: String) -> RepositoryCreateRequest {
    self.slug = Some(slug);
    self
  }

  pub fn slug(&self) -> Option<&String> {
    self.slug.as_ref()
  }

  pub fn reset_slug(&mut self) {
    self.slug = None;
  }

  pub fn set_storage_region(&mut self, storage_region: String) {
    self.storage_region = Some(storage_region);
  }

  pub fn with_storage_region(mut self, storage_region: String) -> RepositoryCreateRequest {
    self.storage_region = Some(storage_region);
    self
  }

  pub fn storage_region(&self) -> Option<&String> {
    self.storage_region.as_ref()
  }

  pub fn reset_storage_region(&mut self) {
    self.storage_region = None;
  }

  pub fn set_strict_npm_validation(&mut self, strict_npm_validation: bool) {
    self.strict_npm_validation = Some(strict_npm_validation);
  }

  pub fn with_strict_npm_validation(mut self, strict_npm_validation: bool) -> RepositoryCreateRequest {
    self.strict_npm_validation = Some(strict_npm_validation);
    self
  }

  pub fn strict_npm_validation(&self) -> Option<&bool> {
    self.strict_npm_validation.as_ref()
  }

  pub fn reset_strict_npm_validation(&mut self) {
    self.strict_npm_validation = None;
  }

  pub fn set_tag_pre_releases_as_latest(&mut self, tag_pre_releases_as_latest: bool) {
    self.tag_pre_releases_as_latest = Some(tag_pre_releases_as_latest);
  }

  pub fn with_tag_pre_releases_as_latest(mut self, tag_pre_releases_as_latest: bool) -> RepositoryCreateRequest {
    self.tag_pre_releases_as_latest = Some(tag_pre_releases_as_latest);
    self
  }

  pub fn tag_pre_releases_as_latest(&self) -> Option<&bool> {
    self.tag_pre_releases_as_latest.as_ref()
  }

  pub fn reset_tag_pre_releases_as_latest(&mut self) {
    self.tag_pre_releases_as_latest = None;
  }

  pub fn set_use_debian_labels(&mut self, use_debian_labels: bool) {
    self.use_debian_labels = Some(use_debian_labels);
  }

  pub fn with_use_debian_labels(mut self, use_debian_labels: bool) -> RepositoryCreateRequest {
    self.use_debian_labels = Some(use_debian_labels);
    self
  }

  pub fn use_debian_labels(&self) -> Option<&bool> {
    self.use_debian_labels.as_ref()
  }

  pub fn reset_use_debian_labels(&mut self) {
    self.use_debian_labels = None;
  }

  pub fn set_use_default_cargo_upstream(&mut self, use_default_cargo_upstream: bool) {
    self.use_default_cargo_upstream = Some(use_default_cargo_upstream);
  }

  pub fn with_use_default_cargo_upstream(mut self, use_default_cargo_upstream: bool) -> RepositoryCreateRequest {
    self.use_default_cargo_upstream = Some(use_default_cargo_upstream);
    self
  }

  pub fn use_default_cargo_upstream(&self) -> Option<&bool> {
    self.use_default_cargo_upstream.as_ref()
  }

  pub fn reset_use_default_cargo_upstream(&mut self) {
    self.use_default_cargo_upstream = None;
  }

  pub fn set_use_entitlements_privilege(&mut self, use_entitlements_privilege: String) {
    self.use_entitlements_privilege = Some(use_entitlements_privilege);
  }

  pub fn with_use_entitlements_privilege(mut self, use_entitlements_privilege: String) -> RepositoryCreateRequest {
    self.use_entitlements_privilege = Some(use_entitlements_privilege);
    self
  }

  pub fn use_entitlements_privilege(&self) -> Option<&String> {
    self.use_entitlements_privilege.as_ref()
  }

  pub fn reset_use_entitlements_privilege(&mut self) {
    self.use_entitlements_privilege = None;
  }

  pub fn set_use_noarch_packages(&mut self, use_noarch_packages: bool) {
    self.use_noarch_packages = Some(use_noarch_packages);
  }

  pub fn with_use_noarch_packages(mut self, use_noarch_packages: bool) -> RepositoryCreateRequest {
    self.use_noarch_packages = Some(use_noarch_packages);
    self
  }

  pub fn use_noarch_packages(&self) -> Option<&bool> {
    self.use_noarch_packages.as_ref()
  }

  pub fn reset_use_noarch_packages(&mut self) {
    self.use_noarch_packages = None;
  }

  pub fn set_use_source_packages(&mut self, use_source_packages: bool) {
    self.use_source_packages = Some(use_source_packages);
  }

  pub fn with_use_source_packages(mut self, use_source_packages: bool) -> RepositoryCreateRequest {
    self.use_source_packages = Some(use_source_packages);
    self
  }

  pub fn use_source_packages(&self) -> Option<&bool> {
    self.use_source_packages.as_ref()
  }

  pub fn reset_use_source_packages(&mut self) {
    self.use_source_packages = None;
  }

  pub fn set_use_vulnerability_scanning(&mut self, use_vulnerability_scanning: bool) {
    self.use_vulnerability_scanning = Some(use_vulnerability_scanning);
  }

  pub fn with_use_vulnerability_scanning(mut self, use_vulnerability_scanning: bool) -> RepositoryCreateRequest {
    self.use_vulnerability_scanning = Some(use_vulnerability_scanning);
    self
  }

  pub fn use_vulnerability_scanning(&self) -> Option<&bool> {
    self.use_vulnerability_scanning.as_ref()
  }

  pub fn reset_use_vulnerability_scanning(&mut self) {
    self.use_vulnerability_scanning = None;
  }

  pub fn set_user_entitlements_enabled(&mut self, user_entitlements_enabled: bool) {
    self.user_entitlements_enabled = Some(user_entitlements_enabled);
  }

  pub fn with_user_entitlements_enabled(mut self, user_entitlements_enabled: bool) -> RepositoryCreateRequest {
    self.user_entitlements_enabled = Some(user_entitlements_enabled);
    self
  }

  pub fn user_entitlements_enabled(&self) -> Option<&bool> {
    self.user_entitlements_enabled.as_ref()
  }

  pub fn reset_user_entitlements_enabled(&mut self) {
    self.user_entitlements_enabled = None;
  }

  pub fn set_view_statistics(&mut self, view_statistics: String) {
    self.view_statistics = Some(view_statistics);
  }

  pub fn with_view_statistics(mut self, view_statistics: String) -> RepositoryCreateRequest {
    self.view_statistics = Some(view_statistics);
    self
  }

  pub fn view_statistics(&self) -> Option<&String> {
    self.view_statistics.as_ref()
  }

  pub fn reset_view_statistics(&mut self) {
    self.view_statistics = None;
  }

}



