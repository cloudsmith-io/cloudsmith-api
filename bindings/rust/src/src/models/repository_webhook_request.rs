/* 
 * Cloudsmith API (v1)
 *
 * The API to the Cloudsmith Service
 *
 * OpenAPI spec version: v1
 * Contact: support@cloudsmith.io
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct RepositoryWebhookRequest {
  #[serde(rename = "events")]
  events: Vec<String>,
  /// If enabled, the webhook will trigger on subscribed events and send payloads to the configured target URL.
  #[serde(rename = "is_active")]
  is_active: Option<bool>,
  /// The package-based search query for webhooks to fire. This uses the same syntax as the standard search used for repositories, and also supports boolean logic operators such as OR/AND/NOT and parentheses for grouping. If a package does not match, the webhook will not fire.
  #[serde(rename = "package_query")]
  package_query: Option<String>,
  /// The format of the payloads for webhook requests. Valid options are: (0) JSON, (1) JSON array, (2) form encoded JSON and (3) Handlebars template.
  #[serde(rename = "request_body_format")]
  request_body_format: Option<i32>,
  /// The format of the payloads for webhook requests. Valid options are: (0) Generic/user defined, (1) JSON and (2) XML.
  #[serde(rename = "request_body_template_format")]
  request_body_template_format: Option<i32>,
  /// The value that will be sent for the 'Content Type' header. 
  #[serde(rename = "request_content_type")]
  request_content_type: Option<String>,
  /// The header to send the predefined secret in. This must be unique from existing headers or it won't be sent. You can use this as a form of authentication on the endpoint side.
  #[serde(rename = "secret_header")]
  secret_header: Option<String>,
  /// The value for the predefined secret (note: this is treated as a passphrase and is encrypted when we store it). You can use this as a form of authentication on the endpoint side.
  #[serde(rename = "secret_value")]
  secret_value: Option<String>,
  /// The value for the signature key - This is used to generate an HMAC-based hex digest of the request body, which we send as the X-Cloudsmith-Signature header so that you can ensure that the request wasn't modified by a malicious party (note: this is treated as a passphrase and is encrypted when we store it).
  #[serde(rename = "signature_key")]
  signature_key: Option<String>,
  /// The destination URL that webhook payloads will be POST'ed to.
  #[serde(rename = "target_url")]
  target_url: String,
  #[serde(rename = "templates")]
  templates: Vec<::models::WebhookTemplate>,
  /// If enabled, SSL certificates is verified when webhooks are sent. It's recommended to leave this enabled as not verifying the integrity of SSL certificates leaves you susceptible to Man-in-the-Middle (MITM) attacks.
  #[serde(rename = "verify_ssl")]
  verify_ssl: Option<bool>
}

impl RepositoryWebhookRequest {
  pub fn new(events: Vec<String>, target_url: String, templates: Vec<::models::WebhookTemplate>) -> RepositoryWebhookRequest {
    RepositoryWebhookRequest {
      events: events,
      is_active: None,
      package_query: None,
      request_body_format: None,
      request_body_template_format: None,
      request_content_type: None,
      secret_header: None,
      secret_value: None,
      signature_key: None,
      target_url: target_url,
      templates: templates,
      verify_ssl: None
    }
  }

  pub fn set_events(&mut self, events: Vec<String>) {
    self.events = events;
  }

  pub fn with_events(mut self, events: Vec<String>) -> RepositoryWebhookRequest {
    self.events = events;
    self
  }

  pub fn events(&self) -> &Vec<String> {
    &self.events
  }


  pub fn set_is_active(&mut self, is_active: bool) {
    self.is_active = Some(is_active);
  }

  pub fn with_is_active(mut self, is_active: bool) -> RepositoryWebhookRequest {
    self.is_active = Some(is_active);
    self
  }

  pub fn is_active(&self) -> Option<&bool> {
    self.is_active.as_ref()
  }

  pub fn reset_is_active(&mut self) {
    self.is_active = None;
  }

  pub fn set_package_query(&mut self, package_query: String) {
    self.package_query = Some(package_query);
  }

  pub fn with_package_query(mut self, package_query: String) -> RepositoryWebhookRequest {
    self.package_query = Some(package_query);
    self
  }

  pub fn package_query(&self) -> Option<&String> {
    self.package_query.as_ref()
  }

  pub fn reset_package_query(&mut self) {
    self.package_query = None;
  }

  pub fn set_request_body_format(&mut self, request_body_format: i32) {
    self.request_body_format = Some(request_body_format);
  }

  pub fn with_request_body_format(mut self, request_body_format: i32) -> RepositoryWebhookRequest {
    self.request_body_format = Some(request_body_format);
    self
  }

  pub fn request_body_format(&self) -> Option<&i32> {
    self.request_body_format.as_ref()
  }

  pub fn reset_request_body_format(&mut self) {
    self.request_body_format = None;
  }

  pub fn set_request_body_template_format(&mut self, request_body_template_format: i32) {
    self.request_body_template_format = Some(request_body_template_format);
  }

  pub fn with_request_body_template_format(mut self, request_body_template_format: i32) -> RepositoryWebhookRequest {
    self.request_body_template_format = Some(request_body_template_format);
    self
  }

  pub fn request_body_template_format(&self) -> Option<&i32> {
    self.request_body_template_format.as_ref()
  }

  pub fn reset_request_body_template_format(&mut self) {
    self.request_body_template_format = None;
  }

  pub fn set_request_content_type(&mut self, request_content_type: String) {
    self.request_content_type = Some(request_content_type);
  }

  pub fn with_request_content_type(mut self, request_content_type: String) -> RepositoryWebhookRequest {
    self.request_content_type = Some(request_content_type);
    self
  }

  pub fn request_content_type(&self) -> Option<&String> {
    self.request_content_type.as_ref()
  }

  pub fn reset_request_content_type(&mut self) {
    self.request_content_type = None;
  }

  pub fn set_secret_header(&mut self, secret_header: String) {
    self.secret_header = Some(secret_header);
  }

  pub fn with_secret_header(mut self, secret_header: String) -> RepositoryWebhookRequest {
    self.secret_header = Some(secret_header);
    self
  }

  pub fn secret_header(&self) -> Option<&String> {
    self.secret_header.as_ref()
  }

  pub fn reset_secret_header(&mut self) {
    self.secret_header = None;
  }

  pub fn set_secret_value(&mut self, secret_value: String) {
    self.secret_value = Some(secret_value);
  }

  pub fn with_secret_value(mut self, secret_value: String) -> RepositoryWebhookRequest {
    self.secret_value = Some(secret_value);
    self
  }

  pub fn secret_value(&self) -> Option<&String> {
    self.secret_value.as_ref()
  }

  pub fn reset_secret_value(&mut self) {
    self.secret_value = None;
  }

  pub fn set_signature_key(&mut self, signature_key: String) {
    self.signature_key = Some(signature_key);
  }

  pub fn with_signature_key(mut self, signature_key: String) -> RepositoryWebhookRequest {
    self.signature_key = Some(signature_key);
    self
  }

  pub fn signature_key(&self) -> Option<&String> {
    self.signature_key.as_ref()
  }

  pub fn reset_signature_key(&mut self) {
    self.signature_key = None;
  }

  pub fn set_target_url(&mut self, target_url: String) {
    self.target_url = target_url;
  }

  pub fn with_target_url(mut self, target_url: String) -> RepositoryWebhookRequest {
    self.target_url = target_url;
    self
  }

  pub fn target_url(&self) -> &String {
    &self.target_url
  }


  pub fn set_templates(&mut self, templates: Vec<::models::WebhookTemplate>) {
    self.templates = templates;
  }

  pub fn with_templates(mut self, templates: Vec<::models::WebhookTemplate>) -> RepositoryWebhookRequest {
    self.templates = templates;
    self
  }

  pub fn templates(&self) -> &Vec<::models::WebhookTemplate> {
    &self.templates
  }


  pub fn set_verify_ssl(&mut self, verify_ssl: bool) {
    self.verify_ssl = Some(verify_ssl);
  }

  pub fn with_verify_ssl(mut self, verify_ssl: bool) -> RepositoryWebhookRequest {
    self.verify_ssl = Some(verify_ssl);
    self
  }

  pub fn verify_ssl(&self) -> Option<&bool> {
    self.verify_ssl.as_ref()
  }

  pub fn reset_verify_ssl(&mut self) {
    self.verify_ssl = None;
  }

}



