/* 
 * Cloudsmith API (v1)
 *
 * The API to the Cloudsmith Service
 *
 * OpenAPI spec version: v1
 * Contact: support@cloudsmith.io
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct DockerUpstream {
  /// The authentication mode to use when accessing this upstream. 
  #[serde(rename = "auth_mode")]
  auth_mode: Option<String>,
  /// Secret to provide with requests to upstream.
  #[serde(rename = "auth_secret")]
  auth_secret: Option<String>,
  /// Username to provide with requests to upstream.
  #[serde(rename = "auth_username")]
  auth_username: Option<String>,
  /// The datetime the upstream source was created.
  #[serde(rename = "created_at")]
  created_at: Option<String>,
  #[serde(rename = "disable_reason")]
  disable_reason: Option<String>,
  /// The key for extra header #1 to send to upstream.
  #[serde(rename = "extra_header_1")]
  extra_header_1: Option<String>,
  /// The key for extra header #2 to send to upstream.
  #[serde(rename = "extra_header_2")]
  extra_header_2: Option<String>,
  /// The value for extra header #1 to send to upstream. This is stored as plaintext, and is NOT encrypted.
  #[serde(rename = "extra_value_1")]
  extra_value_1: Option<String>,
  /// The value for extra header #2 to send to upstream. This is stored as plaintext, and is NOT encrypted.
  #[serde(rename = "extra_value_2")]
  extra_value_2: Option<String>,
  /// Whether or not this upstream is active and ready for requests.
  #[serde(rename = "is_active")]
  is_active: Option<bool>,
  /// The mode that this upstream should operate in. Upstream sources can be used to proxy resolved packages, as well as operate in a proxy/cache or cache only mode.
  #[serde(rename = "mode")]
  mode: Option<String>,
  /// A descriptive name for this upstream source. A shortened version of this name will be used for tagging cached packages retrieved from this upstream.
  #[serde(rename = "name")]
  name: String,
  /// When true, this upstream source is pending validation.
  #[serde(rename = "pending_validation")]
  pending_validation: Option<bool>,
  /// Upstream sources are selected for resolving requests by sequential order (1..n), followed by creation date.
  #[serde(rename = "priority")]
  priority: Option<i32>,
  #[serde(rename = "slug_perm")]
  slug_perm: Option<String>,
  #[serde(rename = "updated_at")]
  updated_at: Option<String>,
  /// The URL for this upstream source. This must be a fully qualified URL including any path elements required to reach the root of the repository. 
  #[serde(rename = "upstream_url")]
  upstream_url: String,
  /// If enabled, SSL certificates are verified when requests are made to this upstream. It's recommended to leave this enabled for all public sources to help mitigate Man-In-The-Middle (MITM) attacks. Please note this only applies to HTTPS upstreams.
  #[serde(rename = "verify_ssl")]
  verify_ssl: Option<bool>
}

impl DockerUpstream {
  pub fn new(name: String, upstream_url: String) -> DockerUpstream {
    DockerUpstream {
      auth_mode: None,
      auth_secret: None,
      auth_username: None,
      created_at: None,
      disable_reason: None,
      extra_header_1: None,
      extra_header_2: None,
      extra_value_1: None,
      extra_value_2: None,
      is_active: None,
      mode: None,
      name: name,
      pending_validation: None,
      priority: None,
      slug_perm: None,
      updated_at: None,
      upstream_url: upstream_url,
      verify_ssl: None
    }
  }

  pub fn set_auth_mode(&mut self, auth_mode: String) {
    self.auth_mode = Some(auth_mode);
  }

  pub fn with_auth_mode(mut self, auth_mode: String) -> DockerUpstream {
    self.auth_mode = Some(auth_mode);
    self
  }

  pub fn auth_mode(&self) -> Option<&String> {
    self.auth_mode.as_ref()
  }

  pub fn reset_auth_mode(&mut self) {
    self.auth_mode = None;
  }

  pub fn set_auth_secret(&mut self, auth_secret: String) {
    self.auth_secret = Some(auth_secret);
  }

  pub fn with_auth_secret(mut self, auth_secret: String) -> DockerUpstream {
    self.auth_secret = Some(auth_secret);
    self
  }

  pub fn auth_secret(&self) -> Option<&String> {
    self.auth_secret.as_ref()
  }

  pub fn reset_auth_secret(&mut self) {
    self.auth_secret = None;
  }

  pub fn set_auth_username(&mut self, auth_username: String) {
    self.auth_username = Some(auth_username);
  }

  pub fn with_auth_username(mut self, auth_username: String) -> DockerUpstream {
    self.auth_username = Some(auth_username);
    self
  }

  pub fn auth_username(&self) -> Option<&String> {
    self.auth_username.as_ref()
  }

  pub fn reset_auth_username(&mut self) {
    self.auth_username = None;
  }

  pub fn set_created_at(&mut self, created_at: String) {
    self.created_at = Some(created_at);
  }

  pub fn with_created_at(mut self, created_at: String) -> DockerUpstream {
    self.created_at = Some(created_at);
    self
  }

  pub fn created_at(&self) -> Option<&String> {
    self.created_at.as_ref()
  }

  pub fn reset_created_at(&mut self) {
    self.created_at = None;
  }

  pub fn set_disable_reason(&mut self, disable_reason: String) {
    self.disable_reason = Some(disable_reason);
  }

  pub fn with_disable_reason(mut self, disable_reason: String) -> DockerUpstream {
    self.disable_reason = Some(disable_reason);
    self
  }

  pub fn disable_reason(&self) -> Option<&String> {
    self.disable_reason.as_ref()
  }

  pub fn reset_disable_reason(&mut self) {
    self.disable_reason = None;
  }

  pub fn set_extra_header_1(&mut self, extra_header_1: String) {
    self.extra_header_1 = Some(extra_header_1);
  }

  pub fn with_extra_header_1(mut self, extra_header_1: String) -> DockerUpstream {
    self.extra_header_1 = Some(extra_header_1);
    self
  }

  pub fn extra_header_1(&self) -> Option<&String> {
    self.extra_header_1.as_ref()
  }

  pub fn reset_extra_header_1(&mut self) {
    self.extra_header_1 = None;
  }

  pub fn set_extra_header_2(&mut self, extra_header_2: String) {
    self.extra_header_2 = Some(extra_header_2);
  }

  pub fn with_extra_header_2(mut self, extra_header_2: String) -> DockerUpstream {
    self.extra_header_2 = Some(extra_header_2);
    self
  }

  pub fn extra_header_2(&self) -> Option<&String> {
    self.extra_header_2.as_ref()
  }

  pub fn reset_extra_header_2(&mut self) {
    self.extra_header_2 = None;
  }

  pub fn set_extra_value_1(&mut self, extra_value_1: String) {
    self.extra_value_1 = Some(extra_value_1);
  }

  pub fn with_extra_value_1(mut self, extra_value_1: String) -> DockerUpstream {
    self.extra_value_1 = Some(extra_value_1);
    self
  }

  pub fn extra_value_1(&self) -> Option<&String> {
    self.extra_value_1.as_ref()
  }

  pub fn reset_extra_value_1(&mut self) {
    self.extra_value_1 = None;
  }

  pub fn set_extra_value_2(&mut self, extra_value_2: String) {
    self.extra_value_2 = Some(extra_value_2);
  }

  pub fn with_extra_value_2(mut self, extra_value_2: String) -> DockerUpstream {
    self.extra_value_2 = Some(extra_value_2);
    self
  }

  pub fn extra_value_2(&self) -> Option<&String> {
    self.extra_value_2.as_ref()
  }

  pub fn reset_extra_value_2(&mut self) {
    self.extra_value_2 = None;
  }

  pub fn set_is_active(&mut self, is_active: bool) {
    self.is_active = Some(is_active);
  }

  pub fn with_is_active(mut self, is_active: bool) -> DockerUpstream {
    self.is_active = Some(is_active);
    self
  }

  pub fn is_active(&self) -> Option<&bool> {
    self.is_active.as_ref()
  }

  pub fn reset_is_active(&mut self) {
    self.is_active = None;
  }

  pub fn set_mode(&mut self, mode: String) {
    self.mode = Some(mode);
  }

  pub fn with_mode(mut self, mode: String) -> DockerUpstream {
    self.mode = Some(mode);
    self
  }

  pub fn mode(&self) -> Option<&String> {
    self.mode.as_ref()
  }

  pub fn reset_mode(&mut self) {
    self.mode = None;
  }

  pub fn set_name(&mut self, name: String) {
    self.name = name;
  }

  pub fn with_name(mut self, name: String) -> DockerUpstream {
    self.name = name;
    self
  }

  pub fn name(&self) -> &String {
    &self.name
  }


  pub fn set_pending_validation(&mut self, pending_validation: bool) {
    self.pending_validation = Some(pending_validation);
  }

  pub fn with_pending_validation(mut self, pending_validation: bool) -> DockerUpstream {
    self.pending_validation = Some(pending_validation);
    self
  }

  pub fn pending_validation(&self) -> Option<&bool> {
    self.pending_validation.as_ref()
  }

  pub fn reset_pending_validation(&mut self) {
    self.pending_validation = None;
  }

  pub fn set_priority(&mut self, priority: i32) {
    self.priority = Some(priority);
  }

  pub fn with_priority(mut self, priority: i32) -> DockerUpstream {
    self.priority = Some(priority);
    self
  }

  pub fn priority(&self) -> Option<&i32> {
    self.priority.as_ref()
  }

  pub fn reset_priority(&mut self) {
    self.priority = None;
  }

  pub fn set_slug_perm(&mut self, slug_perm: String) {
    self.slug_perm = Some(slug_perm);
  }

  pub fn with_slug_perm(mut self, slug_perm: String) -> DockerUpstream {
    self.slug_perm = Some(slug_perm);
    self
  }

  pub fn slug_perm(&self) -> Option<&String> {
    self.slug_perm.as_ref()
  }

  pub fn reset_slug_perm(&mut self) {
    self.slug_perm = None;
  }

  pub fn set_updated_at(&mut self, updated_at: String) {
    self.updated_at = Some(updated_at);
  }

  pub fn with_updated_at(mut self, updated_at: String) -> DockerUpstream {
    self.updated_at = Some(updated_at);
    self
  }

  pub fn updated_at(&self) -> Option<&String> {
    self.updated_at.as_ref()
  }

  pub fn reset_updated_at(&mut self) {
    self.updated_at = None;
  }

  pub fn set_upstream_url(&mut self, upstream_url: String) {
    self.upstream_url = upstream_url;
  }

  pub fn with_upstream_url(mut self, upstream_url: String) -> DockerUpstream {
    self.upstream_url = upstream_url;
    self
  }

  pub fn upstream_url(&self) -> &String {
    &self.upstream_url
  }


  pub fn set_verify_ssl(&mut self, verify_ssl: bool) {
    self.verify_ssl = Some(verify_ssl);
  }

  pub fn with_verify_ssl(mut self, verify_ssl: bool) -> DockerUpstream {
    self.verify_ssl = Some(verify_ssl);
    self
  }

  pub fn verify_ssl(&self) -> Option<&bool> {
    self.verify_ssl.as_ref()
  }

  pub fn reset_verify_ssl(&mut self) {
    self.verify_ssl = None;
  }

}



