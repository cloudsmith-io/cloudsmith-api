/* 
 * Cloudsmith API (v1)
 *
 * The API to the Cloudsmith Service
 *
 * OpenAPI spec version: v1
 * Contact: support@cloudsmith.io
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct PackageStatus {
  #[serde(rename = "is_cancellable")]
  is_cancellable: Option<bool>,
  #[serde(rename = "is_copyable")]
  is_copyable: Option<bool>,
  #[serde(rename = "is_deleteable")]
  is_deleteable: Option<bool>,
  #[serde(rename = "is_downloadable")]
  is_downloadable: Option<bool>,
  #[serde(rename = "is_moveable")]
  is_moveable: Option<bool>,
  #[serde(rename = "is_quarantinable")]
  is_quarantinable: Option<bool>,
  #[serde(rename = "is_quarantined")]
  is_quarantined: Option<bool>,
  #[serde(rename = "is_resyncable")]
  is_resyncable: Option<bool>,
  #[serde(rename = "is_security_scannable")]
  is_security_scannable: Option<bool>,
  #[serde(rename = "is_sync_awaiting")]
  is_sync_awaiting: Option<bool>,
  #[serde(rename = "is_sync_completed")]
  is_sync_completed: Option<bool>,
  #[serde(rename = "is_sync_failed")]
  is_sync_failed: Option<bool>,
  #[serde(rename = "is_sync_in_flight")]
  is_sync_in_flight: Option<bool>,
  #[serde(rename = "is_sync_in_progress")]
  is_sync_in_progress: Option<bool>,
  #[serde(rename = "self_url")]
  self_url: Option<String>,
  /// The synchronisation (in progress) stage of the package.
  #[serde(rename = "stage")]
  stage: Option<i32>,
  #[serde(rename = "stage_str")]
  stage_str: Option<String>,
  /// The datetime the package stage was updated at.
  #[serde(rename = "stage_updated_at")]
  stage_updated_at: Option<String>,
  /// The synchronisation status of the package.
  #[serde(rename = "status")]
  status: Option<i32>,
  /// A textual description for the synchronous status reason (if any
  #[serde(rename = "status_reason")]
  status_reason: Option<String>,
  #[serde(rename = "status_str")]
  status_str: Option<String>,
  /// The datetime the package status was updated at.
  #[serde(rename = "status_updated_at")]
  status_updated_at: Option<String>,
  /// The datetime the package sync was finished at.
  #[serde(rename = "sync_finished_at")]
  sync_finished_at: Option<String>,
  /// Synchronisation progress (from 0-100)
  #[serde(rename = "sync_progress")]
  sync_progress: Option<i32>
}

impl PackageStatus {
  pub fn new() -> PackageStatus {
    PackageStatus {
      is_cancellable: None,
      is_copyable: None,
      is_deleteable: None,
      is_downloadable: None,
      is_moveable: None,
      is_quarantinable: None,
      is_quarantined: None,
      is_resyncable: None,
      is_security_scannable: None,
      is_sync_awaiting: None,
      is_sync_completed: None,
      is_sync_failed: None,
      is_sync_in_flight: None,
      is_sync_in_progress: None,
      self_url: None,
      stage: None,
      stage_str: None,
      stage_updated_at: None,
      status: None,
      status_reason: None,
      status_str: None,
      status_updated_at: None,
      sync_finished_at: None,
      sync_progress: None
    }
  }

  pub fn set_is_cancellable(&mut self, is_cancellable: bool) {
    self.is_cancellable = Some(is_cancellable);
  }

  pub fn with_is_cancellable(mut self, is_cancellable: bool) -> PackageStatus {
    self.is_cancellable = Some(is_cancellable);
    self
  }

  pub fn is_cancellable(&self) -> Option<&bool> {
    self.is_cancellable.as_ref()
  }

  pub fn reset_is_cancellable(&mut self) {
    self.is_cancellable = None;
  }

  pub fn set_is_copyable(&mut self, is_copyable: bool) {
    self.is_copyable = Some(is_copyable);
  }

  pub fn with_is_copyable(mut self, is_copyable: bool) -> PackageStatus {
    self.is_copyable = Some(is_copyable);
    self
  }

  pub fn is_copyable(&self) -> Option<&bool> {
    self.is_copyable.as_ref()
  }

  pub fn reset_is_copyable(&mut self) {
    self.is_copyable = None;
  }

  pub fn set_is_deleteable(&mut self, is_deleteable: bool) {
    self.is_deleteable = Some(is_deleteable);
  }

  pub fn with_is_deleteable(mut self, is_deleteable: bool) -> PackageStatus {
    self.is_deleteable = Some(is_deleteable);
    self
  }

  pub fn is_deleteable(&self) -> Option<&bool> {
    self.is_deleteable.as_ref()
  }

  pub fn reset_is_deleteable(&mut self) {
    self.is_deleteable = None;
  }

  pub fn set_is_downloadable(&mut self, is_downloadable: bool) {
    self.is_downloadable = Some(is_downloadable);
  }

  pub fn with_is_downloadable(mut self, is_downloadable: bool) -> PackageStatus {
    self.is_downloadable = Some(is_downloadable);
    self
  }

  pub fn is_downloadable(&self) -> Option<&bool> {
    self.is_downloadable.as_ref()
  }

  pub fn reset_is_downloadable(&mut self) {
    self.is_downloadable = None;
  }

  pub fn set_is_moveable(&mut self, is_moveable: bool) {
    self.is_moveable = Some(is_moveable);
  }

  pub fn with_is_moveable(mut self, is_moveable: bool) -> PackageStatus {
    self.is_moveable = Some(is_moveable);
    self
  }

  pub fn is_moveable(&self) -> Option<&bool> {
    self.is_moveable.as_ref()
  }

  pub fn reset_is_moveable(&mut self) {
    self.is_moveable = None;
  }

  pub fn set_is_quarantinable(&mut self, is_quarantinable: bool) {
    self.is_quarantinable = Some(is_quarantinable);
  }

  pub fn with_is_quarantinable(mut self, is_quarantinable: bool) -> PackageStatus {
    self.is_quarantinable = Some(is_quarantinable);
    self
  }

  pub fn is_quarantinable(&self) -> Option<&bool> {
    self.is_quarantinable.as_ref()
  }

  pub fn reset_is_quarantinable(&mut self) {
    self.is_quarantinable = None;
  }

  pub fn set_is_quarantined(&mut self, is_quarantined: bool) {
    self.is_quarantined = Some(is_quarantined);
  }

  pub fn with_is_quarantined(mut self, is_quarantined: bool) -> PackageStatus {
    self.is_quarantined = Some(is_quarantined);
    self
  }

  pub fn is_quarantined(&self) -> Option<&bool> {
    self.is_quarantined.as_ref()
  }

  pub fn reset_is_quarantined(&mut self) {
    self.is_quarantined = None;
  }

  pub fn set_is_resyncable(&mut self, is_resyncable: bool) {
    self.is_resyncable = Some(is_resyncable);
  }

  pub fn with_is_resyncable(mut self, is_resyncable: bool) -> PackageStatus {
    self.is_resyncable = Some(is_resyncable);
    self
  }

  pub fn is_resyncable(&self) -> Option<&bool> {
    self.is_resyncable.as_ref()
  }

  pub fn reset_is_resyncable(&mut self) {
    self.is_resyncable = None;
  }

  pub fn set_is_security_scannable(&mut self, is_security_scannable: bool) {
    self.is_security_scannable = Some(is_security_scannable);
  }

  pub fn with_is_security_scannable(mut self, is_security_scannable: bool) -> PackageStatus {
    self.is_security_scannable = Some(is_security_scannable);
    self
  }

  pub fn is_security_scannable(&self) -> Option<&bool> {
    self.is_security_scannable.as_ref()
  }

  pub fn reset_is_security_scannable(&mut self) {
    self.is_security_scannable = None;
  }

  pub fn set_is_sync_awaiting(&mut self, is_sync_awaiting: bool) {
    self.is_sync_awaiting = Some(is_sync_awaiting);
  }

  pub fn with_is_sync_awaiting(mut self, is_sync_awaiting: bool) -> PackageStatus {
    self.is_sync_awaiting = Some(is_sync_awaiting);
    self
  }

  pub fn is_sync_awaiting(&self) -> Option<&bool> {
    self.is_sync_awaiting.as_ref()
  }

  pub fn reset_is_sync_awaiting(&mut self) {
    self.is_sync_awaiting = None;
  }

  pub fn set_is_sync_completed(&mut self, is_sync_completed: bool) {
    self.is_sync_completed = Some(is_sync_completed);
  }

  pub fn with_is_sync_completed(mut self, is_sync_completed: bool) -> PackageStatus {
    self.is_sync_completed = Some(is_sync_completed);
    self
  }

  pub fn is_sync_completed(&self) -> Option<&bool> {
    self.is_sync_completed.as_ref()
  }

  pub fn reset_is_sync_completed(&mut self) {
    self.is_sync_completed = None;
  }

  pub fn set_is_sync_failed(&mut self, is_sync_failed: bool) {
    self.is_sync_failed = Some(is_sync_failed);
  }

  pub fn with_is_sync_failed(mut self, is_sync_failed: bool) -> PackageStatus {
    self.is_sync_failed = Some(is_sync_failed);
    self
  }

  pub fn is_sync_failed(&self) -> Option<&bool> {
    self.is_sync_failed.as_ref()
  }

  pub fn reset_is_sync_failed(&mut self) {
    self.is_sync_failed = None;
  }

  pub fn set_is_sync_in_flight(&mut self, is_sync_in_flight: bool) {
    self.is_sync_in_flight = Some(is_sync_in_flight);
  }

  pub fn with_is_sync_in_flight(mut self, is_sync_in_flight: bool) -> PackageStatus {
    self.is_sync_in_flight = Some(is_sync_in_flight);
    self
  }

  pub fn is_sync_in_flight(&self) -> Option<&bool> {
    self.is_sync_in_flight.as_ref()
  }

  pub fn reset_is_sync_in_flight(&mut self) {
    self.is_sync_in_flight = None;
  }

  pub fn set_is_sync_in_progress(&mut self, is_sync_in_progress: bool) {
    self.is_sync_in_progress = Some(is_sync_in_progress);
  }

  pub fn with_is_sync_in_progress(mut self, is_sync_in_progress: bool) -> PackageStatus {
    self.is_sync_in_progress = Some(is_sync_in_progress);
    self
  }

  pub fn is_sync_in_progress(&self) -> Option<&bool> {
    self.is_sync_in_progress.as_ref()
  }

  pub fn reset_is_sync_in_progress(&mut self) {
    self.is_sync_in_progress = None;
  }

  pub fn set_self_url(&mut self, self_url: String) {
    self.self_url = Some(self_url);
  }

  pub fn with_self_url(mut self, self_url: String) -> PackageStatus {
    self.self_url = Some(self_url);
    self
  }

  pub fn self_url(&self) -> Option<&String> {
    self.self_url.as_ref()
  }

  pub fn reset_self_url(&mut self) {
    self.self_url = None;
  }

  pub fn set_stage(&mut self, stage: i32) {
    self.stage = Some(stage);
  }

  pub fn with_stage(mut self, stage: i32) -> PackageStatus {
    self.stage = Some(stage);
    self
  }

  pub fn stage(&self) -> Option<&i32> {
    self.stage.as_ref()
  }

  pub fn reset_stage(&mut self) {
    self.stage = None;
  }

  pub fn set_stage_str(&mut self, stage_str: String) {
    self.stage_str = Some(stage_str);
  }

  pub fn with_stage_str(mut self, stage_str: String) -> PackageStatus {
    self.stage_str = Some(stage_str);
    self
  }

  pub fn stage_str(&self) -> Option<&String> {
    self.stage_str.as_ref()
  }

  pub fn reset_stage_str(&mut self) {
    self.stage_str = None;
  }

  pub fn set_stage_updated_at(&mut self, stage_updated_at: String) {
    self.stage_updated_at = Some(stage_updated_at);
  }

  pub fn with_stage_updated_at(mut self, stage_updated_at: String) -> PackageStatus {
    self.stage_updated_at = Some(stage_updated_at);
    self
  }

  pub fn stage_updated_at(&self) -> Option<&String> {
    self.stage_updated_at.as_ref()
  }

  pub fn reset_stage_updated_at(&mut self) {
    self.stage_updated_at = None;
  }

  pub fn set_status(&mut self, status: i32) {
    self.status = Some(status);
  }

  pub fn with_status(mut self, status: i32) -> PackageStatus {
    self.status = Some(status);
    self
  }

  pub fn status(&self) -> Option<&i32> {
    self.status.as_ref()
  }

  pub fn reset_status(&mut self) {
    self.status = None;
  }

  pub fn set_status_reason(&mut self, status_reason: String) {
    self.status_reason = Some(status_reason);
  }

  pub fn with_status_reason(mut self, status_reason: String) -> PackageStatus {
    self.status_reason = Some(status_reason);
    self
  }

  pub fn status_reason(&self) -> Option<&String> {
    self.status_reason.as_ref()
  }

  pub fn reset_status_reason(&mut self) {
    self.status_reason = None;
  }

  pub fn set_status_str(&mut self, status_str: String) {
    self.status_str = Some(status_str);
  }

  pub fn with_status_str(mut self, status_str: String) -> PackageStatus {
    self.status_str = Some(status_str);
    self
  }

  pub fn status_str(&self) -> Option<&String> {
    self.status_str.as_ref()
  }

  pub fn reset_status_str(&mut self) {
    self.status_str = None;
  }

  pub fn set_status_updated_at(&mut self, status_updated_at: String) {
    self.status_updated_at = Some(status_updated_at);
  }

  pub fn with_status_updated_at(mut self, status_updated_at: String) -> PackageStatus {
    self.status_updated_at = Some(status_updated_at);
    self
  }

  pub fn status_updated_at(&self) -> Option<&String> {
    self.status_updated_at.as_ref()
  }

  pub fn reset_status_updated_at(&mut self) {
    self.status_updated_at = None;
  }

  pub fn set_sync_finished_at(&mut self, sync_finished_at: String) {
    self.sync_finished_at = Some(sync_finished_at);
  }

  pub fn with_sync_finished_at(mut self, sync_finished_at: String) -> PackageStatus {
    self.sync_finished_at = Some(sync_finished_at);
    self
  }

  pub fn sync_finished_at(&self) -> Option<&String> {
    self.sync_finished_at.as_ref()
  }

  pub fn reset_sync_finished_at(&mut self) {
    self.sync_finished_at = None;
  }

  pub fn set_sync_progress(&mut self, sync_progress: i32) {
    self.sync_progress = Some(sync_progress);
  }

  pub fn with_sync_progress(mut self, sync_progress: i32) -> PackageStatus {
    self.sync_progress = Some(sync_progress);
    self
  }

  pub fn sync_progress(&self) -> Option<&i32> {
    self.sync_progress.as_ref()
  }

  pub fn reset_sync_progress(&mut self) {
    self.sync_progress = None;
  }

}



