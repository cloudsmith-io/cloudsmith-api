/* 
 * Cloudsmith API (v1)
 *
 * The API to the Cloudsmith Service
 *
 * OpenAPI spec version: v1
 * Contact: support@cloudsmith.io
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct DebUpstreamRequestPatch {
  /// The authentication mode to use when accessing this upstream. 
  #[serde(rename = "auth_mode")]
  auth_mode: Option<String>,
  /// Secret to provide with requests to upstream.
  #[serde(rename = "auth_secret")]
  auth_secret: Option<String>,
  /// Username to provide with requests to upstream.
  #[serde(rename = "auth_username")]
  auth_username: Option<String>,
  /// The component to fetch from the upstream
  #[serde(rename = "component")]
  component: Option<String>,
  /// The distribution version that packages found on this upstream could be associated with.
  #[serde(rename = "distro_versions")]
  distro_versions: Option<Vec<String>>,
  /// The key for extra header #1 to send to upstream.
  #[serde(rename = "extra_header_1")]
  extra_header_1: Option<String>,
  /// The key for extra header #2 to send to upstream.
  #[serde(rename = "extra_header_2")]
  extra_header_2: Option<String>,
  /// The value for extra header #1 to send to upstream. This is stored as plaintext, and is NOT encrypted.
  #[serde(rename = "extra_value_1")]
  extra_value_1: Option<String>,
  /// The value for extra header #2 to send to upstream. This is stored as plaintext, and is NOT encrypted.
  #[serde(rename = "extra_value_2")]
  extra_value_2: Option<String>,
  /// A public GPG key to associate with packages found on this upstream. When using the Cloudsmith setup script, this GPG key will be automatically imported on your deployment machines to allow upstream packages to validate and install.
  #[serde(rename = "gpg_key_inline")]
  gpg_key_inline: Option<String>,
  /// When provided, Cloudsmith will fetch, validate, and associate a public GPG key found at the provided URL. When using the Cloudsmith setup script, this GPG key will be automatically imported on your deployment machines to allow upstream packages to validate and install.
  #[serde(rename = "gpg_key_url")]
  gpg_key_url: Option<String>,
  /// The GPG signature verification mode for this upstream.
  #[serde(rename = "gpg_verification")]
  gpg_verification: Option<String>,
  /// When true, source packages will be available from this upstream.
  #[serde(rename = "include_sources")]
  include_sources: Option<bool>,
  /// Whether or not this upstream is active and ready for requests.
  #[serde(rename = "is_active")]
  is_active: Option<bool>,
  /// The mode that this upstream should operate in. Upstream sources can be used to proxy resolved packages, as well as operate in a proxy/cache or cache only mode.
  #[serde(rename = "mode")]
  mode: Option<String>,
  /// A descriptive name for this upstream source. A shortened version of this name will be used for tagging cached packages retrieved from this upstream.
  #[serde(rename = "name")]
  name: Option<String>,
  /// Upstream sources are selected for resolving requests by sequential order (1..n), followed by creation date.
  #[serde(rename = "priority")]
  priority: Option<i32>,
  /// The distribution to fetch from the upstream
  #[serde(rename = "upstream_distribution")]
  upstream_distribution: Option<String>,
  /// The URL for this upstream source. This must be a fully qualified URL including any path elements required to reach the root of the repository. 
  #[serde(rename = "upstream_url")]
  upstream_url: Option<String>,
  /// If enabled, SSL certificates are verified when requests are made to this upstream. It's recommended to leave this enabled for all public sources to help mitigate Man-In-The-Middle (MITM) attacks. Please note this only applies to HTTPS upstreams.
  #[serde(rename = "verify_ssl")]
  verify_ssl: Option<bool>
}

impl DebUpstreamRequestPatch {
  pub fn new() -> DebUpstreamRequestPatch {
    DebUpstreamRequestPatch {
      auth_mode: None,
      auth_secret: None,
      auth_username: None,
      component: None,
      distro_versions: None,
      extra_header_1: None,
      extra_header_2: None,
      extra_value_1: None,
      extra_value_2: None,
      gpg_key_inline: None,
      gpg_key_url: None,
      gpg_verification: None,
      include_sources: None,
      is_active: None,
      mode: None,
      name: None,
      priority: None,
      upstream_distribution: None,
      upstream_url: None,
      verify_ssl: None
    }
  }

  pub fn set_auth_mode(&mut self, auth_mode: String) {
    self.auth_mode = Some(auth_mode);
  }

  pub fn with_auth_mode(mut self, auth_mode: String) -> DebUpstreamRequestPatch {
    self.auth_mode = Some(auth_mode);
    self
  }

  pub fn auth_mode(&self) -> Option<&String> {
    self.auth_mode.as_ref()
  }

  pub fn reset_auth_mode(&mut self) {
    self.auth_mode = None;
  }

  pub fn set_auth_secret(&mut self, auth_secret: String) {
    self.auth_secret = Some(auth_secret);
  }

  pub fn with_auth_secret(mut self, auth_secret: String) -> DebUpstreamRequestPatch {
    self.auth_secret = Some(auth_secret);
    self
  }

  pub fn auth_secret(&self) -> Option<&String> {
    self.auth_secret.as_ref()
  }

  pub fn reset_auth_secret(&mut self) {
    self.auth_secret = None;
  }

  pub fn set_auth_username(&mut self, auth_username: String) {
    self.auth_username = Some(auth_username);
  }

  pub fn with_auth_username(mut self, auth_username: String) -> DebUpstreamRequestPatch {
    self.auth_username = Some(auth_username);
    self
  }

  pub fn auth_username(&self) -> Option<&String> {
    self.auth_username.as_ref()
  }

  pub fn reset_auth_username(&mut self) {
    self.auth_username = None;
  }

  pub fn set_component(&mut self, component: String) {
    self.component = Some(component);
  }

  pub fn with_component(mut self, component: String) -> DebUpstreamRequestPatch {
    self.component = Some(component);
    self
  }

  pub fn component(&self) -> Option<&String> {
    self.component.as_ref()
  }

  pub fn reset_component(&mut self) {
    self.component = None;
  }

  pub fn set_distro_versions(&mut self, distro_versions: Vec<String>) {
    self.distro_versions = Some(distro_versions);
  }

  pub fn with_distro_versions(mut self, distro_versions: Vec<String>) -> DebUpstreamRequestPatch {
    self.distro_versions = Some(distro_versions);
    self
  }

  pub fn distro_versions(&self) -> Option<&Vec<String>> {
    self.distro_versions.as_ref()
  }

  pub fn reset_distro_versions(&mut self) {
    self.distro_versions = None;
  }

  pub fn set_extra_header_1(&mut self, extra_header_1: String) {
    self.extra_header_1 = Some(extra_header_1);
  }

  pub fn with_extra_header_1(mut self, extra_header_1: String) -> DebUpstreamRequestPatch {
    self.extra_header_1 = Some(extra_header_1);
    self
  }

  pub fn extra_header_1(&self) -> Option<&String> {
    self.extra_header_1.as_ref()
  }

  pub fn reset_extra_header_1(&mut self) {
    self.extra_header_1 = None;
  }

  pub fn set_extra_header_2(&mut self, extra_header_2: String) {
    self.extra_header_2 = Some(extra_header_2);
  }

  pub fn with_extra_header_2(mut self, extra_header_2: String) -> DebUpstreamRequestPatch {
    self.extra_header_2 = Some(extra_header_2);
    self
  }

  pub fn extra_header_2(&self) -> Option<&String> {
    self.extra_header_2.as_ref()
  }

  pub fn reset_extra_header_2(&mut self) {
    self.extra_header_2 = None;
  }

  pub fn set_extra_value_1(&mut self, extra_value_1: String) {
    self.extra_value_1 = Some(extra_value_1);
  }

  pub fn with_extra_value_1(mut self, extra_value_1: String) -> DebUpstreamRequestPatch {
    self.extra_value_1 = Some(extra_value_1);
    self
  }

  pub fn extra_value_1(&self) -> Option<&String> {
    self.extra_value_1.as_ref()
  }

  pub fn reset_extra_value_1(&mut self) {
    self.extra_value_1 = None;
  }

  pub fn set_extra_value_2(&mut self, extra_value_2: String) {
    self.extra_value_2 = Some(extra_value_2);
  }

  pub fn with_extra_value_2(mut self, extra_value_2: String) -> DebUpstreamRequestPatch {
    self.extra_value_2 = Some(extra_value_2);
    self
  }

  pub fn extra_value_2(&self) -> Option<&String> {
    self.extra_value_2.as_ref()
  }

  pub fn reset_extra_value_2(&mut self) {
    self.extra_value_2 = None;
  }

  pub fn set_gpg_key_inline(&mut self, gpg_key_inline: String) {
    self.gpg_key_inline = Some(gpg_key_inline);
  }

  pub fn with_gpg_key_inline(mut self, gpg_key_inline: String) -> DebUpstreamRequestPatch {
    self.gpg_key_inline = Some(gpg_key_inline);
    self
  }

  pub fn gpg_key_inline(&self) -> Option<&String> {
    self.gpg_key_inline.as_ref()
  }

  pub fn reset_gpg_key_inline(&mut self) {
    self.gpg_key_inline = None;
  }

  pub fn set_gpg_key_url(&mut self, gpg_key_url: String) {
    self.gpg_key_url = Some(gpg_key_url);
  }

  pub fn with_gpg_key_url(mut self, gpg_key_url: String) -> DebUpstreamRequestPatch {
    self.gpg_key_url = Some(gpg_key_url);
    self
  }

  pub fn gpg_key_url(&self) -> Option<&String> {
    self.gpg_key_url.as_ref()
  }

  pub fn reset_gpg_key_url(&mut self) {
    self.gpg_key_url = None;
  }

  pub fn set_gpg_verification(&mut self, gpg_verification: String) {
    self.gpg_verification = Some(gpg_verification);
  }

  pub fn with_gpg_verification(mut self, gpg_verification: String) -> DebUpstreamRequestPatch {
    self.gpg_verification = Some(gpg_verification);
    self
  }

  pub fn gpg_verification(&self) -> Option<&String> {
    self.gpg_verification.as_ref()
  }

  pub fn reset_gpg_verification(&mut self) {
    self.gpg_verification = None;
  }

  pub fn set_include_sources(&mut self, include_sources: bool) {
    self.include_sources = Some(include_sources);
  }

  pub fn with_include_sources(mut self, include_sources: bool) -> DebUpstreamRequestPatch {
    self.include_sources = Some(include_sources);
    self
  }

  pub fn include_sources(&self) -> Option<&bool> {
    self.include_sources.as_ref()
  }

  pub fn reset_include_sources(&mut self) {
    self.include_sources = None;
  }

  pub fn set_is_active(&mut self, is_active: bool) {
    self.is_active = Some(is_active);
  }

  pub fn with_is_active(mut self, is_active: bool) -> DebUpstreamRequestPatch {
    self.is_active = Some(is_active);
    self
  }

  pub fn is_active(&self) -> Option<&bool> {
    self.is_active.as_ref()
  }

  pub fn reset_is_active(&mut self) {
    self.is_active = None;
  }

  pub fn set_mode(&mut self, mode: String) {
    self.mode = Some(mode);
  }

  pub fn with_mode(mut self, mode: String) -> DebUpstreamRequestPatch {
    self.mode = Some(mode);
    self
  }

  pub fn mode(&self) -> Option<&String> {
    self.mode.as_ref()
  }

  pub fn reset_mode(&mut self) {
    self.mode = None;
  }

  pub fn set_name(&mut self, name: String) {
    self.name = Some(name);
  }

  pub fn with_name(mut self, name: String) -> DebUpstreamRequestPatch {
    self.name = Some(name);
    self
  }

  pub fn name(&self) -> Option<&String> {
    self.name.as_ref()
  }

  pub fn reset_name(&mut self) {
    self.name = None;
  }

  pub fn set_priority(&mut self, priority: i32) {
    self.priority = Some(priority);
  }

  pub fn with_priority(mut self, priority: i32) -> DebUpstreamRequestPatch {
    self.priority = Some(priority);
    self
  }

  pub fn priority(&self) -> Option<&i32> {
    self.priority.as_ref()
  }

  pub fn reset_priority(&mut self) {
    self.priority = None;
  }

  pub fn set_upstream_distribution(&mut self, upstream_distribution: String) {
    self.upstream_distribution = Some(upstream_distribution);
  }

  pub fn with_upstream_distribution(mut self, upstream_distribution: String) -> DebUpstreamRequestPatch {
    self.upstream_distribution = Some(upstream_distribution);
    self
  }

  pub fn upstream_distribution(&self) -> Option<&String> {
    self.upstream_distribution.as_ref()
  }

  pub fn reset_upstream_distribution(&mut self) {
    self.upstream_distribution = None;
  }

  pub fn set_upstream_url(&mut self, upstream_url: String) {
    self.upstream_url = Some(upstream_url);
  }

  pub fn with_upstream_url(mut self, upstream_url: String) -> DebUpstreamRequestPatch {
    self.upstream_url = Some(upstream_url);
    self
  }

  pub fn upstream_url(&self) -> Option<&String> {
    self.upstream_url.as_ref()
  }

  pub fn reset_upstream_url(&mut self) {
    self.upstream_url = None;
  }

  pub fn set_verify_ssl(&mut self, verify_ssl: bool) {
    self.verify_ssl = Some(verify_ssl);
  }

  pub fn with_verify_ssl(mut self, verify_ssl: bool) -> DebUpstreamRequestPatch {
    self.verify_ssl = Some(verify_ssl);
    self
  }

  pub fn verify_ssl(&self) -> Option<&bool> {
    self.verify_ssl.as_ref()
  }

  pub fn reset_verify_ssl(&mut self) {
    self.verify_ssl = None;
  }

}



