/* 
 * Cloudsmith API (v1)
 *
 * The API to the Cloudsmith Service
 *
 * OpenAPI spec version: v1
 * Contact: support@cloudsmith.io
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct RepositoryTokenRefresh {
  #[serde(rename = "clients")]
  clients: Option<i32>,
  /// The datetime the token was updated at.
  #[serde(rename = "created_at")]
  created_at: Option<String>,
  #[serde(rename = "created_by")]
  created_by: Option<String>,
  #[serde(rename = "created_by_url")]
  created_by_url: Option<String>,
  /// If selected this is the default token for this repository.
  #[serde(rename = "default")]
  default: Option<bool>,
  #[serde(rename = "disable_url")]
  disable_url: Option<String>,
  #[serde(rename = "downloads")]
  downloads: Option<i32>,
  #[serde(rename = "enable_url")]
  enable_url: Option<String>,
  #[serde(rename = "eula_accepted")]
  eula_accepted: Option<::models::Eula>,
  /// The datetime the EULA was accepted at.
  #[serde(rename = "eula_accepted_at")]
  eula_accepted_at: Option<String>,
  #[serde(rename = "eula_accepted_from")]
  eula_accepted_from: Option<String>,
  /// If checked, a EULA acceptance is required for this token.
  #[serde(rename = "eula_required")]
  eula_required: Option<bool>,
  #[serde(rename = "has_limits")]
  has_limits: Option<bool>,
  /// Deprecated (23-05-15): Please use 'slug_perm' instead. Previously: A monotonically increasing number that identified an entitlement within a repository.
  #[serde(rename = "identifier")]
  identifier: Option<i32>,
  /// If enabled, the token will allow downloads based on configured restrictions (if any).
  #[serde(rename = "is_active")]
  is_active: Option<bool>,
  #[serde(rename = "is_limited")]
  is_limited: Option<bool>,
  /// The maximum download bandwidth allowed for the token. Values are expressed as the selected unit of bandwidth. Please note that since downloads are calculated asynchronously (after the download happens), the limit may not be imposed immediately but at a later point. 
  #[serde(rename = "limit_bandwidth")]
  limit_bandwidth: Option<i32>,
  #[serde(rename = "limit_bandwidth_unit")]
  limit_bandwidth_unit: Option<String>,
  /// The starting date/time the token is allowed to be used from.
  #[serde(rename = "limit_date_range_from")]
  limit_date_range_from: Option<String>,
  /// The ending date/time the token is allowed to be used until.
  #[serde(rename = "limit_date_range_to")]
  limit_date_range_to: Option<String>,
  /// The maximum number of unique clients allowed for the token. Please note that since clients are calculated asynchronously (after the download happens), the limit may not be imposed immediately but at a later point.
  #[serde(rename = "limit_num_clients")]
  limit_num_clients: Option<i32>,
  /// The maximum number of downloads allowed for the token. Please note that since downloads are calculated asynchronously (after the download happens), the limit may not be imposed immediately but at a later point.
  #[serde(rename = "limit_num_downloads")]
  limit_num_downloads: Option<i32>,
  /// The package-based search query to apply to restrict downloads to. This uses the same syntax as the standard search used for repositories, and also supports boolean logic operators such as OR/AND/NOT and parentheses for grouping. This will still allow access to non-package files, such as metadata.
  #[serde(rename = "limit_package_query")]
  limit_package_query: Option<String>,
  /// THIS WILL SOON BE DEPRECATED, please use limit_package_query instead. The path-based search query to apply to restrict downloads to. This supports boolean logic operators such as OR/AND/NOT and parentheses for grouping. The path evaluated does not include the domain name, the namespace, the entitlement code used, the package format, etc. and it always starts with a forward slash.
  #[serde(rename = "limit_path_query")]
  limit_path_query: Option<String>,
  #[serde(rename = "metadata")]
  metadata: Option<Value>,
  #[serde(rename = "name")]
  name: Option<String>,
  #[serde(rename = "refresh_url")]
  refresh_url: Option<String>,
  #[serde(rename = "reset_url")]
  reset_url: Option<String>,
  /// The time at which the scheduled reset period has elapsed and the token limits were automatically reset to zero.
  #[serde(rename = "scheduled_reset_at")]
  scheduled_reset_at: Option<String>,
  #[serde(rename = "scheduled_reset_period")]
  scheduled_reset_period: Option<String>,
  #[serde(rename = "self_url")]
  self_url: Option<String>,
  #[serde(rename = "slug_perm")]
  slug_perm: Option<String>,
  #[serde(rename = "token")]
  token: Option<String>,
  /// The datetime the token was updated at.
  #[serde(rename = "updated_at")]
  updated_at: Option<String>,
  #[serde(rename = "updated_by")]
  updated_by: Option<String>,
  #[serde(rename = "updated_by_url")]
  updated_by_url: Option<String>,
  #[serde(rename = "usage")]
  usage: Option<String>,
  #[serde(rename = "user")]
  user: Option<String>,
  #[serde(rename = "user_url")]
  user_url: Option<String>
}

impl RepositoryTokenRefresh {
  pub fn new() -> RepositoryTokenRefresh {
    RepositoryTokenRefresh {
      clients: None,
      created_at: None,
      created_by: None,
      created_by_url: None,
      default: None,
      disable_url: None,
      downloads: None,
      enable_url: None,
      eula_accepted: None,
      eula_accepted_at: None,
      eula_accepted_from: None,
      eula_required: None,
      has_limits: None,
      identifier: None,
      is_active: None,
      is_limited: None,
      limit_bandwidth: None,
      limit_bandwidth_unit: None,
      limit_date_range_from: None,
      limit_date_range_to: None,
      limit_num_clients: None,
      limit_num_downloads: None,
      limit_package_query: None,
      limit_path_query: None,
      metadata: None,
      name: None,
      refresh_url: None,
      reset_url: None,
      scheduled_reset_at: None,
      scheduled_reset_period: None,
      self_url: None,
      slug_perm: None,
      token: None,
      updated_at: None,
      updated_by: None,
      updated_by_url: None,
      usage: None,
      user: None,
      user_url: None
    }
  }

  pub fn set_clients(&mut self, clients: i32) {
    self.clients = Some(clients);
  }

  pub fn with_clients(mut self, clients: i32) -> RepositoryTokenRefresh {
    self.clients = Some(clients);
    self
  }

  pub fn clients(&self) -> Option<&i32> {
    self.clients.as_ref()
  }

  pub fn reset_clients(&mut self) {
    self.clients = None;
  }

  pub fn set_created_at(&mut self, created_at: String) {
    self.created_at = Some(created_at);
  }

  pub fn with_created_at(mut self, created_at: String) -> RepositoryTokenRefresh {
    self.created_at = Some(created_at);
    self
  }

  pub fn created_at(&self) -> Option<&String> {
    self.created_at.as_ref()
  }

  pub fn reset_created_at(&mut self) {
    self.created_at = None;
  }

  pub fn set_created_by(&mut self, created_by: String) {
    self.created_by = Some(created_by);
  }

  pub fn with_created_by(mut self, created_by: String) -> RepositoryTokenRefresh {
    self.created_by = Some(created_by);
    self
  }

  pub fn created_by(&self) -> Option<&String> {
    self.created_by.as_ref()
  }

  pub fn reset_created_by(&mut self) {
    self.created_by = None;
  }

  pub fn set_created_by_url(&mut self, created_by_url: String) {
    self.created_by_url = Some(created_by_url);
  }

  pub fn with_created_by_url(mut self, created_by_url: String) -> RepositoryTokenRefresh {
    self.created_by_url = Some(created_by_url);
    self
  }

  pub fn created_by_url(&self) -> Option<&String> {
    self.created_by_url.as_ref()
  }

  pub fn reset_created_by_url(&mut self) {
    self.created_by_url = None;
  }

  pub fn set_default(&mut self, default: bool) {
    self.default = Some(default);
  }

  pub fn with_default(mut self, default: bool) -> RepositoryTokenRefresh {
    self.default = Some(default);
    self
  }

  pub fn default(&self) -> Option<&bool> {
    self.default.as_ref()
  }

  pub fn reset_default(&mut self) {
    self.default = None;
  }

  pub fn set_disable_url(&mut self, disable_url: String) {
    self.disable_url = Some(disable_url);
  }

  pub fn with_disable_url(mut self, disable_url: String) -> RepositoryTokenRefresh {
    self.disable_url = Some(disable_url);
    self
  }

  pub fn disable_url(&self) -> Option<&String> {
    self.disable_url.as_ref()
  }

  pub fn reset_disable_url(&mut self) {
    self.disable_url = None;
  }

  pub fn set_downloads(&mut self, downloads: i32) {
    self.downloads = Some(downloads);
  }

  pub fn with_downloads(mut self, downloads: i32) -> RepositoryTokenRefresh {
    self.downloads = Some(downloads);
    self
  }

  pub fn downloads(&self) -> Option<&i32> {
    self.downloads.as_ref()
  }

  pub fn reset_downloads(&mut self) {
    self.downloads = None;
  }

  pub fn set_enable_url(&mut self, enable_url: String) {
    self.enable_url = Some(enable_url);
  }

  pub fn with_enable_url(mut self, enable_url: String) -> RepositoryTokenRefresh {
    self.enable_url = Some(enable_url);
    self
  }

  pub fn enable_url(&self) -> Option<&String> {
    self.enable_url.as_ref()
  }

  pub fn reset_enable_url(&mut self) {
    self.enable_url = None;
  }

  pub fn set_eula_accepted(&mut self, eula_accepted: ::models::Eula) {
    self.eula_accepted = Some(eula_accepted);
  }

  pub fn with_eula_accepted(mut self, eula_accepted: ::models::Eula) -> RepositoryTokenRefresh {
    self.eula_accepted = Some(eula_accepted);
    self
  }

  pub fn eula_accepted(&self) -> Option<&::models::Eula> {
    self.eula_accepted.as_ref()
  }

  pub fn reset_eula_accepted(&mut self) {
    self.eula_accepted = None;
  }

  pub fn set_eula_accepted_at(&mut self, eula_accepted_at: String) {
    self.eula_accepted_at = Some(eula_accepted_at);
  }

  pub fn with_eula_accepted_at(mut self, eula_accepted_at: String) -> RepositoryTokenRefresh {
    self.eula_accepted_at = Some(eula_accepted_at);
    self
  }

  pub fn eula_accepted_at(&self) -> Option<&String> {
    self.eula_accepted_at.as_ref()
  }

  pub fn reset_eula_accepted_at(&mut self) {
    self.eula_accepted_at = None;
  }

  pub fn set_eula_accepted_from(&mut self, eula_accepted_from: String) {
    self.eula_accepted_from = Some(eula_accepted_from);
  }

  pub fn with_eula_accepted_from(mut self, eula_accepted_from: String) -> RepositoryTokenRefresh {
    self.eula_accepted_from = Some(eula_accepted_from);
    self
  }

  pub fn eula_accepted_from(&self) -> Option<&String> {
    self.eula_accepted_from.as_ref()
  }

  pub fn reset_eula_accepted_from(&mut self) {
    self.eula_accepted_from = None;
  }

  pub fn set_eula_required(&mut self, eula_required: bool) {
    self.eula_required = Some(eula_required);
  }

  pub fn with_eula_required(mut self, eula_required: bool) -> RepositoryTokenRefresh {
    self.eula_required = Some(eula_required);
    self
  }

  pub fn eula_required(&self) -> Option<&bool> {
    self.eula_required.as_ref()
  }

  pub fn reset_eula_required(&mut self) {
    self.eula_required = None;
  }

  pub fn set_has_limits(&mut self, has_limits: bool) {
    self.has_limits = Some(has_limits);
  }

  pub fn with_has_limits(mut self, has_limits: bool) -> RepositoryTokenRefresh {
    self.has_limits = Some(has_limits);
    self
  }

  pub fn has_limits(&self) -> Option<&bool> {
    self.has_limits.as_ref()
  }

  pub fn reset_has_limits(&mut self) {
    self.has_limits = None;
  }

  pub fn set_identifier(&mut self, identifier: i32) {
    self.identifier = Some(identifier);
  }

  pub fn with_identifier(mut self, identifier: i32) -> RepositoryTokenRefresh {
    self.identifier = Some(identifier);
    self
  }

  pub fn identifier(&self) -> Option<&i32> {
    self.identifier.as_ref()
  }

  pub fn reset_identifier(&mut self) {
    self.identifier = None;
  }

  pub fn set_is_active(&mut self, is_active: bool) {
    self.is_active = Some(is_active);
  }

  pub fn with_is_active(mut self, is_active: bool) -> RepositoryTokenRefresh {
    self.is_active = Some(is_active);
    self
  }

  pub fn is_active(&self) -> Option<&bool> {
    self.is_active.as_ref()
  }

  pub fn reset_is_active(&mut self) {
    self.is_active = None;
  }

  pub fn set_is_limited(&mut self, is_limited: bool) {
    self.is_limited = Some(is_limited);
  }

  pub fn with_is_limited(mut self, is_limited: bool) -> RepositoryTokenRefresh {
    self.is_limited = Some(is_limited);
    self
  }

  pub fn is_limited(&self) -> Option<&bool> {
    self.is_limited.as_ref()
  }

  pub fn reset_is_limited(&mut self) {
    self.is_limited = None;
  }

  pub fn set_limit_bandwidth(&mut self, limit_bandwidth: i32) {
    self.limit_bandwidth = Some(limit_bandwidth);
  }

  pub fn with_limit_bandwidth(mut self, limit_bandwidth: i32) -> RepositoryTokenRefresh {
    self.limit_bandwidth = Some(limit_bandwidth);
    self
  }

  pub fn limit_bandwidth(&self) -> Option<&i32> {
    self.limit_bandwidth.as_ref()
  }

  pub fn reset_limit_bandwidth(&mut self) {
    self.limit_bandwidth = None;
  }

  pub fn set_limit_bandwidth_unit(&mut self, limit_bandwidth_unit: String) {
    self.limit_bandwidth_unit = Some(limit_bandwidth_unit);
  }

  pub fn with_limit_bandwidth_unit(mut self, limit_bandwidth_unit: String) -> RepositoryTokenRefresh {
    self.limit_bandwidth_unit = Some(limit_bandwidth_unit);
    self
  }

  pub fn limit_bandwidth_unit(&self) -> Option<&String> {
    self.limit_bandwidth_unit.as_ref()
  }

  pub fn reset_limit_bandwidth_unit(&mut self) {
    self.limit_bandwidth_unit = None;
  }

  pub fn set_limit_date_range_from(&mut self, limit_date_range_from: String) {
    self.limit_date_range_from = Some(limit_date_range_from);
  }

  pub fn with_limit_date_range_from(mut self, limit_date_range_from: String) -> RepositoryTokenRefresh {
    self.limit_date_range_from = Some(limit_date_range_from);
    self
  }

  pub fn limit_date_range_from(&self) -> Option<&String> {
    self.limit_date_range_from.as_ref()
  }

  pub fn reset_limit_date_range_from(&mut self) {
    self.limit_date_range_from = None;
  }

  pub fn set_limit_date_range_to(&mut self, limit_date_range_to: String) {
    self.limit_date_range_to = Some(limit_date_range_to);
  }

  pub fn with_limit_date_range_to(mut self, limit_date_range_to: String) -> RepositoryTokenRefresh {
    self.limit_date_range_to = Some(limit_date_range_to);
    self
  }

  pub fn limit_date_range_to(&self) -> Option<&String> {
    self.limit_date_range_to.as_ref()
  }

  pub fn reset_limit_date_range_to(&mut self) {
    self.limit_date_range_to = None;
  }

  pub fn set_limit_num_clients(&mut self, limit_num_clients: i32) {
    self.limit_num_clients = Some(limit_num_clients);
  }

  pub fn with_limit_num_clients(mut self, limit_num_clients: i32) -> RepositoryTokenRefresh {
    self.limit_num_clients = Some(limit_num_clients);
    self
  }

  pub fn limit_num_clients(&self) -> Option<&i32> {
    self.limit_num_clients.as_ref()
  }

  pub fn reset_limit_num_clients(&mut self) {
    self.limit_num_clients = None;
  }

  pub fn set_limit_num_downloads(&mut self, limit_num_downloads: i32) {
    self.limit_num_downloads = Some(limit_num_downloads);
  }

  pub fn with_limit_num_downloads(mut self, limit_num_downloads: i32) -> RepositoryTokenRefresh {
    self.limit_num_downloads = Some(limit_num_downloads);
    self
  }

  pub fn limit_num_downloads(&self) -> Option<&i32> {
    self.limit_num_downloads.as_ref()
  }

  pub fn reset_limit_num_downloads(&mut self) {
    self.limit_num_downloads = None;
  }

  pub fn set_limit_package_query(&mut self, limit_package_query: String) {
    self.limit_package_query = Some(limit_package_query);
  }

  pub fn with_limit_package_query(mut self, limit_package_query: String) -> RepositoryTokenRefresh {
    self.limit_package_query = Some(limit_package_query);
    self
  }

  pub fn limit_package_query(&self) -> Option<&String> {
    self.limit_package_query.as_ref()
  }

  pub fn reset_limit_package_query(&mut self) {
    self.limit_package_query = None;
  }

  pub fn set_limit_path_query(&mut self, limit_path_query: String) {
    self.limit_path_query = Some(limit_path_query);
  }

  pub fn with_limit_path_query(mut self, limit_path_query: String) -> RepositoryTokenRefresh {
    self.limit_path_query = Some(limit_path_query);
    self
  }

  pub fn limit_path_query(&self) -> Option<&String> {
    self.limit_path_query.as_ref()
  }

  pub fn reset_limit_path_query(&mut self) {
    self.limit_path_query = None;
  }

  pub fn set_metadata(&mut self, metadata: Value) {
    self.metadata = Some(metadata);
  }

  pub fn with_metadata(mut self, metadata: Value) -> RepositoryTokenRefresh {
    self.metadata = Some(metadata);
    self
  }

  pub fn metadata(&self) -> Option<&Value> {
    self.metadata.as_ref()
  }

  pub fn reset_metadata(&mut self) {
    self.metadata = None;
  }

  pub fn set_name(&mut self, name: String) {
    self.name = Some(name);
  }

  pub fn with_name(mut self, name: String) -> RepositoryTokenRefresh {
    self.name = Some(name);
    self
  }

  pub fn name(&self) -> Option<&String> {
    self.name.as_ref()
  }

  pub fn reset_name(&mut self) {
    self.name = None;
  }

  pub fn set_refresh_url(&mut self, refresh_url: String) {
    self.refresh_url = Some(refresh_url);
  }

  pub fn with_refresh_url(mut self, refresh_url: String) -> RepositoryTokenRefresh {
    self.refresh_url = Some(refresh_url);
    self
  }

  pub fn refresh_url(&self) -> Option<&String> {
    self.refresh_url.as_ref()
  }

  pub fn reset_refresh_url(&mut self) {
    self.refresh_url = None;
  }

  pub fn set_reset_url(&mut self, reset_url: String) {
    self.reset_url = Some(reset_url);
  }

  pub fn with_reset_url(mut self, reset_url: String) -> RepositoryTokenRefresh {
    self.reset_url = Some(reset_url);
    self
  }

  pub fn reset_url(&self) -> Option<&String> {
    self.reset_url.as_ref()
  }

  pub fn reset_reset_url(&mut self) {
    self.reset_url = None;
  }

  pub fn set_scheduled_reset_at(&mut self, scheduled_reset_at: String) {
    self.scheduled_reset_at = Some(scheduled_reset_at);
  }

  pub fn with_scheduled_reset_at(mut self, scheduled_reset_at: String) -> RepositoryTokenRefresh {
    self.scheduled_reset_at = Some(scheduled_reset_at);
    self
  }

  pub fn scheduled_reset_at(&self) -> Option<&String> {
    self.scheduled_reset_at.as_ref()
  }

  pub fn reset_scheduled_reset_at(&mut self) {
    self.scheduled_reset_at = None;
  }

  pub fn set_scheduled_reset_period(&mut self, scheduled_reset_period: String) {
    self.scheduled_reset_period = Some(scheduled_reset_period);
  }

  pub fn with_scheduled_reset_period(mut self, scheduled_reset_period: String) -> RepositoryTokenRefresh {
    self.scheduled_reset_period = Some(scheduled_reset_period);
    self
  }

  pub fn scheduled_reset_period(&self) -> Option<&String> {
    self.scheduled_reset_period.as_ref()
  }

  pub fn reset_scheduled_reset_period(&mut self) {
    self.scheduled_reset_period = None;
  }

  pub fn set_self_url(&mut self, self_url: String) {
    self.self_url = Some(self_url);
  }

  pub fn with_self_url(mut self, self_url: String) -> RepositoryTokenRefresh {
    self.self_url = Some(self_url);
    self
  }

  pub fn self_url(&self) -> Option<&String> {
    self.self_url.as_ref()
  }

  pub fn reset_self_url(&mut self) {
    self.self_url = None;
  }

  pub fn set_slug_perm(&mut self, slug_perm: String) {
    self.slug_perm = Some(slug_perm);
  }

  pub fn with_slug_perm(mut self, slug_perm: String) -> RepositoryTokenRefresh {
    self.slug_perm = Some(slug_perm);
    self
  }

  pub fn slug_perm(&self) -> Option<&String> {
    self.slug_perm.as_ref()
  }

  pub fn reset_slug_perm(&mut self) {
    self.slug_perm = None;
  }

  pub fn set_token(&mut self, token: String) {
    self.token = Some(token);
  }

  pub fn with_token(mut self, token: String) -> RepositoryTokenRefresh {
    self.token = Some(token);
    self
  }

  pub fn token(&self) -> Option<&String> {
    self.token.as_ref()
  }

  pub fn reset_token(&mut self) {
    self.token = None;
  }

  pub fn set_updated_at(&mut self, updated_at: String) {
    self.updated_at = Some(updated_at);
  }

  pub fn with_updated_at(mut self, updated_at: String) -> RepositoryTokenRefresh {
    self.updated_at = Some(updated_at);
    self
  }

  pub fn updated_at(&self) -> Option<&String> {
    self.updated_at.as_ref()
  }

  pub fn reset_updated_at(&mut self) {
    self.updated_at = None;
  }

  pub fn set_updated_by(&mut self, updated_by: String) {
    self.updated_by = Some(updated_by);
  }

  pub fn with_updated_by(mut self, updated_by: String) -> RepositoryTokenRefresh {
    self.updated_by = Some(updated_by);
    self
  }

  pub fn updated_by(&self) -> Option<&String> {
    self.updated_by.as_ref()
  }

  pub fn reset_updated_by(&mut self) {
    self.updated_by = None;
  }

  pub fn set_updated_by_url(&mut self, updated_by_url: String) {
    self.updated_by_url = Some(updated_by_url);
  }

  pub fn with_updated_by_url(mut self, updated_by_url: String) -> RepositoryTokenRefresh {
    self.updated_by_url = Some(updated_by_url);
    self
  }

  pub fn updated_by_url(&self) -> Option<&String> {
    self.updated_by_url.as_ref()
  }

  pub fn reset_updated_by_url(&mut self) {
    self.updated_by_url = None;
  }

  pub fn set_usage(&mut self, usage: String) {
    self.usage = Some(usage);
  }

  pub fn with_usage(mut self, usage: String) -> RepositoryTokenRefresh {
    self.usage = Some(usage);
    self
  }

  pub fn usage(&self) -> Option<&String> {
    self.usage.as_ref()
  }

  pub fn reset_usage(&mut self) {
    self.usage = None;
  }

  pub fn set_user(&mut self, user: String) {
    self.user = Some(user);
  }

  pub fn with_user(mut self, user: String) -> RepositoryTokenRefresh {
    self.user = Some(user);
    self
  }

  pub fn user(&self) -> Option<&String> {
    self.user.as_ref()
  }

  pub fn reset_user(&mut self) {
    self.user = None;
  }

  pub fn set_user_url(&mut self, user_url: String) {
    self.user_url = Some(user_url);
  }

  pub fn with_user_url(mut self, user_url: String) -> RepositoryTokenRefresh {
    self.user_url = Some(user_url);
    self
  }

  pub fn user_url(&self) -> Option<&String> {
    self.user_url.as_ref()
  }

  pub fn reset_user_url(&mut self) {
    self.user_url = None;
  }

}



