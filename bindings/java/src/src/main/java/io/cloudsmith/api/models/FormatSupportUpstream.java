/*
 * Cloudsmith API (v1)
 * The API to the Cloudsmith Service
 *
 * OpenAPI spec version: v1
 * Contact: support@cloudsmith.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.cloudsmith.api.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.io.Serializable;
import javax.validation.constraints.*;
import javax.validation.Valid;

/**
 * The upstream support for the package format
 */
@ApiModel(description = "The upstream support for the package format")

public class FormatSupportUpstream implements Serializable {
  private static final long serialVersionUID = 1L;

  /**
   * Gets or Sets authModes
   */
  @JsonAdapter(AuthModesEnum.Adapter.class)
  public enum AuthModesEnum {
    USERNAME_AND_PASSWORD("Username and Password"),
    
    TOKEN("Token"),
    
    CERTIFICATE_AND_KEY("Certificate and Key");

    private String value;

    AuthModesEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AuthModesEnum fromValue(String text) {
      for (AuthModesEnum b : AuthModesEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<AuthModesEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AuthModesEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AuthModesEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return AuthModesEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("auth_modes")
  private List<AuthModesEnum> authModes = new ArrayList<>();

  @SerializedName("caching")
  private Boolean caching = null;

  @SerializedName("indexing")
  private Boolean indexing = null;

  /**
   * The behavior of the upstream when indexing
   */
  @JsonAdapter(IndexingBehaviorEnum.Adapter.class)
  public enum IndexingBehaviorEnum {
    UNSUPPORTED("Unsupported"),
    
    AHEAD_OF_TIME_STATIC_INDEXING("Ahead-of-time (static) indexing"),
    
    JUST_IN_TIME_DYNAMIC_INDEXING("Just-in-time (dynamic) indexing");

    private String value;

    IndexingBehaviorEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static IndexingBehaviorEnum fromValue(String text) {
      for (IndexingBehaviorEnum b : IndexingBehaviorEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<IndexingBehaviorEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final IndexingBehaviorEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public IndexingBehaviorEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return IndexingBehaviorEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("indexing_behavior")
  private IndexingBehaviorEnum indexingBehavior = IndexingBehaviorEnum.UNSUPPORTED;

  @SerializedName("proxying")
  private Boolean proxying = null;

  /**
   * The signature verification supported by the upstream format
   */
  @JsonAdapter(SignatureVerificationEnum.Adapter.class)
  public enum SignatureVerificationEnum {
    UNSUPPORTED("Unsupported"),
    
    REPOSITORY_METADATA("Repository Metadata"),
    
    PACKAGES("Packages"),
    
    REPOSITORY_METADATA_AND_PACKAGES("Repository Metadata and Packages");

    private String value;

    SignatureVerificationEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SignatureVerificationEnum fromValue(String text) {
      for (SignatureVerificationEnum b : SignatureVerificationEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<SignatureVerificationEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SignatureVerificationEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SignatureVerificationEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return SignatureVerificationEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("signature_verification")
  private SignatureVerificationEnum signatureVerification = SignatureVerificationEnum.UNSUPPORTED;

  public FormatSupportUpstream authModes(List<AuthModesEnum> authModes) {
    this.authModes = authModes;
    return this;
  }

  public FormatSupportUpstream addAuthModesItem(AuthModesEnum authModesItem) {
    this.authModes.add(authModesItem);
    return this;
  }

   /**
   * The authentication modes supported by the upstream format
   * @return authModes
  **/
  @NotNull
  @ApiModelProperty(required = true, value = "The authentication modes supported by the upstream format")
  public List<AuthModesEnum> getAuthModes() {
    return authModes;
  }

  public void setAuthModes(List<AuthModesEnum> authModes) {
    this.authModes = authModes;
  }

  public FormatSupportUpstream caching(Boolean caching) {
    this.caching = caching;
    return this;
  }

   /**
   * If true the upstream format supports caching
   * @return caching
  **/
  @NotNull
  @ApiModelProperty(required = true, value = "If true the upstream format supports caching")
  public Boolean isCaching() {
    return caching;
  }

  public void setCaching(Boolean caching) {
    this.caching = caching;
  }

  public FormatSupportUpstream indexing(Boolean indexing) {
    this.indexing = indexing;
    return this;
  }

   /**
   * If true the upstream format supports indexing
   * @return indexing
  **/
  @NotNull
  @ApiModelProperty(required = true, value = "If true the upstream format supports indexing")
  public Boolean isIndexing() {
    return indexing;
  }

  public void setIndexing(Boolean indexing) {
    this.indexing = indexing;
  }

  public FormatSupportUpstream indexingBehavior(IndexingBehaviorEnum indexingBehavior) {
    this.indexingBehavior = indexingBehavior;
    return this;
  }

   /**
   * The behavior of the upstream when indexing
   * @return indexingBehavior
  **/
  @ApiModelProperty(value = "The behavior of the upstream when indexing")
  public IndexingBehaviorEnum getIndexingBehavior() {
    return indexingBehavior;
  }

  public void setIndexingBehavior(IndexingBehaviorEnum indexingBehavior) {
    this.indexingBehavior = indexingBehavior;
  }

  public FormatSupportUpstream proxying(Boolean proxying) {
    this.proxying = proxying;
    return this;
  }

   /**
   * If true the upstream format supports proxying
   * @return proxying
  **/
  @NotNull
  @ApiModelProperty(required = true, value = "If true the upstream format supports proxying")
  public Boolean isProxying() {
    return proxying;
  }

  public void setProxying(Boolean proxying) {
    this.proxying = proxying;
  }

  public FormatSupportUpstream signatureVerification(SignatureVerificationEnum signatureVerification) {
    this.signatureVerification = signatureVerification;
    return this;
  }

   /**
   * The signature verification supported by the upstream format
   * @return signatureVerification
  **/
  @ApiModelProperty(value = "The signature verification supported by the upstream format")
  public SignatureVerificationEnum getSignatureVerification() {
    return signatureVerification;
  }

  public void setSignatureVerification(SignatureVerificationEnum signatureVerification) {
    this.signatureVerification = signatureVerification;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FormatSupportUpstream formatSupportUpstream = (FormatSupportUpstream) o;
    return Objects.equals(this.authModes, formatSupportUpstream.authModes) &&
        Objects.equals(this.caching, formatSupportUpstream.caching) &&
        Objects.equals(this.indexing, formatSupportUpstream.indexing) &&
        Objects.equals(this.indexingBehavior, formatSupportUpstream.indexingBehavior) &&
        Objects.equals(this.proxying, formatSupportUpstream.proxying) &&
        Objects.equals(this.signatureVerification, formatSupportUpstream.signatureVerification);
  }

  @Override
  public int hashCode() {
    return Objects.hash(authModes, caching, indexing, indexingBehavior, proxying, signatureVerification);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FormatSupportUpstream {\n");
    
    sb.append("    authModes: ").append(toIndentedString(authModes)).append("\n");
    sb.append("    caching: ").append(toIndentedString(caching)).append("\n");
    sb.append("    indexing: ").append(toIndentedString(indexing)).append("\n");
    sb.append("    indexingBehavior: ").append(toIndentedString(indexingBehavior)).append("\n");
    sb.append("    proxying: ").append(toIndentedString(proxying)).append("\n");
    sb.append("    signatureVerification: ").append(toIndentedString(signatureVerification)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

