/*
 * Cloudsmith API
 * The API to the Cloudsmith Service
 *
 * OpenAPI spec version: v1
 * Contact: support@cloudsmith.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.cloudsmith.api.models;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.io.Serializable;
import javax.validation.constraints.*;
import javax.validation.Valid;

/**
 * RepositoryTokenSyncTokens
 */

public class RepositoryTokenSyncTokens implements Serializable {
  private static final long serialVersionUID = 1L;

  @SerializedName("created_at")
  private String createdAt = null;

  @SerializedName("created_by")
  private String createdBy = null;

  @SerializedName("created_by_url")
  private String createdByUrl = null;

  @SerializedName("default")
  private Boolean _default = null;

  @SerializedName("has_limits")
  private String hasLimits = null;

  @SerializedName("identifier")
  private Integer identifier = null;

  @SerializedName("is_active")
  private Boolean isActive = null;

  @SerializedName("is_limited")
  private String isLimited = null;

  @SerializedName("limit_date_range_from")
  private String limitDateRangeFrom = null;

  @SerializedName("limit_date_range_to")
  private String limitDateRangeTo = null;

  @SerializedName("limit_num_clients")
  private Integer limitNumClients = null;

  @SerializedName("limit_num_downloads")
  private Integer limitNumDownloads = null;

  @SerializedName("limit_package_query")
  private String limitPackageQuery = null;

  @SerializedName("limit_path_query")
  private String limitPathQuery = null;

  @SerializedName("metadata")
  private String metadata = null;

  @SerializedName("name")
  private String name = null;

  @SerializedName("refresh_url")
  private String refreshUrl = null;

  @SerializedName("self_url")
  private String selfUrl = null;

  @SerializedName("slug_perm")
  private String slugPerm = null;

  @SerializedName("token")
  private String token = null;

  @SerializedName("updated_at")
  private String updatedAt = null;

  @SerializedName("updated_by")
  private String updatedBy = null;

  @SerializedName("updated_by_url")
  private String updatedByUrl = null;

  @SerializedName("user")
  private String user = null;

  @SerializedName("user_url")
  private String userUrl = null;

  public RepositoryTokenSyncTokens createdAt(String createdAt) {
    this.createdAt = createdAt;
    return this;
  }

   /**
   * The datetime the token was updated at.
   * @return createdAt
  **/
  @ApiModelProperty(value = "The datetime the token was updated at.")
  public String getCreatedAt() {
    return createdAt;
  }

  public void setCreatedAt(String createdAt) {
    this.createdAt = createdAt;
  }

  public RepositoryTokenSyncTokens createdBy(String createdBy) {
    this.createdBy = createdBy;
    return this;
  }

   /**
   * 
   * @return createdBy
  **/
  @ApiModelProperty(value = "")
  public String getCreatedBy() {
    return createdBy;
  }

  public void setCreatedBy(String createdBy) {
    this.createdBy = createdBy;
  }

  public RepositoryTokenSyncTokens createdByUrl(String createdByUrl) {
    this.createdByUrl = createdByUrl;
    return this;
  }

   /**
   * 
   * @return createdByUrl
  **/
  @ApiModelProperty(value = "")
  public String getCreatedByUrl() {
    return createdByUrl;
  }

  public void setCreatedByUrl(String createdByUrl) {
    this.createdByUrl = createdByUrl;
  }

  public RepositoryTokenSyncTokens _default(Boolean _default) {
    this._default = _default;
    return this;
  }

   /**
   * If selected this is the default token for this repository.
   * @return _default
  **/
  @ApiModelProperty(value = "If selected this is the default token for this repository.")
  public Boolean getDefault() {
    return _default;
  }

  public void setDefault(Boolean _default) {
    this._default = _default;
  }

  public RepositoryTokenSyncTokens hasLimits(String hasLimits) {
    this.hasLimits = hasLimits;
    return this;
  }

   /**
   * 
   * @return hasLimits
  **/
  @ApiModelProperty(value = "")
  public String getHasLimits() {
    return hasLimits;
  }

  public void setHasLimits(String hasLimits) {
    this.hasLimits = hasLimits;
  }

  public RepositoryTokenSyncTokens identifier(Integer identifier) {
    this.identifier = identifier;
    return this;
  }

   /**
   * 
   * @return identifier
  **/
  @ApiModelProperty(value = "")
  public Integer getIdentifier() {
    return identifier;
  }

  public void setIdentifier(Integer identifier) {
    this.identifier = identifier;
  }

  public RepositoryTokenSyncTokens isActive(Boolean isActive) {
    this.isActive = isActive;
    return this;
  }

   /**
   * If enabled, the token will allow downloads based on configured restrictions (if any).
   * @return isActive
  **/
  @ApiModelProperty(value = "If enabled, the token will allow downloads based on configured restrictions (if any).")
  public Boolean getIsActive() {
    return isActive;
  }

  public void setIsActive(Boolean isActive) {
    this.isActive = isActive;
  }

  public RepositoryTokenSyncTokens isLimited(String isLimited) {
    this.isLimited = isLimited;
    return this;
  }

   /**
   * 
   * @return isLimited
  **/
  @ApiModelProperty(value = "")
  public String getIsLimited() {
    return isLimited;
  }

  public void setIsLimited(String isLimited) {
    this.isLimited = isLimited;
  }

  public RepositoryTokenSyncTokens limitDateRangeFrom(String limitDateRangeFrom) {
    this.limitDateRangeFrom = limitDateRangeFrom;
    return this;
  }

   /**
   * The starting date/time the token is allowed to be used from.
   * @return limitDateRangeFrom
  **/
  @ApiModelProperty(value = "The starting date/time the token is allowed to be used from.")
  public String getLimitDateRangeFrom() {
    return limitDateRangeFrom;
  }

  public void setLimitDateRangeFrom(String limitDateRangeFrom) {
    this.limitDateRangeFrom = limitDateRangeFrom;
  }

  public RepositoryTokenSyncTokens limitDateRangeTo(String limitDateRangeTo) {
    this.limitDateRangeTo = limitDateRangeTo;
    return this;
  }

   /**
   * The ending date/time the token is allowed to be used until.
   * @return limitDateRangeTo
  **/
  @ApiModelProperty(value = "The ending date/time the token is allowed to be used until.")
  public String getLimitDateRangeTo() {
    return limitDateRangeTo;
  }

  public void setLimitDateRangeTo(String limitDateRangeTo) {
    this.limitDateRangeTo = limitDateRangeTo;
  }

  public RepositoryTokenSyncTokens limitNumClients(Integer limitNumClients) {
    this.limitNumClients = limitNumClients;
    return this;
  }

   /**
   * The maximum number of unique clients allowed for the token. Please note that since clients are calculated asynchronously (after the download happens), the limit may not be imposed immediately but at a later point.
   * @return limitNumClients
  **/
  @ApiModelProperty(value = "The maximum number of unique clients allowed for the token. Please note that since clients are calculated asynchronously (after the download happens), the limit may not be imposed immediately but at a later point.")
  public Integer getLimitNumClients() {
    return limitNumClients;
  }

  public void setLimitNumClients(Integer limitNumClients) {
    this.limitNumClients = limitNumClients;
  }

  public RepositoryTokenSyncTokens limitNumDownloads(Integer limitNumDownloads) {
    this.limitNumDownloads = limitNumDownloads;
    return this;
  }

   /**
   * The maximum number of downloads allowed for the token. Please note that since downloads are calculated asynchronously (after the download happens), the limit may not be imposed immediately but at a later point.
   * @return limitNumDownloads
  **/
  @ApiModelProperty(value = "The maximum number of downloads allowed for the token. Please note that since downloads are calculated asynchronously (after the download happens), the limit may not be imposed immediately but at a later point.")
  public Integer getLimitNumDownloads() {
    return limitNumDownloads;
  }

  public void setLimitNumDownloads(Integer limitNumDownloads) {
    this.limitNumDownloads = limitNumDownloads;
  }

  public RepositoryTokenSyncTokens limitPackageQuery(String limitPackageQuery) {
    this.limitPackageQuery = limitPackageQuery;
    return this;
  }

   /**
   * The package-based search query to apply to restrict downloads to. This uses the same syntax as the standard search used for repositories, and also supports boolean logic operators such as OR/AND/NOT and parentheses for grouping. This will still allow access to non-package files, such as metadata. For package formats that support dynamic metadata indexes, the contents of the metadata will also be filtered.
   * @return limitPackageQuery
  **/
  @ApiModelProperty(value = "The package-based search query to apply to restrict downloads to. This uses the same syntax as the standard search used for repositories, and also supports boolean logic operators such as OR/AND/NOT and parentheses for grouping. This will still allow access to non-package files, such as metadata. For package formats that support dynamic metadata indexes, the contents of the metadata will also be filtered.")
  public String getLimitPackageQuery() {
    return limitPackageQuery;
  }

  public void setLimitPackageQuery(String limitPackageQuery) {
    this.limitPackageQuery = limitPackageQuery;
  }

  public RepositoryTokenSyncTokens limitPathQuery(String limitPathQuery) {
    this.limitPathQuery = limitPathQuery;
    return this;
  }

   /**
   * The path-based search query to apply to restrict downloads to. This supports boolean logic operators such as OR/AND/NOT and parentheses for grouping. The path evaluated does not include the domain name, the namespace, the entitlement code used, the package format, etc. and it always starts with a forward slash.
   * @return limitPathQuery
  **/
  @ApiModelProperty(value = "The path-based search query to apply to restrict downloads to. This supports boolean logic operators such as OR/AND/NOT and parentheses for grouping. The path evaluated does not include the domain name, the namespace, the entitlement code used, the package format, etc. and it always starts with a forward slash.")
  public String getLimitPathQuery() {
    return limitPathQuery;
  }

  public void setLimitPathQuery(String limitPathQuery) {
    this.limitPathQuery = limitPathQuery;
  }

  public RepositoryTokenSyncTokens metadata(String metadata) {
    this.metadata = metadata;
    return this;
  }

   /**
   * 
   * @return metadata
  **/
  @ApiModelProperty(value = "")
  public String getMetadata() {
    return metadata;
  }

  public void setMetadata(String metadata) {
    this.metadata = metadata;
  }

  public RepositoryTokenSyncTokens name(String name) {
    this.name = name;
    return this;
  }

   /**
   * 
   * @return name
  **/
  @ApiModelProperty(value = "")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public RepositoryTokenSyncTokens refreshUrl(String refreshUrl) {
    this.refreshUrl = refreshUrl;
    return this;
  }

   /**
   * 
   * @return refreshUrl
  **/
  @ApiModelProperty(value = "")
  public String getRefreshUrl() {
    return refreshUrl;
  }

  public void setRefreshUrl(String refreshUrl) {
    this.refreshUrl = refreshUrl;
  }

  public RepositoryTokenSyncTokens selfUrl(String selfUrl) {
    this.selfUrl = selfUrl;
    return this;
  }

   /**
   * 
   * @return selfUrl
  **/
  @ApiModelProperty(value = "")
  public String getSelfUrl() {
    return selfUrl;
  }

  public void setSelfUrl(String selfUrl) {
    this.selfUrl = selfUrl;
  }

  public RepositoryTokenSyncTokens slugPerm(String slugPerm) {
    this.slugPerm = slugPerm;
    return this;
  }

   /**
   * 
   * @return slugPerm
  **/
  @ApiModelProperty(value = "")
  public String getSlugPerm() {
    return slugPerm;
  }

  public void setSlugPerm(String slugPerm) {
    this.slugPerm = slugPerm;
  }

  public RepositoryTokenSyncTokens token(String token) {
    this.token = token;
    return this;
  }

   /**
   * 
   * @return token
  **/
  @ApiModelProperty(value = "")
  public String getToken() {
    return token;
  }

  public void setToken(String token) {
    this.token = token;
  }

  public RepositoryTokenSyncTokens updatedAt(String updatedAt) {
    this.updatedAt = updatedAt;
    return this;
  }

   /**
   * The datetime the token was updated at.
   * @return updatedAt
  **/
  @ApiModelProperty(value = "The datetime the token was updated at.")
  public String getUpdatedAt() {
    return updatedAt;
  }

  public void setUpdatedAt(String updatedAt) {
    this.updatedAt = updatedAt;
  }

  public RepositoryTokenSyncTokens updatedBy(String updatedBy) {
    this.updatedBy = updatedBy;
    return this;
  }

   /**
   * 
   * @return updatedBy
  **/
  @ApiModelProperty(value = "")
  public String getUpdatedBy() {
    return updatedBy;
  }

  public void setUpdatedBy(String updatedBy) {
    this.updatedBy = updatedBy;
  }

  public RepositoryTokenSyncTokens updatedByUrl(String updatedByUrl) {
    this.updatedByUrl = updatedByUrl;
    return this;
  }

   /**
   * 
   * @return updatedByUrl
  **/
  @ApiModelProperty(value = "")
  public String getUpdatedByUrl() {
    return updatedByUrl;
  }

  public void setUpdatedByUrl(String updatedByUrl) {
    this.updatedByUrl = updatedByUrl;
  }

  public RepositoryTokenSyncTokens user(String user) {
    this.user = user;
    return this;
  }

   /**
   * 
   * @return user
  **/
  @ApiModelProperty(value = "")
  public String getUser() {
    return user;
  }

  public void setUser(String user) {
    this.user = user;
  }

  public RepositoryTokenSyncTokens userUrl(String userUrl) {
    this.userUrl = userUrl;
    return this;
  }

   /**
   * 
   * @return userUrl
  **/
  @ApiModelProperty(value = "")
  public String getUserUrl() {
    return userUrl;
  }

  public void setUserUrl(String userUrl) {
    this.userUrl = userUrl;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RepositoryTokenSyncTokens repositoryTokenSyncTokens = (RepositoryTokenSyncTokens) o;
    return Objects.equals(this.createdAt, repositoryTokenSyncTokens.createdAt) &&
        Objects.equals(this.createdBy, repositoryTokenSyncTokens.createdBy) &&
        Objects.equals(this.createdByUrl, repositoryTokenSyncTokens.createdByUrl) &&
        Objects.equals(this._default, repositoryTokenSyncTokens._default) &&
        Objects.equals(this.hasLimits, repositoryTokenSyncTokens.hasLimits) &&
        Objects.equals(this.identifier, repositoryTokenSyncTokens.identifier) &&
        Objects.equals(this.isActive, repositoryTokenSyncTokens.isActive) &&
        Objects.equals(this.isLimited, repositoryTokenSyncTokens.isLimited) &&
        Objects.equals(this.limitDateRangeFrom, repositoryTokenSyncTokens.limitDateRangeFrom) &&
        Objects.equals(this.limitDateRangeTo, repositoryTokenSyncTokens.limitDateRangeTo) &&
        Objects.equals(this.limitNumClients, repositoryTokenSyncTokens.limitNumClients) &&
        Objects.equals(this.limitNumDownloads, repositoryTokenSyncTokens.limitNumDownloads) &&
        Objects.equals(this.limitPackageQuery, repositoryTokenSyncTokens.limitPackageQuery) &&
        Objects.equals(this.limitPathQuery, repositoryTokenSyncTokens.limitPathQuery) &&
        Objects.equals(this.metadata, repositoryTokenSyncTokens.metadata) &&
        Objects.equals(this.name, repositoryTokenSyncTokens.name) &&
        Objects.equals(this.refreshUrl, repositoryTokenSyncTokens.refreshUrl) &&
        Objects.equals(this.selfUrl, repositoryTokenSyncTokens.selfUrl) &&
        Objects.equals(this.slugPerm, repositoryTokenSyncTokens.slugPerm) &&
        Objects.equals(this.token, repositoryTokenSyncTokens.token) &&
        Objects.equals(this.updatedAt, repositoryTokenSyncTokens.updatedAt) &&
        Objects.equals(this.updatedBy, repositoryTokenSyncTokens.updatedBy) &&
        Objects.equals(this.updatedByUrl, repositoryTokenSyncTokens.updatedByUrl) &&
        Objects.equals(this.user, repositoryTokenSyncTokens.user) &&
        Objects.equals(this.userUrl, repositoryTokenSyncTokens.userUrl);
  }

  @Override
  public int hashCode() {
    return Objects.hash(createdAt, createdBy, createdByUrl, _default, hasLimits, identifier, isActive, isLimited, limitDateRangeFrom, limitDateRangeTo, limitNumClients, limitNumDownloads, limitPackageQuery, limitPathQuery, metadata, name, refreshUrl, selfUrl, slugPerm, token, updatedAt, updatedBy, updatedByUrl, user, userUrl);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RepositoryTokenSyncTokens {\n");
    
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    createdBy: ").append(toIndentedString(createdBy)).append("\n");
    sb.append("    createdByUrl: ").append(toIndentedString(createdByUrl)).append("\n");
    sb.append("    _default: ").append(toIndentedString(_default)).append("\n");
    sb.append("    hasLimits: ").append(toIndentedString(hasLimits)).append("\n");
    sb.append("    identifier: ").append(toIndentedString(identifier)).append("\n");
    sb.append("    isActive: ").append(toIndentedString(isActive)).append("\n");
    sb.append("    isLimited: ").append(toIndentedString(isLimited)).append("\n");
    sb.append("    limitDateRangeFrom: ").append(toIndentedString(limitDateRangeFrom)).append("\n");
    sb.append("    limitDateRangeTo: ").append(toIndentedString(limitDateRangeTo)).append("\n");
    sb.append("    limitNumClients: ").append(toIndentedString(limitNumClients)).append("\n");
    sb.append("    limitNumDownloads: ").append(toIndentedString(limitNumDownloads)).append("\n");
    sb.append("    limitPackageQuery: ").append(toIndentedString(limitPackageQuery)).append("\n");
    sb.append("    limitPathQuery: ").append(toIndentedString(limitPathQuery)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    refreshUrl: ").append(toIndentedString(refreshUrl)).append("\n");
    sb.append("    selfUrl: ").append(toIndentedString(selfUrl)).append("\n");
    sb.append("    slugPerm: ").append(toIndentedString(slugPerm)).append("\n");
    sb.append("    token: ").append(toIndentedString(token)).append("\n");
    sb.append("    updatedAt: ").append(toIndentedString(updatedAt)).append("\n");
    sb.append("    updatedBy: ").append(toIndentedString(updatedBy)).append("\n");
    sb.append("    updatedByUrl: ").append(toIndentedString(updatedByUrl)).append("\n");
    sb.append("    user: ").append(toIndentedString(user)).append("\n");
    sb.append("    userUrl: ").append(toIndentedString(userUrl)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
  
}

