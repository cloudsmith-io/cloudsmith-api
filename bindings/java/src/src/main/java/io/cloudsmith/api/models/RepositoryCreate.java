/*
 * Cloudsmith API
 * The API to the Cloudsmith Service
 *
 * OpenAPI spec version: v1
 * Contact: support@cloudsmith.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.cloudsmith.api.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.cloudsmith.api.models.ReposGpgKeys;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.io.Serializable;
import javax.validation.constraints.*;
import javax.validation.Valid;

/**
 * RepositoryCreate
 */

public class RepositoryCreate implements Serializable {
  private static final long serialVersionUID = 1L;

  @SerializedName("cdn_url")
  private String cdnUrl = null;

  /**
   * The repository content kind determines whether this repository contains packages, or provides a distribution of packages from other repositories. You can only select the content kind at repository creation time.
   */
  @JsonAdapter(ContentKindEnum.Adapter.class)
  public enum ContentKindEnum {
    STANDARD("Standard"),
    
    DISTRIBUTION("Distribution"),
    
    UPSTREAM("Upstream");

    private String value;

    ContentKindEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ContentKindEnum fromValue(String text) {
      for (ContentKindEnum b : ContentKindEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ContentKindEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ContentKindEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ContentKindEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ContentKindEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("content_kind")
  private ContentKindEnum contentKind = null;

  @SerializedName("contextual_auth_realm")
  private Boolean contextualAuthRealm = null;

  @SerializedName("copy_own")
  private Boolean copyOwn = null;

  /**
   * This defines the minimum level of privilege required for a user to copy packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific copy setting.
   */
  @JsonAdapter(CopyPackagesEnum.Adapter.class)
  public enum CopyPackagesEnum {
    ADMIN("Admin"),
    
    WRITE("Write"),
    
    READ("Read");

    private String value;

    CopyPackagesEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CopyPackagesEnum fromValue(String text) {
      for (CopyPackagesEnum b : CopyPackagesEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<CopyPackagesEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CopyPackagesEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CopyPackagesEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return CopyPackagesEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("copy_packages")
  private CopyPackagesEnum copyPackages = null;

  @SerializedName("created_at")
  private String createdAt = null;

  /**
   * This defines the default level of privilege that all of your organization members have for this repository. This does not include collaborators, but applies to any member of the org regardless of their own membership role (i.e. it applies to owners, managers and members). Be careful if setting this to admin, because any member will be able to change settings.
   */
  @JsonAdapter(DefaultPrivilegeEnum.Adapter.class)
  public enum DefaultPrivilegeEnum {
    ADMIN("Admin"),
    
    WRITE("Write"),
    
    READ("Read"),
    
    NONE("None");

    private String value;

    DefaultPrivilegeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DefaultPrivilegeEnum fromValue(String text) {
      for (DefaultPrivilegeEnum b : DefaultPrivilegeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<DefaultPrivilegeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DefaultPrivilegeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DefaultPrivilegeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return DefaultPrivilegeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("default_privilege")
  private DefaultPrivilegeEnum defaultPrivilege = null;

  @SerializedName("delete_own")
  private Boolean deleteOwn = null;

  /**
   * This defines the minimum level of privilege required for a user to delete packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific delete setting.
   */
  @JsonAdapter(DeletePackagesEnum.Adapter.class)
  public enum DeletePackagesEnum {
    ADMIN("Admin"),
    
    WRITE("Write");

    private String value;

    DeletePackagesEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DeletePackagesEnum fromValue(String text) {
      for (DeletePackagesEnum b : DeletePackagesEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<DeletePackagesEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DeletePackagesEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DeletePackagesEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return DeletePackagesEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("delete_packages")
  private DeletePackagesEnum deletePackages = null;

  @SerializedName("deleted_at")
  private String deletedAt = null;

  @SerializedName("description")
  private String description = null;

  @SerializedName("distributes")
  private List<String> distributes = null;

  @SerializedName("docker_refresh_tokens_enabled")
  private Boolean dockerRefreshTokensEnabled = null;

  @SerializedName("gpg_keys")
  private List<ReposGpgKeys> gpgKeys = null;

  @SerializedName("index_files")
  private Boolean indexFiles = null;

  @SerializedName("is_open_source")
  private Boolean isOpenSource = null;

  @SerializedName("is_private")
  private Boolean isPrivate = null;

  @SerializedName("is_public")
  private Boolean isPublic = null;

  @SerializedName("move_own")
  private Boolean moveOwn = null;

  /**
   * This defines the minimum level of privilege required for a user to move packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific move setting.
   */
  @JsonAdapter(MovePackagesEnum.Adapter.class)
  public enum MovePackagesEnum {
    ADMIN("Admin"),
    
    WRITE("Write"),
    
    READ("Read");

    private String value;

    MovePackagesEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static MovePackagesEnum fromValue(String text) {
      for (MovePackagesEnum b : MovePackagesEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<MovePackagesEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MovePackagesEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MovePackagesEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return MovePackagesEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("move_packages")
  private MovePackagesEnum movePackages = null;

  @SerializedName("name")
  private String name = null;

  @SerializedName("namespace")
  private String namespace = null;

  @SerializedName("namespace_url")
  private String namespaceUrl = null;

  @SerializedName("num_downloads")
  private Integer numDownloads = null;

  @SerializedName("package_count")
  private Integer packageCount = null;

  @SerializedName("package_group_count")
  private Integer packageGroupCount = null;

  @SerializedName("proxy_npmjs")
  private Boolean proxyNpmjs = null;

  @SerializedName("proxy_pypi")
  private Boolean proxyPypi = null;

  @SerializedName("raw_package_index_enabled")
  private Boolean rawPackageIndexEnabled = null;

  @SerializedName("raw_package_index_signatures_enabled")
  private Boolean rawPackageIndexSignaturesEnabled = null;

  /**
   * This defines the minimum level of privilege required for a user to republish packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific republish setting. Please note that the user still requires the privilege to delete packages that will be replaced by the new package; otherwise the republish will fail.
   */
  @JsonAdapter(ReplacePackagesEnum.Adapter.class)
  public enum ReplacePackagesEnum {
    ADMIN("Admin"),
    
    WRITE("Write");

    private String value;

    ReplacePackagesEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ReplacePackagesEnum fromValue(String text) {
      for (ReplacePackagesEnum b : ReplacePackagesEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ReplacePackagesEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ReplacePackagesEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ReplacePackagesEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ReplacePackagesEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("replace_packages")
  private ReplacePackagesEnum replacePackages = null;

  @SerializedName("replace_packages_by_default")
  private Boolean replacePackagesByDefault = null;

  @SerializedName("repository_type")
  private Integer repositoryType = null;

  @SerializedName("repository_type_str")
  private String repositoryTypeStr = null;

  @SerializedName("resync_own")
  private Boolean resyncOwn = null;

  /**
   * This defines the minimum level of privilege required for a user to resync packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific resync setting.
   */
  @JsonAdapter(ResyncPackagesEnum.Adapter.class)
  public enum ResyncPackagesEnum {
    ADMIN("Admin"),
    
    WRITE("Write");

    private String value;

    ResyncPackagesEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ResyncPackagesEnum fromValue(String text) {
      for (ResyncPackagesEnum b : ResyncPackagesEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ResyncPackagesEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ResyncPackagesEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ResyncPackagesEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ResyncPackagesEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("resync_packages")
  private ResyncPackagesEnum resyncPackages = null;

  @SerializedName("scan_own")
  private Boolean scanOwn = null;

  /**
   * This defines the minimum level of privilege required for a user to scan packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific scan setting.
   */
  @JsonAdapter(ScanPackagesEnum.Adapter.class)
  public enum ScanPackagesEnum {
    ADMIN("Admin"),
    
    WRITE("Write"),
    
    READ("Read");

    private String value;

    ScanPackagesEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ScanPackagesEnum fromValue(String text) {
      for (ScanPackagesEnum b : ScanPackagesEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ScanPackagesEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ScanPackagesEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ScanPackagesEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ScanPackagesEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("scan_packages")
  private ScanPackagesEnum scanPackages = null;

  @SerializedName("self_html_url")
  private String selfHtmlUrl = null;

  @SerializedName("self_url")
  private String selfUrl = null;

  @SerializedName("show_setup_all")
  private Boolean showSetupAll = null;

  @SerializedName("size")
  private Integer size = null;

  @SerializedName("size_str")
  private String sizeStr = null;

  @SerializedName("slug")
  private String slug = null;

  @SerializedName("slug_perm")
  private String slugPerm = null;

  @SerializedName("storage_region")
  private String storageRegion = null;

  @SerializedName("strict_npm_validation")
  private Boolean strictNpmValidation = null;

  @SerializedName("use_debian_labels")
  private Boolean useDebianLabels = null;

  @SerializedName("use_default_cargo_upstream")
  private Boolean useDefaultCargoUpstream = null;

  @SerializedName("use_noarch_packages")
  private Boolean useNoarchPackages = null;

  @SerializedName("use_source_packages")
  private Boolean useSourcePackages = null;

  @SerializedName("use_vulnerability_scanning")
  private Boolean useVulnerabilityScanning = null;

  @SerializedName("user_entitlements_enabled")
  private Boolean userEntitlementsEnabled = null;

  /**
   * This defines the minimum level of privilege required for a user to view repository statistics, to include entitlement-based usage, if applicable. If a user does not have the permission, they won&#39;t be able to view any statistics, either via the UI, API or CLI.
   */
  @JsonAdapter(ViewStatisticsEnum.Adapter.class)
  public enum ViewStatisticsEnum {
    ADMIN("Admin"),
    
    WRITE("Write"),
    
    READ("Read");

    private String value;

    ViewStatisticsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ViewStatisticsEnum fromValue(String text) {
      for (ViewStatisticsEnum b : ViewStatisticsEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ViewStatisticsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ViewStatisticsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ViewStatisticsEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ViewStatisticsEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("view_statistics")
  private ViewStatisticsEnum viewStatistics = null;

  public RepositoryCreate cdnUrl(String cdnUrl) {
    this.cdnUrl = cdnUrl;
    return this;
  }

   /**
   * Base URL from which packages and other artifacts are downloaded.
   * @return cdnUrl
  **/
  @ApiModelProperty(value = "Base URL from which packages and other artifacts are downloaded.")
  public String getCdnUrl() {
    return cdnUrl;
  }

  public void setCdnUrl(String cdnUrl) {
    this.cdnUrl = cdnUrl;
  }

  public RepositoryCreate contentKind(ContentKindEnum contentKind) {
    this.contentKind = contentKind;
    return this;
  }

   /**
   * The repository content kind determines whether this repository contains packages, or provides a distribution of packages from other repositories. You can only select the content kind at repository creation time.
   * @return contentKind
  **/
  @ApiModelProperty(value = "The repository content kind determines whether this repository contains packages, or provides a distribution of packages from other repositories. You can only select the content kind at repository creation time.")
  public ContentKindEnum getContentKind() {
    return contentKind;
  }

  public void setContentKind(ContentKindEnum contentKind) {
    this.contentKind = contentKind;
  }

  public RepositoryCreate contextualAuthRealm(Boolean contextualAuthRealm) {
    this.contextualAuthRealm = contextualAuthRealm;
    return this;
  }

   /**
   * If checked, missing credentials for this repository where basic authentication is required shall present an enriched value in the &#39;WWW-Authenticate&#39; header containing the namespace and repository. This can be useful for tooling such as SBT where the authentication realm is used to distinguish and disambiguate credentials.
   * @return contextualAuthRealm
  **/
  @ApiModelProperty(value = "If checked, missing credentials for this repository where basic authentication is required shall present an enriched value in the 'WWW-Authenticate' header containing the namespace and repository. This can be useful for tooling such as SBT where the authentication realm is used to distinguish and disambiguate credentials.")
  public Boolean isContextualAuthRealm() {
    return contextualAuthRealm;
  }

  public void setContextualAuthRealm(Boolean contextualAuthRealm) {
    this.contextualAuthRealm = contextualAuthRealm;
  }

  public RepositoryCreate copyOwn(Boolean copyOwn) {
    this.copyOwn = copyOwn;
    return this;
  }

   /**
   * If checked, users can copy any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the &#39;Access Controls&#39; section of the repository, and any inherited from the org.
   * @return copyOwn
  **/
  @ApiModelProperty(value = "If checked, users can copy any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the 'Access Controls' section of the repository, and any inherited from the org.")
  public Boolean isCopyOwn() {
    return copyOwn;
  }

  public void setCopyOwn(Boolean copyOwn) {
    this.copyOwn = copyOwn;
  }

  public RepositoryCreate copyPackages(CopyPackagesEnum copyPackages) {
    this.copyPackages = copyPackages;
    return this;
  }

   /**
   * This defines the minimum level of privilege required for a user to copy packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific copy setting.
   * @return copyPackages
  **/
  @ApiModelProperty(value = "This defines the minimum level of privilege required for a user to copy packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific copy setting.")
  public CopyPackagesEnum getCopyPackages() {
    return copyPackages;
  }

  public void setCopyPackages(CopyPackagesEnum copyPackages) {
    this.copyPackages = copyPackages;
  }

  public RepositoryCreate createdAt(String createdAt) {
    this.createdAt = createdAt;
    return this;
  }

   /**
   * 
   * @return createdAt
  **/
  @ApiModelProperty(value = "")
  public String getCreatedAt() {
    return createdAt;
  }

  public void setCreatedAt(String createdAt) {
    this.createdAt = createdAt;
  }

  public RepositoryCreate defaultPrivilege(DefaultPrivilegeEnum defaultPrivilege) {
    this.defaultPrivilege = defaultPrivilege;
    return this;
  }

   /**
   * This defines the default level of privilege that all of your organization members have for this repository. This does not include collaborators, but applies to any member of the org regardless of their own membership role (i.e. it applies to owners, managers and members). Be careful if setting this to admin, because any member will be able to change settings.
   * @return defaultPrivilege
  **/
  @ApiModelProperty(value = "This defines the default level of privilege that all of your organization members have for this repository. This does not include collaborators, but applies to any member of the org regardless of their own membership role (i.e. it applies to owners, managers and members). Be careful if setting this to admin, because any member will be able to change settings.")
  public DefaultPrivilegeEnum getDefaultPrivilege() {
    return defaultPrivilege;
  }

  public void setDefaultPrivilege(DefaultPrivilegeEnum defaultPrivilege) {
    this.defaultPrivilege = defaultPrivilege;
  }

  public RepositoryCreate deleteOwn(Boolean deleteOwn) {
    this.deleteOwn = deleteOwn;
    return this;
  }

   /**
   * If checked, users can delete any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the &#39;Access Controls&#39; section of the repository, and any inherited from the org.
   * @return deleteOwn
  **/
  @ApiModelProperty(value = "If checked, users can delete any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the 'Access Controls' section of the repository, and any inherited from the org.")
  public Boolean isDeleteOwn() {
    return deleteOwn;
  }

  public void setDeleteOwn(Boolean deleteOwn) {
    this.deleteOwn = deleteOwn;
  }

  public RepositoryCreate deletePackages(DeletePackagesEnum deletePackages) {
    this.deletePackages = deletePackages;
    return this;
  }

   /**
   * This defines the minimum level of privilege required for a user to delete packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific delete setting.
   * @return deletePackages
  **/
  @ApiModelProperty(value = "This defines the minimum level of privilege required for a user to delete packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific delete setting.")
  public DeletePackagesEnum getDeletePackages() {
    return deletePackages;
  }

  public void setDeletePackages(DeletePackagesEnum deletePackages) {
    this.deletePackages = deletePackages;
  }

  public RepositoryCreate deletedAt(String deletedAt) {
    this.deletedAt = deletedAt;
    return this;
  }

   /**
   * 
   * @return deletedAt
  **/
  @ApiModelProperty(value = "")
  public String getDeletedAt() {
    return deletedAt;
  }

  public void setDeletedAt(String deletedAt) {
    this.deletedAt = deletedAt;
  }

  public RepositoryCreate description(String description) {
    this.description = description;
    return this;
  }

   /**
   * A description of the repository&#39;s purpose/contents.
   * @return description
  **/
  @ApiModelProperty(value = "A description of the repository's purpose/contents.")
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public RepositoryCreate distributes(List<String> distributes) {
    this.distributes = distributes;
    return this;
  }

  public RepositoryCreate addDistributesItem(String distributesItem) {
    if (this.distributes == null) {
      this.distributes = new ArrayList<>();
    }
    this.distributes.add(distributesItem);
    return this;
  }

   /**
   * The repositories distributed through this repo. Adding repos here is only valid if the content_kind is DISTRIBUTION.
   * @return distributes
  **/
  @ApiModelProperty(value = "The repositories distributed through this repo. Adding repos here is only valid if the content_kind is DISTRIBUTION.")
  public List<String> getDistributes() {
    return distributes;
  }

  public void setDistributes(List<String> distributes) {
    this.distributes = distributes;
  }

  public RepositoryCreate dockerRefreshTokensEnabled(Boolean dockerRefreshTokensEnabled) {
    this.dockerRefreshTokensEnabled = dockerRefreshTokensEnabled;
    return this;
  }

   /**
   * If checked, refresh tokens will be issued in addition to access tokens for Docker authentication. This allows unlimited extension of the lifetime of access tokens.
   * @return dockerRefreshTokensEnabled
  **/
  @ApiModelProperty(value = "If checked, refresh tokens will be issued in addition to access tokens for Docker authentication. This allows unlimited extension of the lifetime of access tokens.")
  public Boolean isDockerRefreshTokensEnabled() {
    return dockerRefreshTokensEnabled;
  }

  public void setDockerRefreshTokensEnabled(Boolean dockerRefreshTokensEnabled) {
    this.dockerRefreshTokensEnabled = dockerRefreshTokensEnabled;
  }

  public RepositoryCreate gpgKeys(List<ReposGpgKeys> gpgKeys) {
    this.gpgKeys = gpgKeys;
    return this;
  }

  public RepositoryCreate addGpgKeysItem(ReposGpgKeys gpgKeysItem) {
    if (this.gpgKeys == null) {
      this.gpgKeys = new ArrayList<>();
    }
    this.gpgKeys.add(gpgKeysItem);
    return this;
  }

   /**
   * 
   * @return gpgKeys
  **/
  @Valid
  @ApiModelProperty(value = "")
  public List<ReposGpgKeys> getGpgKeys() {
    return gpgKeys;
  }

  public void setGpgKeys(List<ReposGpgKeys> gpgKeys) {
    this.gpgKeys = gpgKeys;
  }

  public RepositoryCreate indexFiles(Boolean indexFiles) {
    this.indexFiles = indexFiles;
    return this;
  }

   /**
   * If checked, files contained in packages will be indexed, which increase the synchronisation time required for packages. Note that it is recommended you keep this enabled unless the synchronisation time is significantly impacted.
   * @return indexFiles
  **/
  @ApiModelProperty(value = "If checked, files contained in packages will be indexed, which increase the synchronisation time required for packages. Note that it is recommended you keep this enabled unless the synchronisation time is significantly impacted.")
  public Boolean isIndexFiles() {
    return indexFiles;
  }

  public void setIndexFiles(Boolean indexFiles) {
    this.indexFiles = indexFiles;
  }

  public RepositoryCreate isOpenSource(Boolean isOpenSource) {
    this.isOpenSource = isOpenSource;
    return this;
  }

   /**
   * 
   * @return isOpenSource
  **/
  @ApiModelProperty(value = "")
  public Boolean isIsOpenSource() {
    return isOpenSource;
  }

  public void setIsOpenSource(Boolean isOpenSource) {
    this.isOpenSource = isOpenSource;
  }

  public RepositoryCreate isPrivate(Boolean isPrivate) {
    this.isPrivate = isPrivate;
    return this;
  }

   /**
   * 
   * @return isPrivate
  **/
  @ApiModelProperty(value = "")
  public Boolean isIsPrivate() {
    return isPrivate;
  }

  public void setIsPrivate(Boolean isPrivate) {
    this.isPrivate = isPrivate;
  }

  public RepositoryCreate isPublic(Boolean isPublic) {
    this.isPublic = isPublic;
    return this;
  }

   /**
   * 
   * @return isPublic
  **/
  @ApiModelProperty(value = "")
  public Boolean isIsPublic() {
    return isPublic;
  }

  public void setIsPublic(Boolean isPublic) {
    this.isPublic = isPublic;
  }

  public RepositoryCreate moveOwn(Boolean moveOwn) {
    this.moveOwn = moveOwn;
    return this;
  }

   /**
   * If checked, users can move any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the &#39;Access Controls&#39; section of the repository, and any inherited from the org.
   * @return moveOwn
  **/
  @ApiModelProperty(value = "If checked, users can move any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the 'Access Controls' section of the repository, and any inherited from the org.")
  public Boolean isMoveOwn() {
    return moveOwn;
  }

  public void setMoveOwn(Boolean moveOwn) {
    this.moveOwn = moveOwn;
  }

  public RepositoryCreate movePackages(MovePackagesEnum movePackages) {
    this.movePackages = movePackages;
    return this;
  }

   /**
   * This defines the minimum level of privilege required for a user to move packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific move setting.
   * @return movePackages
  **/
  @ApiModelProperty(value = "This defines the minimum level of privilege required for a user to move packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific move setting.")
  public MovePackagesEnum getMovePackages() {
    return movePackages;
  }

  public void setMovePackages(MovePackagesEnum movePackages) {
    this.movePackages = movePackages;
  }

  public RepositoryCreate name(String name) {
    this.name = name;
    return this;
  }

   /**
   * A descriptive name for the repository.
   * @return name
  **/
  @NotNull
  @ApiModelProperty(required = true, value = "A descriptive name for the repository.")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public RepositoryCreate namespace(String namespace) {
    this.namespace = namespace;
    return this;
  }

   /**
   * Namespace to which this repository belongs.
   * @return namespace
  **/
  @ApiModelProperty(value = "Namespace to which this repository belongs.")
  public String getNamespace() {
    return namespace;
  }

  public void setNamespace(String namespace) {
    this.namespace = namespace;
  }

  public RepositoryCreate namespaceUrl(String namespaceUrl) {
    this.namespaceUrl = namespaceUrl;
    return this;
  }

   /**
   * API endpoint where data about this namespace can be retrieved.
   * @return namespaceUrl
  **/
  @ApiModelProperty(value = "API endpoint where data about this namespace can be retrieved.")
  public String getNamespaceUrl() {
    return namespaceUrl;
  }

  public void setNamespaceUrl(String namespaceUrl) {
    this.namespaceUrl = namespaceUrl;
  }

  public RepositoryCreate numDownloads(Integer numDownloads) {
    this.numDownloads = numDownloads;
    return this;
  }

   /**
   * The number of downloads for packages in the repository.
   * @return numDownloads
  **/
  @ApiModelProperty(value = "The number of downloads for packages in the repository.")
  public Integer getNumDownloads() {
    return numDownloads;
  }

  public void setNumDownloads(Integer numDownloads) {
    this.numDownloads = numDownloads;
  }

  public RepositoryCreate packageCount(Integer packageCount) {
    this.packageCount = packageCount;
    return this;
  }

   /**
   * The number of packages in the repository.
   * @return packageCount
  **/
  @ApiModelProperty(value = "The number of packages in the repository.")
  public Integer getPackageCount() {
    return packageCount;
  }

  public void setPackageCount(Integer packageCount) {
    this.packageCount = packageCount;
  }

  public RepositoryCreate packageGroupCount(Integer packageGroupCount) {
    this.packageGroupCount = packageGroupCount;
    return this;
  }

   /**
   * The number of groups in the repository.
   * @return packageGroupCount
  **/
  @ApiModelProperty(value = "The number of groups in the repository.")
  public Integer getPackageGroupCount() {
    return packageGroupCount;
  }

  public void setPackageGroupCount(Integer packageGroupCount) {
    this.packageGroupCount = packageGroupCount;
  }

  public RepositoryCreate proxyNpmjs(Boolean proxyNpmjs) {
    this.proxyNpmjs = proxyNpmjs;
    return this;
  }

   /**
   * If checked, Npm packages that are not in the repository when requested by clients will automatically be proxied from the public npmjs.org registry. If there is at least one version for a package, others will not be proxied.
   * @return proxyNpmjs
  **/
  @ApiModelProperty(value = "If checked, Npm packages that are not in the repository when requested by clients will automatically be proxied from the public npmjs.org registry. If there is at least one version for a package, others will not be proxied.")
  public Boolean isProxyNpmjs() {
    return proxyNpmjs;
  }

  public void setProxyNpmjs(Boolean proxyNpmjs) {
    this.proxyNpmjs = proxyNpmjs;
  }

  public RepositoryCreate proxyPypi(Boolean proxyPypi) {
    this.proxyPypi = proxyPypi;
    return this;
  }

   /**
   * If checked, Python packages that are not in the repository when requested by clients will automatically be proxied from the public pypi.python.org registry. If there is at least one version for a package, others will not be proxied.
   * @return proxyPypi
  **/
  @ApiModelProperty(value = "If checked, Python packages that are not in the repository when requested by clients will automatically be proxied from the public pypi.python.org registry. If there is at least one version for a package, others will not be proxied.")
  public Boolean isProxyPypi() {
    return proxyPypi;
  }

  public void setProxyPypi(Boolean proxyPypi) {
    this.proxyPypi = proxyPypi;
  }

  public RepositoryCreate rawPackageIndexEnabled(Boolean rawPackageIndexEnabled) {
    this.rawPackageIndexEnabled = rawPackageIndexEnabled;
    return this;
  }

   /**
   * If checked, HTML and JSON indexes will be generated that list all available raw packages in the repository.
   * @return rawPackageIndexEnabled
  **/
  @ApiModelProperty(value = "If checked, HTML and JSON indexes will be generated that list all available raw packages in the repository.")
  public Boolean isRawPackageIndexEnabled() {
    return rawPackageIndexEnabled;
  }

  public void setRawPackageIndexEnabled(Boolean rawPackageIndexEnabled) {
    this.rawPackageIndexEnabled = rawPackageIndexEnabled;
  }

  public RepositoryCreate rawPackageIndexSignaturesEnabled(Boolean rawPackageIndexSignaturesEnabled) {
    this.rawPackageIndexSignaturesEnabled = rawPackageIndexSignaturesEnabled;
    return this;
  }

   /**
   * If checked, the HTML and JSON indexes will display raw package GPG signatures alongside the index packages.
   * @return rawPackageIndexSignaturesEnabled
  **/
  @ApiModelProperty(value = "If checked, the HTML and JSON indexes will display raw package GPG signatures alongside the index packages.")
  public Boolean isRawPackageIndexSignaturesEnabled() {
    return rawPackageIndexSignaturesEnabled;
  }

  public void setRawPackageIndexSignaturesEnabled(Boolean rawPackageIndexSignaturesEnabled) {
    this.rawPackageIndexSignaturesEnabled = rawPackageIndexSignaturesEnabled;
  }

  public RepositoryCreate replacePackages(ReplacePackagesEnum replacePackages) {
    this.replacePackages = replacePackages;
    return this;
  }

   /**
   * This defines the minimum level of privilege required for a user to republish packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific republish setting. Please note that the user still requires the privilege to delete packages that will be replaced by the new package; otherwise the republish will fail.
   * @return replacePackages
  **/
  @ApiModelProperty(value = "This defines the minimum level of privilege required for a user to republish packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific republish setting. Please note that the user still requires the privilege to delete packages that will be replaced by the new package; otherwise the republish will fail.")
  public ReplacePackagesEnum getReplacePackages() {
    return replacePackages;
  }

  public void setReplacePackages(ReplacePackagesEnum replacePackages) {
    this.replacePackages = replacePackages;
  }

  public RepositoryCreate replacePackagesByDefault(Boolean replacePackagesByDefault) {
    this.replacePackagesByDefault = replacePackagesByDefault;
    return this;
  }

   /**
   * If checked, uploaded packages will overwrite/replace any others with the same attributes (e.g. same version) by default. This only applies if the user has the required privilege for the republishing AND has the required privilege to delete existing packages that they don&#39;t own.
   * @return replacePackagesByDefault
  **/
  @ApiModelProperty(value = "If checked, uploaded packages will overwrite/replace any others with the same attributes (e.g. same version) by default. This only applies if the user has the required privilege for the republishing AND has the required privilege to delete existing packages that they don't own.")
  public Boolean isReplacePackagesByDefault() {
    return replacePackagesByDefault;
  }

  public void setReplacePackagesByDefault(Boolean replacePackagesByDefault) {
    this.replacePackagesByDefault = replacePackagesByDefault;
  }

  public RepositoryCreate repositoryType(Integer repositoryType) {
    this.repositoryType = repositoryType;
    return this;
  }

   /**
   * The repository type changes how it is accessed and billed. Private repositories can only be used on paid plans, but are visible only to you or authorised delegates. Open-Source repositories are always visible to everyone and are restricted by licensing, but are free to use and come with generous bandwidth/storage. You can only select Open-Source at repository creation time.
   * @return repositoryType
  **/
  @ApiModelProperty(value = "The repository type changes how it is accessed and billed. Private repositories can only be used on paid plans, but are visible only to you or authorised delegates. Open-Source repositories are always visible to everyone and are restricted by licensing, but are free to use and come with generous bandwidth/storage. You can only select Open-Source at repository creation time.")
  public Integer getRepositoryType() {
    return repositoryType;
  }

  public void setRepositoryType(Integer repositoryType) {
    this.repositoryType = repositoryType;
  }

  public RepositoryCreate repositoryTypeStr(String repositoryTypeStr) {
    this.repositoryTypeStr = repositoryTypeStr;
    return this;
  }

   /**
   * The repository type changes how it is accessed and billed. Private repositories can only be used on paid plans, but are visible only to you or authorised delegates. Public repositories are free to use on all plans and visible to all Cloudsmith users.
   * @return repositoryTypeStr
  **/
  @ApiModelProperty(value = "The repository type changes how it is accessed and billed. Private repositories can only be used on paid plans, but are visible only to you or authorised delegates. Public repositories are free to use on all plans and visible to all Cloudsmith users.")
  public String getRepositoryTypeStr() {
    return repositoryTypeStr;
  }

  public void setRepositoryTypeStr(String repositoryTypeStr) {
    this.repositoryTypeStr = repositoryTypeStr;
  }

  public RepositoryCreate resyncOwn(Boolean resyncOwn) {
    this.resyncOwn = resyncOwn;
    return this;
  }

   /**
   * If checked, users can resync any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the &#39;Access Controls&#39; section of the repository, and any inherited from the org.
   * @return resyncOwn
  **/
  @ApiModelProperty(value = "If checked, users can resync any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the 'Access Controls' section of the repository, and any inherited from the org.")
  public Boolean isResyncOwn() {
    return resyncOwn;
  }

  public void setResyncOwn(Boolean resyncOwn) {
    this.resyncOwn = resyncOwn;
  }

  public RepositoryCreate resyncPackages(ResyncPackagesEnum resyncPackages) {
    this.resyncPackages = resyncPackages;
    return this;
  }

   /**
   * This defines the minimum level of privilege required for a user to resync packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific resync setting.
   * @return resyncPackages
  **/
  @ApiModelProperty(value = "This defines the minimum level of privilege required for a user to resync packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific resync setting.")
  public ResyncPackagesEnum getResyncPackages() {
    return resyncPackages;
  }

  public void setResyncPackages(ResyncPackagesEnum resyncPackages) {
    this.resyncPackages = resyncPackages;
  }

  public RepositoryCreate scanOwn(Boolean scanOwn) {
    this.scanOwn = scanOwn;
    return this;
  }

   /**
   * If checked, users can scan any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the &#39;Access Controls&#39; section of the repository, and any inherited from the org.
   * @return scanOwn
  **/
  @ApiModelProperty(value = "If checked, users can scan any of their own packages that they have uploaded, assuming that they still have write privilege for the repository. This takes precedence over privileges configured in the 'Access Controls' section of the repository, and any inherited from the org.")
  public Boolean isScanOwn() {
    return scanOwn;
  }

  public void setScanOwn(Boolean scanOwn) {
    this.scanOwn = scanOwn;
  }

  public RepositoryCreate scanPackages(ScanPackagesEnum scanPackages) {
    this.scanPackages = scanPackages;
    return this;
  }

   /**
   * This defines the minimum level of privilege required for a user to scan packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific scan setting.
   * @return scanPackages
  **/
  @ApiModelProperty(value = "This defines the minimum level of privilege required for a user to scan packages. Unless the package was uploaded by that user, in which the permission may be overridden by the user-specific scan setting.")
  public ScanPackagesEnum getScanPackages() {
    return scanPackages;
  }

  public void setScanPackages(ScanPackagesEnum scanPackages) {
    this.scanPackages = scanPackages;
  }

  public RepositoryCreate selfHtmlUrl(String selfHtmlUrl) {
    this.selfHtmlUrl = selfHtmlUrl;
    return this;
  }

   /**
   * Website URL for this repository.
   * @return selfHtmlUrl
  **/
  @ApiModelProperty(value = "Website URL for this repository.")
  public String getSelfHtmlUrl() {
    return selfHtmlUrl;
  }

  public void setSelfHtmlUrl(String selfHtmlUrl) {
    this.selfHtmlUrl = selfHtmlUrl;
  }

  public RepositoryCreate selfUrl(String selfUrl) {
    this.selfUrl = selfUrl;
    return this;
  }

   /**
   * API endpoint where data about this repository can be retrieved.
   * @return selfUrl
  **/
  @ApiModelProperty(value = "API endpoint where data about this repository can be retrieved.")
  public String getSelfUrl() {
    return selfUrl;
  }

  public void setSelfUrl(String selfUrl) {
    this.selfUrl = selfUrl;
  }

  public RepositoryCreate showSetupAll(Boolean showSetupAll) {
    this.showSetupAll = showSetupAll;
    return this;
  }

   /**
   * If checked, the Set Me Up help for all formats will always be shown, even if you don&#39;t have packages of that type uploaded. Otherwise, help will only be shown for packages that are in the repository. For example, if you have uploaded only NuGet packages, then the Set Me Up help for NuGet packages will be shown only.
   * @return showSetupAll
  **/
  @ApiModelProperty(value = "If checked, the Set Me Up help for all formats will always be shown, even if you don't have packages of that type uploaded. Otherwise, help will only be shown for packages that are in the repository. For example, if you have uploaded only NuGet packages, then the Set Me Up help for NuGet packages will be shown only.")
  public Boolean isShowSetupAll() {
    return showSetupAll;
  }

  public void setShowSetupAll(Boolean showSetupAll) {
    this.showSetupAll = showSetupAll;
  }

  public RepositoryCreate size(Integer size) {
    this.size = size;
    return this;
  }

   /**
   * The calculated size of the repository.
   * @return size
  **/
  @ApiModelProperty(value = "The calculated size of the repository.")
  public Integer getSize() {
    return size;
  }

  public void setSize(Integer size) {
    this.size = size;
  }

  public RepositoryCreate sizeStr(String sizeStr) {
    this.sizeStr = sizeStr;
    return this;
  }

   /**
   * The calculated size of the repository (human readable).
   * @return sizeStr
  **/
  @ApiModelProperty(value = "The calculated size of the repository (human readable).")
  public String getSizeStr() {
    return sizeStr;
  }

  public void setSizeStr(String sizeStr) {
    this.sizeStr = sizeStr;
  }

  public RepositoryCreate slug(String slug) {
    this.slug = slug;
    return this;
  }

   /**
   * The slug identifies the repository in URIs.
   * @return slug
  **/
  @ApiModelProperty(value = "The slug identifies the repository in URIs.")
  public String getSlug() {
    return slug;
  }

  public void setSlug(String slug) {
    this.slug = slug;
  }

  public RepositoryCreate slugPerm(String slugPerm) {
    this.slugPerm = slugPerm;
    return this;
  }

   /**
   * The slug_perm immutably identifies the repository. It will never change once a repository has been created.
   * @return slugPerm
  **/
  @ApiModelProperty(value = "The slug_perm immutably identifies the repository. It will never change once a repository has been created.")
  public String getSlugPerm() {
    return slugPerm;
  }

  public void setSlugPerm(String slugPerm) {
    this.slugPerm = slugPerm;
  }

  public RepositoryCreate storageRegion(String storageRegion) {
    this.storageRegion = storageRegion;
    return this;
  }

   /**
   * The Cloudsmith region in which package files are stored.
   * @return storageRegion
  **/
  @ApiModelProperty(value = "The Cloudsmith region in which package files are stored.")
  public String getStorageRegion() {
    return storageRegion;
  }

  public void setStorageRegion(String storageRegion) {
    this.storageRegion = storageRegion;
  }

  public RepositoryCreate strictNpmValidation(Boolean strictNpmValidation) {
    this.strictNpmValidation = strictNpmValidation;
    return this;
  }

   /**
   * If checked, npm packages will be validated strictly to ensure the package matches specifcation. You can turn this off if you have packages that are old or otherwise mildly off-spec, but we can&#39;t guarantee the packages will work with npm-cli or other tooling correctly. Turn off at your own risk!
   * @return strictNpmValidation
  **/
  @ApiModelProperty(value = "If checked, npm packages will be validated strictly to ensure the package matches specifcation. You can turn this off if you have packages that are old or otherwise mildly off-spec, but we can't guarantee the packages will work with npm-cli or other tooling correctly. Turn off at your own risk!")
  public Boolean isStrictNpmValidation() {
    return strictNpmValidation;
  }

  public void setStrictNpmValidation(Boolean strictNpmValidation) {
    this.strictNpmValidation = strictNpmValidation;
  }

  public RepositoryCreate useDebianLabels(Boolean useDebianLabels) {
    this.useDebianLabels = useDebianLabels;
    return this;
  }

   /**
   * If checked, a &#39;Label&#39; field will be present in Debian-based repositories. It will contain a string that identifies the entitlement token used to authenticate the repository, in the form of &#39;source&#x3D;t-&lt;identifier&gt;&#39;; or &#39;source&#x3D;none&#39; if no token was used. You can use this to help with pinning.
   * @return useDebianLabels
  **/
  @ApiModelProperty(value = "If checked, a 'Label' field will be present in Debian-based repositories. It will contain a string that identifies the entitlement token used to authenticate the repository, in the form of 'source=t-<identifier>'; or 'source=none' if no token was used. You can use this to help with pinning.")
  public Boolean isUseDebianLabels() {
    return useDebianLabels;
  }

  public void setUseDebianLabels(Boolean useDebianLabels) {
    this.useDebianLabels = useDebianLabels;
  }

  public RepositoryCreate useDefaultCargoUpstream(Boolean useDefaultCargoUpstream) {
    this.useDefaultCargoUpstream = useDefaultCargoUpstream;
    return this;
  }

   /**
   * If checked, dependencies of uploaded Cargo crates which do not set an explicit value for \&quot;registry\&quot; will be assumed to be available from crates.io. If unchecked, dependencies with unspecified \&quot;registry\&quot; values will be assumed to be available in the registry being uploaded to. Uncheck this if you want to ensure that dependencies are only ever installed from Cloudsmith unless explicitly specified as belong to another registry.
   * @return useDefaultCargoUpstream
  **/
  @ApiModelProperty(value = "If checked, dependencies of uploaded Cargo crates which do not set an explicit value for \"registry\" will be assumed to be available from crates.io. If unchecked, dependencies with unspecified \"registry\" values will be assumed to be available in the registry being uploaded to. Uncheck this if you want to ensure that dependencies are only ever installed from Cloudsmith unless explicitly specified as belong to another registry.")
  public Boolean isUseDefaultCargoUpstream() {
    return useDefaultCargoUpstream;
  }

  public void setUseDefaultCargoUpstream(Boolean useDefaultCargoUpstream) {
    this.useDefaultCargoUpstream = useDefaultCargoUpstream;
  }

  public RepositoryCreate useNoarchPackages(Boolean useNoarchPackages) {
    this.useNoarchPackages = useNoarchPackages;
    return this;
  }

   /**
   * If checked, noarch packages (if supported) are enabled in installations/configurations. A noarch package is one that is not tied to specific system architecture (like i686).
   * @return useNoarchPackages
  **/
  @ApiModelProperty(value = "If checked, noarch packages (if supported) are enabled in installations/configurations. A noarch package is one that is not tied to specific system architecture (like i686).")
  public Boolean isUseNoarchPackages() {
    return useNoarchPackages;
  }

  public void setUseNoarchPackages(Boolean useNoarchPackages) {
    this.useNoarchPackages = useNoarchPackages;
  }

  public RepositoryCreate useSourcePackages(Boolean useSourcePackages) {
    this.useSourcePackages = useSourcePackages;
    return this;
  }

   /**
   * If checked, source packages (if supported) are enabled in installations/configurations. A source package is one that contains source code rather than built binaries.
   * @return useSourcePackages
  **/
  @ApiModelProperty(value = "If checked, source packages (if supported) are enabled in installations/configurations. A source package is one that contains source code rather than built binaries.")
  public Boolean isUseSourcePackages() {
    return useSourcePackages;
  }

  public void setUseSourcePackages(Boolean useSourcePackages) {
    this.useSourcePackages = useSourcePackages;
  }

  public RepositoryCreate useVulnerabilityScanning(Boolean useVulnerabilityScanning) {
    this.useVulnerabilityScanning = useVulnerabilityScanning;
    return this;
  }

   /**
   * If checked, vulnerability scanning will be enabled for all supported packages within this repository.
   * @return useVulnerabilityScanning
  **/
  @ApiModelProperty(value = "If checked, vulnerability scanning will be enabled for all supported packages within this repository.")
  public Boolean isUseVulnerabilityScanning() {
    return useVulnerabilityScanning;
  }

  public void setUseVulnerabilityScanning(Boolean useVulnerabilityScanning) {
    this.useVulnerabilityScanning = useVulnerabilityScanning;
  }

  public RepositoryCreate userEntitlementsEnabled(Boolean userEntitlementsEnabled) {
    this.userEntitlementsEnabled = userEntitlementsEnabled;
    return this;
  }

   /**
   * If checked, users can use and manage their own user-specific entitlement token for the repository (if private). Otherwise, user-specific entitlements are disabled for all users.
   * @return userEntitlementsEnabled
  **/
  @ApiModelProperty(value = "If checked, users can use and manage their own user-specific entitlement token for the repository (if private). Otherwise, user-specific entitlements are disabled for all users.")
  public Boolean isUserEntitlementsEnabled() {
    return userEntitlementsEnabled;
  }

  public void setUserEntitlementsEnabled(Boolean userEntitlementsEnabled) {
    this.userEntitlementsEnabled = userEntitlementsEnabled;
  }

  public RepositoryCreate viewStatistics(ViewStatisticsEnum viewStatistics) {
    this.viewStatistics = viewStatistics;
    return this;
  }

   /**
   * This defines the minimum level of privilege required for a user to view repository statistics, to include entitlement-based usage, if applicable. If a user does not have the permission, they won&#39;t be able to view any statistics, either via the UI, API or CLI.
   * @return viewStatistics
  **/
  @ApiModelProperty(value = "This defines the minimum level of privilege required for a user to view repository statistics, to include entitlement-based usage, if applicable. If a user does not have the permission, they won't be able to view any statistics, either via the UI, API or CLI.")
  public ViewStatisticsEnum getViewStatistics() {
    return viewStatistics;
  }

  public void setViewStatistics(ViewStatisticsEnum viewStatistics) {
    this.viewStatistics = viewStatistics;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RepositoryCreate repositoryCreate = (RepositoryCreate) o;
    return Objects.equals(this.cdnUrl, repositoryCreate.cdnUrl) &&
        Objects.equals(this.contentKind, repositoryCreate.contentKind) &&
        Objects.equals(this.contextualAuthRealm, repositoryCreate.contextualAuthRealm) &&
        Objects.equals(this.copyOwn, repositoryCreate.copyOwn) &&
        Objects.equals(this.copyPackages, repositoryCreate.copyPackages) &&
        Objects.equals(this.createdAt, repositoryCreate.createdAt) &&
        Objects.equals(this.defaultPrivilege, repositoryCreate.defaultPrivilege) &&
        Objects.equals(this.deleteOwn, repositoryCreate.deleteOwn) &&
        Objects.equals(this.deletePackages, repositoryCreate.deletePackages) &&
        Objects.equals(this.deletedAt, repositoryCreate.deletedAt) &&
        Objects.equals(this.description, repositoryCreate.description) &&
        Objects.equals(this.distributes, repositoryCreate.distributes) &&
        Objects.equals(this.dockerRefreshTokensEnabled, repositoryCreate.dockerRefreshTokensEnabled) &&
        Objects.equals(this.gpgKeys, repositoryCreate.gpgKeys) &&
        Objects.equals(this.indexFiles, repositoryCreate.indexFiles) &&
        Objects.equals(this.isOpenSource, repositoryCreate.isOpenSource) &&
        Objects.equals(this.isPrivate, repositoryCreate.isPrivate) &&
        Objects.equals(this.isPublic, repositoryCreate.isPublic) &&
        Objects.equals(this.moveOwn, repositoryCreate.moveOwn) &&
        Objects.equals(this.movePackages, repositoryCreate.movePackages) &&
        Objects.equals(this.name, repositoryCreate.name) &&
        Objects.equals(this.namespace, repositoryCreate.namespace) &&
        Objects.equals(this.namespaceUrl, repositoryCreate.namespaceUrl) &&
        Objects.equals(this.numDownloads, repositoryCreate.numDownloads) &&
        Objects.equals(this.packageCount, repositoryCreate.packageCount) &&
        Objects.equals(this.packageGroupCount, repositoryCreate.packageGroupCount) &&
        Objects.equals(this.proxyNpmjs, repositoryCreate.proxyNpmjs) &&
        Objects.equals(this.proxyPypi, repositoryCreate.proxyPypi) &&
        Objects.equals(this.rawPackageIndexEnabled, repositoryCreate.rawPackageIndexEnabled) &&
        Objects.equals(this.rawPackageIndexSignaturesEnabled, repositoryCreate.rawPackageIndexSignaturesEnabled) &&
        Objects.equals(this.replacePackages, repositoryCreate.replacePackages) &&
        Objects.equals(this.replacePackagesByDefault, repositoryCreate.replacePackagesByDefault) &&
        Objects.equals(this.repositoryType, repositoryCreate.repositoryType) &&
        Objects.equals(this.repositoryTypeStr, repositoryCreate.repositoryTypeStr) &&
        Objects.equals(this.resyncOwn, repositoryCreate.resyncOwn) &&
        Objects.equals(this.resyncPackages, repositoryCreate.resyncPackages) &&
        Objects.equals(this.scanOwn, repositoryCreate.scanOwn) &&
        Objects.equals(this.scanPackages, repositoryCreate.scanPackages) &&
        Objects.equals(this.selfHtmlUrl, repositoryCreate.selfHtmlUrl) &&
        Objects.equals(this.selfUrl, repositoryCreate.selfUrl) &&
        Objects.equals(this.showSetupAll, repositoryCreate.showSetupAll) &&
        Objects.equals(this.size, repositoryCreate.size) &&
        Objects.equals(this.sizeStr, repositoryCreate.sizeStr) &&
        Objects.equals(this.slug, repositoryCreate.slug) &&
        Objects.equals(this.slugPerm, repositoryCreate.slugPerm) &&
        Objects.equals(this.storageRegion, repositoryCreate.storageRegion) &&
        Objects.equals(this.strictNpmValidation, repositoryCreate.strictNpmValidation) &&
        Objects.equals(this.useDebianLabels, repositoryCreate.useDebianLabels) &&
        Objects.equals(this.useDefaultCargoUpstream, repositoryCreate.useDefaultCargoUpstream) &&
        Objects.equals(this.useNoarchPackages, repositoryCreate.useNoarchPackages) &&
        Objects.equals(this.useSourcePackages, repositoryCreate.useSourcePackages) &&
        Objects.equals(this.useVulnerabilityScanning, repositoryCreate.useVulnerabilityScanning) &&
        Objects.equals(this.userEntitlementsEnabled, repositoryCreate.userEntitlementsEnabled) &&
        Objects.equals(this.viewStatistics, repositoryCreate.viewStatistics);
  }

  @Override
  public int hashCode() {
    return Objects.hash(cdnUrl, contentKind, contextualAuthRealm, copyOwn, copyPackages, createdAt, defaultPrivilege, deleteOwn, deletePackages, deletedAt, description, distributes, dockerRefreshTokensEnabled, gpgKeys, indexFiles, isOpenSource, isPrivate, isPublic, moveOwn, movePackages, name, namespace, namespaceUrl, numDownloads, packageCount, packageGroupCount, proxyNpmjs, proxyPypi, rawPackageIndexEnabled, rawPackageIndexSignaturesEnabled, replacePackages, replacePackagesByDefault, repositoryType, repositoryTypeStr, resyncOwn, resyncPackages, scanOwn, scanPackages, selfHtmlUrl, selfUrl, showSetupAll, size, sizeStr, slug, slugPerm, storageRegion, strictNpmValidation, useDebianLabels, useDefaultCargoUpstream, useNoarchPackages, useSourcePackages, useVulnerabilityScanning, userEntitlementsEnabled, viewStatistics);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RepositoryCreate {\n");
    
    sb.append("    cdnUrl: ").append(toIndentedString(cdnUrl)).append("\n");
    sb.append("    contentKind: ").append(toIndentedString(contentKind)).append("\n");
    sb.append("    contextualAuthRealm: ").append(toIndentedString(contextualAuthRealm)).append("\n");
    sb.append("    copyOwn: ").append(toIndentedString(copyOwn)).append("\n");
    sb.append("    copyPackages: ").append(toIndentedString(copyPackages)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    defaultPrivilege: ").append(toIndentedString(defaultPrivilege)).append("\n");
    sb.append("    deleteOwn: ").append(toIndentedString(deleteOwn)).append("\n");
    sb.append("    deletePackages: ").append(toIndentedString(deletePackages)).append("\n");
    sb.append("    deletedAt: ").append(toIndentedString(deletedAt)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    distributes: ").append(toIndentedString(distributes)).append("\n");
    sb.append("    dockerRefreshTokensEnabled: ").append(toIndentedString(dockerRefreshTokensEnabled)).append("\n");
    sb.append("    gpgKeys: ").append(toIndentedString(gpgKeys)).append("\n");
    sb.append("    indexFiles: ").append(toIndentedString(indexFiles)).append("\n");
    sb.append("    isOpenSource: ").append(toIndentedString(isOpenSource)).append("\n");
    sb.append("    isPrivate: ").append(toIndentedString(isPrivate)).append("\n");
    sb.append("    isPublic: ").append(toIndentedString(isPublic)).append("\n");
    sb.append("    moveOwn: ").append(toIndentedString(moveOwn)).append("\n");
    sb.append("    movePackages: ").append(toIndentedString(movePackages)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    namespace: ").append(toIndentedString(namespace)).append("\n");
    sb.append("    namespaceUrl: ").append(toIndentedString(namespaceUrl)).append("\n");
    sb.append("    numDownloads: ").append(toIndentedString(numDownloads)).append("\n");
    sb.append("    packageCount: ").append(toIndentedString(packageCount)).append("\n");
    sb.append("    packageGroupCount: ").append(toIndentedString(packageGroupCount)).append("\n");
    sb.append("    proxyNpmjs: ").append(toIndentedString(proxyNpmjs)).append("\n");
    sb.append("    proxyPypi: ").append(toIndentedString(proxyPypi)).append("\n");
    sb.append("    rawPackageIndexEnabled: ").append(toIndentedString(rawPackageIndexEnabled)).append("\n");
    sb.append("    rawPackageIndexSignaturesEnabled: ").append(toIndentedString(rawPackageIndexSignaturesEnabled)).append("\n");
    sb.append("    replacePackages: ").append(toIndentedString(replacePackages)).append("\n");
    sb.append("    replacePackagesByDefault: ").append(toIndentedString(replacePackagesByDefault)).append("\n");
    sb.append("    repositoryType: ").append(toIndentedString(repositoryType)).append("\n");
    sb.append("    repositoryTypeStr: ").append(toIndentedString(repositoryTypeStr)).append("\n");
    sb.append("    resyncOwn: ").append(toIndentedString(resyncOwn)).append("\n");
    sb.append("    resyncPackages: ").append(toIndentedString(resyncPackages)).append("\n");
    sb.append("    scanOwn: ").append(toIndentedString(scanOwn)).append("\n");
    sb.append("    scanPackages: ").append(toIndentedString(scanPackages)).append("\n");
    sb.append("    selfHtmlUrl: ").append(toIndentedString(selfHtmlUrl)).append("\n");
    sb.append("    selfUrl: ").append(toIndentedString(selfUrl)).append("\n");
    sb.append("    showSetupAll: ").append(toIndentedString(showSetupAll)).append("\n");
    sb.append("    size: ").append(toIndentedString(size)).append("\n");
    sb.append("    sizeStr: ").append(toIndentedString(sizeStr)).append("\n");
    sb.append("    slug: ").append(toIndentedString(slug)).append("\n");
    sb.append("    slugPerm: ").append(toIndentedString(slugPerm)).append("\n");
    sb.append("    storageRegion: ").append(toIndentedString(storageRegion)).append("\n");
    sb.append("    strictNpmValidation: ").append(toIndentedString(strictNpmValidation)).append("\n");
    sb.append("    useDebianLabels: ").append(toIndentedString(useDebianLabels)).append("\n");
    sb.append("    useDefaultCargoUpstream: ").append(toIndentedString(useDefaultCargoUpstream)).append("\n");
    sb.append("    useNoarchPackages: ").append(toIndentedString(useNoarchPackages)).append("\n");
    sb.append("    useSourcePackages: ").append(toIndentedString(useSourcePackages)).append("\n");
    sb.append("    useVulnerabilityScanning: ").append(toIndentedString(useVulnerabilityScanning)).append("\n");
    sb.append("    userEntitlementsEnabled: ").append(toIndentedString(userEntitlementsEnabled)).append("\n");
    sb.append("    viewStatistics: ").append(toIndentedString(viewStatistics)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

