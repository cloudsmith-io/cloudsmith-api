/*
 * Cloudsmith API (v1)
 * The API to the Cloudsmith Service
 *
 * OpenAPI spec version: v1
 * Contact: support@cloudsmith.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.cloudsmith.api.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.io.Serializable;
import javax.validation.constraints.*;
import javax.validation.Valid;

/**
 * RepositoryTokenRequest
 */

public class RepositoryTokenRequest implements Serializable {
  private static final long serialVersionUID = 1L;

  @SerializedName("eula_required")
  private Boolean eulaRequired = null;

  @SerializedName("is_active")
  private Boolean isActive = null;

  @SerializedName("limit_bandwidth")
  private java.math.BigInteger limitBandwidth = null;

  /**
   * Gets or Sets limitBandwidthUnit
   */
  @JsonAdapter(LimitBandwidthUnitEnum.Adapter.class)
  public enum LimitBandwidthUnitEnum {
    BYTE("Byte"),
    
    KILOBYTE("Kilobyte"),
    
    MEGABYTE("Megabyte"),
    
    GIGABYTE("Gigabyte"),
    
    TERABYTE("Terabyte"),
    
    PETABYTE("Petabyte"),
    
    EXABYTE("Exabyte"),
    
    ZETTABYTE("Zettabyte"),
    
    YOTTABYTE("Yottabyte");

    private String value;

    LimitBandwidthUnitEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LimitBandwidthUnitEnum fromValue(String text) {
      for (LimitBandwidthUnitEnum b : LimitBandwidthUnitEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<LimitBandwidthUnitEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LimitBandwidthUnitEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LimitBandwidthUnitEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return LimitBandwidthUnitEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("limit_bandwidth_unit")
  private LimitBandwidthUnitEnum limitBandwidthUnit = LimitBandwidthUnitEnum.BYTE;

  @SerializedName("limit_date_range_from")
  private OffsetDateTime limitDateRangeFrom = null;

  @SerializedName("limit_date_range_to")
  private OffsetDateTime limitDateRangeTo = null;

  @SerializedName("limit_num_clients")
  private java.math.BigInteger limitNumClients = null;

  @SerializedName("limit_num_downloads")
  private java.math.BigInteger limitNumDownloads = null;

  @SerializedName("limit_package_query")
  private String limitPackageQuery = null;

  @SerializedName("limit_path_query")
  private String limitPathQuery = null;

  @SerializedName("metadata")
  private Object metadata = null;

  @SerializedName("name")
  private String name = null;

  @SerializedName("scheduled_reset_at")
  private OffsetDateTime scheduledResetAt = null;

  /**
   * Gets or Sets scheduledResetPeriod
   */
  @JsonAdapter(ScheduledResetPeriodEnum.Adapter.class)
  public enum ScheduledResetPeriodEnum {
    NEVER_RESET("Never Reset"),
    
    DAILY("Daily"),
    
    WEEKLY("Weekly"),
    
    FORTNIGHTLY("Fortnightly"),
    
    MONTHLY("Monthly"),
    
    BI_MONTHLY("Bi-Monthly"),
    
    QUARTERLY("Quarterly"),
    
    EVERY_6_MONTHS("Every 6 months"),
    
    ANNUAL("Annual");

    private String value;

    ScheduledResetPeriodEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ScheduledResetPeriodEnum fromValue(String text) {
      for (ScheduledResetPeriodEnum b : ScheduledResetPeriodEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ScheduledResetPeriodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ScheduledResetPeriodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ScheduledResetPeriodEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ScheduledResetPeriodEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("scheduled_reset_period")
  private ScheduledResetPeriodEnum scheduledResetPeriod = ScheduledResetPeriodEnum.NEVER_RESET;

  @SerializedName("token")
  private String token = null;

  public RepositoryTokenRequest eulaRequired(Boolean eulaRequired) {
    this.eulaRequired = eulaRequired;
    return this;
  }

   /**
   * If checked, a EULA acceptance is required for this token.
   * @return eulaRequired
  **/
  @ApiModelProperty(value = "If checked, a EULA acceptance is required for this token.")
  public Boolean isEulaRequired() {
    return eulaRequired;
  }

  public void setEulaRequired(Boolean eulaRequired) {
    this.eulaRequired = eulaRequired;
  }

  public RepositoryTokenRequest isActive(Boolean isActive) {
    this.isActive = isActive;
    return this;
  }

   /**
   * If enabled, the token will allow downloads based on configured restrictions (if any).
   * @return isActive
  **/
  @ApiModelProperty(value = "If enabled, the token will allow downloads based on configured restrictions (if any).")
  public Boolean isIsActive() {
    return isActive;
  }

  public void setIsActive(Boolean isActive) {
    this.isActive = isActive;
  }

  public RepositoryTokenRequest limitBandwidth(java.math.BigInteger limitBandwidth) {
    this.limitBandwidth = limitBandwidth;
    return this;
  }

   /**
   * The maximum download bandwidth allowed for the token. Values are expressed as the selected unit of bandwidth. Please note that since downloads are calculated asynchronously (after the download happens), the limit may not be imposed immediately but at a later point. 
   * minimum: -9223372036854775808
   * maximum: 9223372036854775807
   * @return limitBandwidth
  **/
 @Min(-9223372036854775808L) @Max(9223372036854775807L)  @ApiModelProperty(value = "The maximum download bandwidth allowed for the token. Values are expressed as the selected unit of bandwidth. Please note that since downloads are calculated asynchronously (after the download happens), the limit may not be imposed immediately but at a later point. ")
  public java.math.BigInteger getLimitBandwidth() {
    return limitBandwidth;
  }

  public void setLimitBandwidth(java.math.BigInteger limitBandwidth) {
    this.limitBandwidth = limitBandwidth;
  }

  public RepositoryTokenRequest limitBandwidthUnit(LimitBandwidthUnitEnum limitBandwidthUnit) {
    this.limitBandwidthUnit = limitBandwidthUnit;
    return this;
  }

   /**
   * Get limitBandwidthUnit
   * @return limitBandwidthUnit
  **/
  @ApiModelProperty(value = "")
  public LimitBandwidthUnitEnum getLimitBandwidthUnit() {
    return limitBandwidthUnit;
  }

  public void setLimitBandwidthUnit(LimitBandwidthUnitEnum limitBandwidthUnit) {
    this.limitBandwidthUnit = limitBandwidthUnit;
  }

  public RepositoryTokenRequest limitDateRangeFrom(OffsetDateTime limitDateRangeFrom) {
    this.limitDateRangeFrom = limitDateRangeFrom;
    return this;
  }

   /**
   * The starting date/time the token is allowed to be used from.
   * @return limitDateRangeFrom
  **/
  @Valid
  @ApiModelProperty(value = "The starting date/time the token is allowed to be used from.")
  public OffsetDateTime getLimitDateRangeFrom() {
    return limitDateRangeFrom;
  }

  public void setLimitDateRangeFrom(OffsetDateTime limitDateRangeFrom) {
    this.limitDateRangeFrom = limitDateRangeFrom;
  }

  public RepositoryTokenRequest limitDateRangeTo(OffsetDateTime limitDateRangeTo) {
    this.limitDateRangeTo = limitDateRangeTo;
    return this;
  }

   /**
   * The ending date/time the token is allowed to be used until.
   * @return limitDateRangeTo
  **/
  @Valid
  @ApiModelProperty(value = "The ending date/time the token is allowed to be used until.")
  public OffsetDateTime getLimitDateRangeTo() {
    return limitDateRangeTo;
  }

  public void setLimitDateRangeTo(OffsetDateTime limitDateRangeTo) {
    this.limitDateRangeTo = limitDateRangeTo;
  }

  public RepositoryTokenRequest limitNumClients(java.math.BigInteger limitNumClients) {
    this.limitNumClients = limitNumClients;
    return this;
  }

   /**
   * The maximum number of unique clients allowed for the token. Please note that since clients are calculated asynchronously (after the download happens), the limit may not be imposed immediately but at a later point.
   * minimum: -9223372036854775808
   * maximum: 9223372036854775807
   * @return limitNumClients
  **/
 @Min(-9223372036854775808L) @Max(9223372036854775807L)  @ApiModelProperty(value = "The maximum number of unique clients allowed for the token. Please note that since clients are calculated asynchronously (after the download happens), the limit may not be imposed immediately but at a later point.")
  public java.math.BigInteger getLimitNumClients() {
    return limitNumClients;
  }

  public void setLimitNumClients(java.math.BigInteger limitNumClients) {
    this.limitNumClients = limitNumClients;
  }

  public RepositoryTokenRequest limitNumDownloads(java.math.BigInteger limitNumDownloads) {
    this.limitNumDownloads = limitNumDownloads;
    return this;
  }

   /**
   * The maximum number of downloads allowed for the token. Please note that since downloads are calculated asynchronously (after the download happens), the limit may not be imposed immediately but at a later point.
   * minimum: -9223372036854775808
   * maximum: 9223372036854775807
   * @return limitNumDownloads
  **/
 @Min(-9223372036854775808L) @Max(9223372036854775807L)  @ApiModelProperty(value = "The maximum number of downloads allowed for the token. Please note that since downloads are calculated asynchronously (after the download happens), the limit may not be imposed immediately but at a later point.")
  public java.math.BigInteger getLimitNumDownloads() {
    return limitNumDownloads;
  }

  public void setLimitNumDownloads(java.math.BigInteger limitNumDownloads) {
    this.limitNumDownloads = limitNumDownloads;
  }

  public RepositoryTokenRequest limitPackageQuery(String limitPackageQuery) {
    this.limitPackageQuery = limitPackageQuery;
    return this;
  }

   /**
   * The package-based search query to apply to restrict downloads to. This uses the same syntax as the standard search used for repositories, and also supports boolean logic operators such as OR/AND/NOT and parentheses for grouping. This will still allow access to non-package files, such as metadata.
   * @return limitPackageQuery
  **/
 @Size(max=1024)  @ApiModelProperty(value = "The package-based search query to apply to restrict downloads to. This uses the same syntax as the standard search used for repositories, and also supports boolean logic operators such as OR/AND/NOT and parentheses for grouping. This will still allow access to non-package files, such as metadata.")
  public String getLimitPackageQuery() {
    return limitPackageQuery;
  }

  public void setLimitPackageQuery(String limitPackageQuery) {
    this.limitPackageQuery = limitPackageQuery;
  }

  public RepositoryTokenRequest limitPathQuery(String limitPathQuery) {
    this.limitPathQuery = limitPathQuery;
    return this;
  }

   /**
   * The path-based search query to apply to restrict downloads to. This supports boolean logic operators such as OR/AND/NOT and parentheses for grouping. The path evaluated does not include the domain name, the namespace, the entitlement code used, the package format, etc. and it always starts with a forward slash.
   * @return limitPathQuery
  **/
 @Size(max=1024)  @ApiModelProperty(value = "The path-based search query to apply to restrict downloads to. This supports boolean logic operators such as OR/AND/NOT and parentheses for grouping. The path evaluated does not include the domain name, the namespace, the entitlement code used, the package format, etc. and it always starts with a forward slash.")
  public String getLimitPathQuery() {
    return limitPathQuery;
  }

  public void setLimitPathQuery(String limitPathQuery) {
    this.limitPathQuery = limitPathQuery;
  }

  public RepositoryTokenRequest metadata(Object metadata) {
    this.metadata = metadata;
    return this;
  }

   /**
   * Get metadata
   * @return metadata
  **/
  @ApiModelProperty(value = "")
  public Object getMetadata() {
    return metadata;
  }

  public void setMetadata(Object metadata) {
    this.metadata = metadata;
  }

  public RepositoryTokenRequest name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Get name
   * @return name
  **/
  @NotNull
 @Size(min=1)  @ApiModelProperty(required = true, value = "")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public RepositoryTokenRequest scheduledResetAt(OffsetDateTime scheduledResetAt) {
    this.scheduledResetAt = scheduledResetAt;
    return this;
  }

   /**
   * The time at which the scheduled reset period has elapsed and the token limits were automatically reset to zero.
   * @return scheduledResetAt
  **/
  @Valid
  @ApiModelProperty(value = "The time at which the scheduled reset period has elapsed and the token limits were automatically reset to zero.")
  public OffsetDateTime getScheduledResetAt() {
    return scheduledResetAt;
  }

  public void setScheduledResetAt(OffsetDateTime scheduledResetAt) {
    this.scheduledResetAt = scheduledResetAt;
  }

  public RepositoryTokenRequest scheduledResetPeriod(ScheduledResetPeriodEnum scheduledResetPeriod) {
    this.scheduledResetPeriod = scheduledResetPeriod;
    return this;
  }

   /**
   * Get scheduledResetPeriod
   * @return scheduledResetPeriod
  **/
  @ApiModelProperty(value = "")
  public ScheduledResetPeriodEnum getScheduledResetPeriod() {
    return scheduledResetPeriod;
  }

  public void setScheduledResetPeriod(ScheduledResetPeriodEnum scheduledResetPeriod) {
    this.scheduledResetPeriod = scheduledResetPeriod;
  }

  public RepositoryTokenRequest token(String token) {
    this.token = token;
    return this;
  }

   /**
   * Get token
   * @return token
  **/
 @Size(min=1)  @ApiModelProperty(value = "")
  public String getToken() {
    return token;
  }

  public void setToken(String token) {
    this.token = token;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RepositoryTokenRequest repositoryTokenRequest = (RepositoryTokenRequest) o;
    return Objects.equals(this.eulaRequired, repositoryTokenRequest.eulaRequired) &&
        Objects.equals(this.isActive, repositoryTokenRequest.isActive) &&
        Objects.equals(this.limitBandwidth, repositoryTokenRequest.limitBandwidth) &&
        Objects.equals(this.limitBandwidthUnit, repositoryTokenRequest.limitBandwidthUnit) &&
        Objects.equals(this.limitDateRangeFrom, repositoryTokenRequest.limitDateRangeFrom) &&
        Objects.equals(this.limitDateRangeTo, repositoryTokenRequest.limitDateRangeTo) &&
        Objects.equals(this.limitNumClients, repositoryTokenRequest.limitNumClients) &&
        Objects.equals(this.limitNumDownloads, repositoryTokenRequest.limitNumDownloads) &&
        Objects.equals(this.limitPackageQuery, repositoryTokenRequest.limitPackageQuery) &&
        Objects.equals(this.limitPathQuery, repositoryTokenRequest.limitPathQuery) &&
        Objects.equals(this.metadata, repositoryTokenRequest.metadata) &&
        Objects.equals(this.name, repositoryTokenRequest.name) &&
        Objects.equals(this.scheduledResetAt, repositoryTokenRequest.scheduledResetAt) &&
        Objects.equals(this.scheduledResetPeriod, repositoryTokenRequest.scheduledResetPeriod) &&
        Objects.equals(this.token, repositoryTokenRequest.token);
  }

  @Override
  public int hashCode() {
    return Objects.hash(eulaRequired, isActive, limitBandwidth, limitBandwidthUnit, limitDateRangeFrom, limitDateRangeTo, limitNumClients, limitNumDownloads, limitPackageQuery, limitPathQuery, metadata, name, scheduledResetAt, scheduledResetPeriod, token);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RepositoryTokenRequest {\n");
    
    sb.append("    eulaRequired: ").append(toIndentedString(eulaRequired)).append("\n");
    sb.append("    isActive: ").append(toIndentedString(isActive)).append("\n");
    sb.append("    limitBandwidth: ").append(toIndentedString(limitBandwidth)).append("\n");
    sb.append("    limitBandwidthUnit: ").append(toIndentedString(limitBandwidthUnit)).append("\n");
    sb.append("    limitDateRangeFrom: ").append(toIndentedString(limitDateRangeFrom)).append("\n");
    sb.append("    limitDateRangeTo: ").append(toIndentedString(limitDateRangeTo)).append("\n");
    sb.append("    limitNumClients: ").append(toIndentedString(limitNumClients)).append("\n");
    sb.append("    limitNumDownloads: ").append(toIndentedString(limitNumDownloads)).append("\n");
    sb.append("    limitPackageQuery: ").append(toIndentedString(limitPackageQuery)).append("\n");
    sb.append("    limitPathQuery: ").append(toIndentedString(limitPathQuery)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    scheduledResetAt: ").append(toIndentedString(scheduledResetAt)).append("\n");
    sb.append("    scheduledResetPeriod: ").append(toIndentedString(scheduledResetPeriod)).append("\n");
    sb.append("    token: ").append(toIndentedString(token)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

