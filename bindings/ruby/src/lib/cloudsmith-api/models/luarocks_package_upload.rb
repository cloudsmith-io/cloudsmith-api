=begin
#Cloudsmith API (v1)

#The API to the Cloudsmith Service

OpenAPI spec version: v1
Contact: support@cloudsmith.io
Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.4.43

=end

require 'date'

module CloudsmithApi
class LuarocksPackageUpload
  attr_accessor :architectures

  attr_accessor :cdn_url

  attr_accessor :checksum_md5

  attr_accessor :checksum_sha1

  attr_accessor :checksum_sha256

  attr_accessor :checksum_sha512

  # A checksum of all of the package's dependencies.
  attr_accessor :dependencies_checksum_md5

  attr_accessor :dependencies_url

  # A textual description of this package.
  attr_accessor :description

  attr_accessor :display_name

  attr_accessor :distro

  attr_accessor :distro_version

  attr_accessor :downloads

  # The epoch of the package version (if any).
  attr_accessor :epoch

  attr_accessor :extension

  attr_accessor :filename

  attr_accessor :files

  attr_accessor :format

  attr_accessor :format_url

  # Amount of storage that will be freed if this package is deleted
  attr_accessor :freeable_storage

  attr_accessor :fully_qualified_name

  # Unique and permanent identifier for the package.
  attr_accessor :identifier_perm

  # Return a map of identifier field names and their values.
  attr_accessor :identifiers

  attr_accessor :indexed

  attr_accessor :is_cancellable

  attr_accessor :is_copyable

  attr_accessor :is_deleteable

  attr_accessor :is_downloadable

  attr_accessor :is_moveable

  attr_accessor :is_quarantinable

  attr_accessor :is_quarantined

  attr_accessor :is_resyncable

  attr_accessor :is_security_scannable

  attr_accessor :is_sync_awaiting

  attr_accessor :is_sync_completed

  attr_accessor :is_sync_failed

  attr_accessor :is_sync_in_flight

  attr_accessor :is_sync_in_progress

  # The license of this package.
  attr_accessor :license

  # The name of this package.
  attr_accessor :name

  attr_accessor :namespace

  attr_accessor :namespace_url

  attr_accessor :num_files

  attr_accessor :origin_repository

  attr_accessor :origin_repository_url

  # The type of package contents.
  attr_accessor :package_type

  # Whether or not the package has violated any policy.
  attr_accessor :policy_violated

  # The release of the package version (if any).
  attr_accessor :release

  attr_accessor :repository

  attr_accessor :repository_url

  # The datetime the security scanning was completed.
  attr_accessor :security_scan_completed_at

  # The datetime the security scanning was started.
  attr_accessor :security_scan_started_at

  attr_accessor :security_scan_status

  # The datetime the security scanning status was updated.
  attr_accessor :security_scan_status_updated_at

  attr_accessor :self_html_url

  attr_accessor :self_url

  attr_accessor :signature_url

  # The calculated size of the package.
  attr_accessor :size

  # The public unique identifier for the package.
  attr_accessor :slug

  attr_accessor :slug_perm

  # The synchronisation (in progress) stage of the package.
  attr_accessor :stage

  attr_accessor :stage_str

  # The datetime the package stage was updated at.
  attr_accessor :stage_updated_at

  # The synchronisation status of the package.
  attr_accessor :status

  # A textual description for the synchronous status reason (if any
  attr_accessor :status_reason

  attr_accessor :status_str

  # The datetime the package status was updated at.
  attr_accessor :status_updated_at

  attr_accessor :status_url

  attr_accessor :subtype

  # A one-liner synopsis of this package.
  attr_accessor :summary

  # The datetime the package sync was finished at.
  attr_accessor :sync_finished_at

  # Synchronisation progress (from 0-100)
  attr_accessor :sync_progress

  attr_accessor :tags_immutable

  attr_accessor :type_display

  # The date this package was uploaded.
  attr_accessor :uploaded_at

  attr_accessor :uploader

  attr_accessor :uploader_url

  # The raw version for this package.
  attr_accessor :version

  attr_accessor :version_orig

  attr_accessor :vulnerability_scan_results_url

  class EnumAttributeValidator
    attr_reader :datatype
    attr_reader :allowable_values

    def initialize(datatype, allowable_values)
      @allowable_values = allowable_values.map do |value|
        case datatype.to_s
        when /Integer/i
          value.to_i
        when /Float/i
          value.to_f
        else
          value
        end
      end
    end

    def valid?(value)
      !value || allowable_values.include?(value)
    end
  end

  # Attribute mapping from ruby-style variable name to JSON key.
  def self.attribute_map
    {
      :'architectures' => :'architectures',
      :'cdn_url' => :'cdn_url',
      :'checksum_md5' => :'checksum_md5',
      :'checksum_sha1' => :'checksum_sha1',
      :'checksum_sha256' => :'checksum_sha256',
      :'checksum_sha512' => :'checksum_sha512',
      :'dependencies_checksum_md5' => :'dependencies_checksum_md5',
      :'dependencies_url' => :'dependencies_url',
      :'description' => :'description',
      :'display_name' => :'display_name',
      :'distro' => :'distro',
      :'distro_version' => :'distro_version',
      :'downloads' => :'downloads',
      :'epoch' => :'epoch',
      :'extension' => :'extension',
      :'filename' => :'filename',
      :'files' => :'files',
      :'format' => :'format',
      :'format_url' => :'format_url',
      :'freeable_storage' => :'freeable_storage',
      :'fully_qualified_name' => :'fully_qualified_name',
      :'identifier_perm' => :'identifier_perm',
      :'identifiers' => :'identifiers',
      :'indexed' => :'indexed',
      :'is_cancellable' => :'is_cancellable',
      :'is_copyable' => :'is_copyable',
      :'is_deleteable' => :'is_deleteable',
      :'is_downloadable' => :'is_downloadable',
      :'is_moveable' => :'is_moveable',
      :'is_quarantinable' => :'is_quarantinable',
      :'is_quarantined' => :'is_quarantined',
      :'is_resyncable' => :'is_resyncable',
      :'is_security_scannable' => :'is_security_scannable',
      :'is_sync_awaiting' => :'is_sync_awaiting',
      :'is_sync_completed' => :'is_sync_completed',
      :'is_sync_failed' => :'is_sync_failed',
      :'is_sync_in_flight' => :'is_sync_in_flight',
      :'is_sync_in_progress' => :'is_sync_in_progress',
      :'license' => :'license',
      :'name' => :'name',
      :'namespace' => :'namespace',
      :'namespace_url' => :'namespace_url',
      :'num_files' => :'num_files',
      :'origin_repository' => :'origin_repository',
      :'origin_repository_url' => :'origin_repository_url',
      :'package_type' => :'package_type',
      :'policy_violated' => :'policy_violated',
      :'release' => :'release',
      :'repository' => :'repository',
      :'repository_url' => :'repository_url',
      :'security_scan_completed_at' => :'security_scan_completed_at',
      :'security_scan_started_at' => :'security_scan_started_at',
      :'security_scan_status' => :'security_scan_status',
      :'security_scan_status_updated_at' => :'security_scan_status_updated_at',
      :'self_html_url' => :'self_html_url',
      :'self_url' => :'self_url',
      :'signature_url' => :'signature_url',
      :'size' => :'size',
      :'slug' => :'slug',
      :'slug_perm' => :'slug_perm',
      :'stage' => :'stage',
      :'stage_str' => :'stage_str',
      :'stage_updated_at' => :'stage_updated_at',
      :'status' => :'status',
      :'status_reason' => :'status_reason',
      :'status_str' => :'status_str',
      :'status_updated_at' => :'status_updated_at',
      :'status_url' => :'status_url',
      :'subtype' => :'subtype',
      :'summary' => :'summary',
      :'sync_finished_at' => :'sync_finished_at',
      :'sync_progress' => :'sync_progress',
      :'tags_immutable' => :'tags_immutable',
      :'type_display' => :'type_display',
      :'uploaded_at' => :'uploaded_at',
      :'uploader' => :'uploader',
      :'uploader_url' => :'uploader_url',
      :'version' => :'version',
      :'version_orig' => :'version_orig',
      :'vulnerability_scan_results_url' => :'vulnerability_scan_results_url'
    }
  end

  # Attribute type mapping.
  def self.swagger_types
    {
      :'architectures' => :'Array<Architecture>',
      :'cdn_url' => :'String',
      :'checksum_md5' => :'String',
      :'checksum_sha1' => :'String',
      :'checksum_sha256' => :'String',
      :'checksum_sha512' => :'String',
      :'dependencies_checksum_md5' => :'String',
      :'dependencies_url' => :'String',
      :'description' => :'String',
      :'display_name' => :'String',
      :'distro' => :'Distribution',
      :'distro_version' => :'DistributionVersion',
      :'downloads' => :'Integer',
      :'epoch' => :'Integer',
      :'extension' => :'String',
      :'filename' => :'String',
      :'files' => :'Array<PackageFile>',
      :'format' => :'String',
      :'format_url' => :'String',
      :'freeable_storage' => :'Integer',
      :'fully_qualified_name' => :'String',
      :'identifier_perm' => :'String',
      :'identifiers' => :'Hash<String, String>',
      :'indexed' => :'BOOLEAN',
      :'is_cancellable' => :'BOOLEAN',
      :'is_copyable' => :'BOOLEAN',
      :'is_deleteable' => :'BOOLEAN',
      :'is_downloadable' => :'BOOLEAN',
      :'is_moveable' => :'BOOLEAN',
      :'is_quarantinable' => :'BOOLEAN',
      :'is_quarantined' => :'BOOLEAN',
      :'is_resyncable' => :'BOOLEAN',
      :'is_security_scannable' => :'BOOLEAN',
      :'is_sync_awaiting' => :'BOOLEAN',
      :'is_sync_completed' => :'BOOLEAN',
      :'is_sync_failed' => :'BOOLEAN',
      :'is_sync_in_flight' => :'BOOLEAN',
      :'is_sync_in_progress' => :'BOOLEAN',
      :'license' => :'String',
      :'name' => :'String',
      :'namespace' => :'String',
      :'namespace_url' => :'String',
      :'num_files' => :'Integer',
      :'origin_repository' => :'String',
      :'origin_repository_url' => :'String',
      :'package_type' => :'Integer',
      :'policy_violated' => :'BOOLEAN',
      :'release' => :'String',
      :'repository' => :'String',
      :'repository_url' => :'String',
      :'security_scan_completed_at' => :'DateTime',
      :'security_scan_started_at' => :'DateTime',
      :'security_scan_status' => :'String',
      :'security_scan_status_updated_at' => :'DateTime',
      :'self_html_url' => :'String',
      :'self_url' => :'String',
      :'signature_url' => :'String',
      :'size' => :'Integer',
      :'slug' => :'String',
      :'slug_perm' => :'String',
      :'stage' => :'Integer',
      :'stage_str' => :'String',
      :'stage_updated_at' => :'DateTime',
      :'status' => :'Integer',
      :'status_reason' => :'String',
      :'status_str' => :'String',
      :'status_updated_at' => :'DateTime',
      :'status_url' => :'String',
      :'subtype' => :'String',
      :'summary' => :'String',
      :'sync_finished_at' => :'DateTime',
      :'sync_progress' => :'Integer',
      :'tags_immutable' => :'Tags',
      :'type_display' => :'String',
      :'uploaded_at' => :'DateTime',
      :'uploader' => :'String',
      :'uploader_url' => :'String',
      :'version' => :'String',
      :'version_orig' => :'String',
      :'vulnerability_scan_results_url' => :'String'
    }
  end

  # Initializes the object
  # @param [Hash] attributes Model attributes in the form of hash
  def initialize(attributes = {})
    return unless attributes.is_a?(Hash)

    # convert string to symbol for hash key
    attributes = attributes.each_with_object({}) { |(k, v), h| h[k.to_sym] = v }

    if attributes.has_key?(:'architectures')
      if (value = attributes[:'architectures']).is_a?(Array)
        self.architectures = value
      end
    end

    if attributes.has_key?(:'cdn_url')
      self.cdn_url = attributes[:'cdn_url']
    end

    if attributes.has_key?(:'checksum_md5')
      self.checksum_md5 = attributes[:'checksum_md5']
    end

    if attributes.has_key?(:'checksum_sha1')
      self.checksum_sha1 = attributes[:'checksum_sha1']
    end

    if attributes.has_key?(:'checksum_sha256')
      self.checksum_sha256 = attributes[:'checksum_sha256']
    end

    if attributes.has_key?(:'checksum_sha512')
      self.checksum_sha512 = attributes[:'checksum_sha512']
    end

    if attributes.has_key?(:'dependencies_checksum_md5')
      self.dependencies_checksum_md5 = attributes[:'dependencies_checksum_md5']
    end

    if attributes.has_key?(:'dependencies_url')
      self.dependencies_url = attributes[:'dependencies_url']
    end

    if attributes.has_key?(:'description')
      self.description = attributes[:'description']
    end

    if attributes.has_key?(:'display_name')
      self.display_name = attributes[:'display_name']
    end

    if attributes.has_key?(:'distro')
      self.distro = attributes[:'distro']
    end

    if attributes.has_key?(:'distro_version')
      self.distro_version = attributes[:'distro_version']
    end

    if attributes.has_key?(:'downloads')
      self.downloads = attributes[:'downloads']
    end

    if attributes.has_key?(:'epoch')
      self.epoch = attributes[:'epoch']
    end

    if attributes.has_key?(:'extension')
      self.extension = attributes[:'extension']
    end

    if attributes.has_key?(:'filename')
      self.filename = attributes[:'filename']
    end

    if attributes.has_key?(:'files')
      if (value = attributes[:'files']).is_a?(Array)
        self.files = value
      end
    end

    if attributes.has_key?(:'format')
      self.format = attributes[:'format']
    end

    if attributes.has_key?(:'format_url')
      self.format_url = attributes[:'format_url']
    end

    if attributes.has_key?(:'freeable_storage')
      self.freeable_storage = attributes[:'freeable_storage']
    end

    if attributes.has_key?(:'fully_qualified_name')
      self.fully_qualified_name = attributes[:'fully_qualified_name']
    end

    if attributes.has_key?(:'identifier_perm')
      self.identifier_perm = attributes[:'identifier_perm']
    end

    if attributes.has_key?(:'identifiers')
      if (value = attributes[:'identifiers']).is_a?(Hash)
        self.identifiers = value
      end
    end

    if attributes.has_key?(:'indexed')
      self.indexed = attributes[:'indexed']
    end

    if attributes.has_key?(:'is_cancellable')
      self.is_cancellable = attributes[:'is_cancellable']
    end

    if attributes.has_key?(:'is_copyable')
      self.is_copyable = attributes[:'is_copyable']
    end

    if attributes.has_key?(:'is_deleteable')
      self.is_deleteable = attributes[:'is_deleteable']
    end

    if attributes.has_key?(:'is_downloadable')
      self.is_downloadable = attributes[:'is_downloadable']
    end

    if attributes.has_key?(:'is_moveable')
      self.is_moveable = attributes[:'is_moveable']
    end

    if attributes.has_key?(:'is_quarantinable')
      self.is_quarantinable = attributes[:'is_quarantinable']
    end

    if attributes.has_key?(:'is_quarantined')
      self.is_quarantined = attributes[:'is_quarantined']
    end

    if attributes.has_key?(:'is_resyncable')
      self.is_resyncable = attributes[:'is_resyncable']
    end

    if attributes.has_key?(:'is_security_scannable')
      self.is_security_scannable = attributes[:'is_security_scannable']
    end

    if attributes.has_key?(:'is_sync_awaiting')
      self.is_sync_awaiting = attributes[:'is_sync_awaiting']
    end

    if attributes.has_key?(:'is_sync_completed')
      self.is_sync_completed = attributes[:'is_sync_completed']
    end

    if attributes.has_key?(:'is_sync_failed')
      self.is_sync_failed = attributes[:'is_sync_failed']
    end

    if attributes.has_key?(:'is_sync_in_flight')
      self.is_sync_in_flight = attributes[:'is_sync_in_flight']
    end

    if attributes.has_key?(:'is_sync_in_progress')
      self.is_sync_in_progress = attributes[:'is_sync_in_progress']
    end

    if attributes.has_key?(:'license')
      self.license = attributes[:'license']
    end

    if attributes.has_key?(:'name')
      self.name = attributes[:'name']
    end

    if attributes.has_key?(:'namespace')
      self.namespace = attributes[:'namespace']
    end

    if attributes.has_key?(:'namespace_url')
      self.namespace_url = attributes[:'namespace_url']
    end

    if attributes.has_key?(:'num_files')
      self.num_files = attributes[:'num_files']
    end

    if attributes.has_key?(:'origin_repository')
      self.origin_repository = attributes[:'origin_repository']
    end

    if attributes.has_key?(:'origin_repository_url')
      self.origin_repository_url = attributes[:'origin_repository_url']
    end

    if attributes.has_key?(:'package_type')
      self.package_type = attributes[:'package_type']
    end

    if attributes.has_key?(:'policy_violated')
      self.policy_violated = attributes[:'policy_violated']
    end

    if attributes.has_key?(:'release')
      self.release = attributes[:'release']
    end

    if attributes.has_key?(:'repository')
      self.repository = attributes[:'repository']
    end

    if attributes.has_key?(:'repository_url')
      self.repository_url = attributes[:'repository_url']
    end

    if attributes.has_key?(:'security_scan_completed_at')
      self.security_scan_completed_at = attributes[:'security_scan_completed_at']
    end

    if attributes.has_key?(:'security_scan_started_at')
      self.security_scan_started_at = attributes[:'security_scan_started_at']
    end

    if attributes.has_key?(:'security_scan_status')
      self.security_scan_status = attributes[:'security_scan_status']
    else
      self.security_scan_status = 'Awaiting Security Scan'
    end

    if attributes.has_key?(:'security_scan_status_updated_at')
      self.security_scan_status_updated_at = attributes[:'security_scan_status_updated_at']
    end

    if attributes.has_key?(:'self_html_url')
      self.self_html_url = attributes[:'self_html_url']
    end

    if attributes.has_key?(:'self_url')
      self.self_url = attributes[:'self_url']
    end

    if attributes.has_key?(:'signature_url')
      self.signature_url = attributes[:'signature_url']
    end

    if attributes.has_key?(:'size')
      self.size = attributes[:'size']
    end

    if attributes.has_key?(:'slug')
      self.slug = attributes[:'slug']
    end

    if attributes.has_key?(:'slug_perm')
      self.slug_perm = attributes[:'slug_perm']
    end

    if attributes.has_key?(:'stage')
      self.stage = attributes[:'stage']
    end

    if attributes.has_key?(:'stage_str')
      self.stage_str = attributes[:'stage_str']
    end

    if attributes.has_key?(:'stage_updated_at')
      self.stage_updated_at = attributes[:'stage_updated_at']
    end

    if attributes.has_key?(:'status')
      self.status = attributes[:'status']
    end

    if attributes.has_key?(:'status_reason')
      self.status_reason = attributes[:'status_reason']
    end

    if attributes.has_key?(:'status_str')
      self.status_str = attributes[:'status_str']
    end

    if attributes.has_key?(:'status_updated_at')
      self.status_updated_at = attributes[:'status_updated_at']
    end

    if attributes.has_key?(:'status_url')
      self.status_url = attributes[:'status_url']
    end

    if attributes.has_key?(:'subtype')
      self.subtype = attributes[:'subtype']
    end

    if attributes.has_key?(:'summary')
      self.summary = attributes[:'summary']
    end

    if attributes.has_key?(:'sync_finished_at')
      self.sync_finished_at = attributes[:'sync_finished_at']
    end

    if attributes.has_key?(:'sync_progress')
      self.sync_progress = attributes[:'sync_progress']
    end

    if attributes.has_key?(:'tags_immutable')
      self.tags_immutable = attributes[:'tags_immutable']
    end

    if attributes.has_key?(:'type_display')
      self.type_display = attributes[:'type_display']
    end

    if attributes.has_key?(:'uploaded_at')
      self.uploaded_at = attributes[:'uploaded_at']
    end

    if attributes.has_key?(:'uploader')
      self.uploader = attributes[:'uploader']
    end

    if attributes.has_key?(:'uploader_url')
      self.uploader_url = attributes[:'uploader_url']
    end

    if attributes.has_key?(:'version')
      self.version = attributes[:'version']
    end

    if attributes.has_key?(:'version_orig')
      self.version_orig = attributes[:'version_orig']
    end

    if attributes.has_key?(:'vulnerability_scan_results_url')
      self.vulnerability_scan_results_url = attributes[:'vulnerability_scan_results_url']
    end
  end

  # Show invalid properties with the reasons. Usually used together with valid?
  # @return Array for valid properties with the reasons
  def list_invalid_properties
    invalid_properties = Array.new
    invalid_properties
  end

  # Check to see if the all the properties in the model are valid
  # @return true if the model is valid
  def valid?
    security_scan_status_validator = EnumAttributeValidator.new('String', ['Awaiting Security Scan', 'Security Scanning in Progress', 'Scan Detected Vulnerabilities', 'Scan Detected No Vulnerabilities', 'Security Scanning Disabled', 'Security Scanning Failed', 'Security Scanning Skipped', 'Security Scanning Not Supported'])
    return false unless security_scan_status_validator.valid?(@security_scan_status)
    true
  end

  # Custom attribute writer method checking allowed values (enum).
  # @param [Object] security_scan_status Object to be assigned
  def security_scan_status=(security_scan_status)
    validator = EnumAttributeValidator.new('String', ['Awaiting Security Scan', 'Security Scanning in Progress', 'Scan Detected Vulnerabilities', 'Scan Detected No Vulnerabilities', 'Security Scanning Disabled', 'Security Scanning Failed', 'Security Scanning Skipped', 'Security Scanning Not Supported'])
    unless validator.valid?(security_scan_status)
      fail ArgumentError, 'invalid value for "security_scan_status", must be one of #{validator.allowable_values}.'
    end
    @security_scan_status = security_scan_status
  end

  # Checks equality by comparing each attribute.
  # @param [Object] Object to be compared
  def ==(o)
    return true if self.equal?(o)
    self.class == o.class &&
        architectures == o.architectures &&
        cdn_url == o.cdn_url &&
        checksum_md5 == o.checksum_md5 &&
        checksum_sha1 == o.checksum_sha1 &&
        checksum_sha256 == o.checksum_sha256 &&
        checksum_sha512 == o.checksum_sha512 &&
        dependencies_checksum_md5 == o.dependencies_checksum_md5 &&
        dependencies_url == o.dependencies_url &&
        description == o.description &&
        display_name == o.display_name &&
        distro == o.distro &&
        distro_version == o.distro_version &&
        downloads == o.downloads &&
        epoch == o.epoch &&
        extension == o.extension &&
        filename == o.filename &&
        files == o.files &&
        format == o.format &&
        format_url == o.format_url &&
        freeable_storage == o.freeable_storage &&
        fully_qualified_name == o.fully_qualified_name &&
        identifier_perm == o.identifier_perm &&
        identifiers == o.identifiers &&
        indexed == o.indexed &&
        is_cancellable == o.is_cancellable &&
        is_copyable == o.is_copyable &&
        is_deleteable == o.is_deleteable &&
        is_downloadable == o.is_downloadable &&
        is_moveable == o.is_moveable &&
        is_quarantinable == o.is_quarantinable &&
        is_quarantined == o.is_quarantined &&
        is_resyncable == o.is_resyncable &&
        is_security_scannable == o.is_security_scannable &&
        is_sync_awaiting == o.is_sync_awaiting &&
        is_sync_completed == o.is_sync_completed &&
        is_sync_failed == o.is_sync_failed &&
        is_sync_in_flight == o.is_sync_in_flight &&
        is_sync_in_progress == o.is_sync_in_progress &&
        license == o.license &&
        name == o.name &&
        namespace == o.namespace &&
        namespace_url == o.namespace_url &&
        num_files == o.num_files &&
        origin_repository == o.origin_repository &&
        origin_repository_url == o.origin_repository_url &&
        package_type == o.package_type &&
        policy_violated == o.policy_violated &&
        release == o.release &&
        repository == o.repository &&
        repository_url == o.repository_url &&
        security_scan_completed_at == o.security_scan_completed_at &&
        security_scan_started_at == o.security_scan_started_at &&
        security_scan_status == o.security_scan_status &&
        security_scan_status_updated_at == o.security_scan_status_updated_at &&
        self_html_url == o.self_html_url &&
        self_url == o.self_url &&
        signature_url == o.signature_url &&
        size == o.size &&
        slug == o.slug &&
        slug_perm == o.slug_perm &&
        stage == o.stage &&
        stage_str == o.stage_str &&
        stage_updated_at == o.stage_updated_at &&
        status == o.status &&
        status_reason == o.status_reason &&
        status_str == o.status_str &&
        status_updated_at == o.status_updated_at &&
        status_url == o.status_url &&
        subtype == o.subtype &&
        summary == o.summary &&
        sync_finished_at == o.sync_finished_at &&
        sync_progress == o.sync_progress &&
        tags_immutable == o.tags_immutable &&
        type_display == o.type_display &&
        uploaded_at == o.uploaded_at &&
        uploader == o.uploader &&
        uploader_url == o.uploader_url &&
        version == o.version &&
        version_orig == o.version_orig &&
        vulnerability_scan_results_url == o.vulnerability_scan_results_url
  end

  # @see the `==` method
  # @param [Object] Object to be compared
  def eql?(o)
    self == o
  end

  # Calculates hash code according to all attributes.
  # @return [Fixnum] Hash code
  def hash
    [architectures, cdn_url, checksum_md5, checksum_sha1, checksum_sha256, checksum_sha512, dependencies_checksum_md5, dependencies_url, description, display_name, distro, distro_version, downloads, epoch, extension, filename, files, format, format_url, freeable_storage, fully_qualified_name, identifier_perm, identifiers, indexed, is_cancellable, is_copyable, is_deleteable, is_downloadable, is_moveable, is_quarantinable, is_quarantined, is_resyncable, is_security_scannable, is_sync_awaiting, is_sync_completed, is_sync_failed, is_sync_in_flight, is_sync_in_progress, license, name, namespace, namespace_url, num_files, origin_repository, origin_repository_url, package_type, policy_violated, release, repository, repository_url, security_scan_completed_at, security_scan_started_at, security_scan_status, security_scan_status_updated_at, self_html_url, self_url, signature_url, size, slug, slug_perm, stage, stage_str, stage_updated_at, status, status_reason, status_str, status_updated_at, status_url, subtype, summary, sync_finished_at, sync_progress, tags_immutable, type_display, uploaded_at, uploader, uploader_url, version, version_orig, vulnerability_scan_results_url].hash
  end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.swagger_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :BOOLEAN
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        temp_model = CloudsmithApi.const_get(type).new
        temp_model.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        next if value.nil?
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end

end
end
